\def\stat{vovchenko}



\def\tit{МЕТОДЫ РАЗРЕШЕНИЯ СУЩНОСТЕЙ И~СЛИЯНИЯ ДАННЫХ
В~ETL-ПРОЦЕССЕ И~ИХ РЕАЛИЗАЦИЯ В~СРЕДЕ HADOOP$^*$}



\def\titkol{Методы разрешения сущностей и~слияния данных
в~ETL-процессе и~их реализация в~среде Hadoop}

\def\aut{А.\,Е.~Вовченко$^1$, Л.\,А.~Калиниченко$^2$, Д.\,Ю.~Ковалев$^3$}

\def\autkol{А.\,Е.~Вовченко, Л.\,А.~Калиниченко, Д.\,Ю.~Ковалев}

\titel{\tit}{\aut}{\autkol}{\titkol}

{\renewcommand{\thefootnote}{\fnsymbol{footnote}} \footnotetext[1]
{Работа выполнена при поддержке РФФИ (проекты 13-07-00579, 14-07-00548),
ИПИ РАН (Тема~38.25
<<Спецификация и~решение задач анализа данных в~концептуальных терминах
предметных областей
с~интенсивным использованием данных>> государственного задания ФГБУН ИПИ РАН)
и~Президиума РАН
(Программа фундаментальных исследований Президиума РАН №\,16 <<Фундаментальные
проблемы системного программирования>>).}}


\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{Институт проблем информатики Российской академии наук, alexey.vovchenko@gmail.com}
\footnotetext[2]{Институт проблем информатики Российской академии наук;
Московский государственный университет им.\ М.\,В.~Ломоносова,
факультет вычислительной математики и кибернетики,
leonidk@synth.ipi.ac.ru}
\footnotetext[3]{Институт проблем информатики Российской академии наук, dm.kovalev@gmail.com}

\Abst{При интеграции данных из совокупности исходных коллекций важной задачей
является извлечение сущностей, их трансформация и~загрузка в~интегрированное
хранилище. Такие действия являются частью ETL-про\-цес\-са (extract--transform--loading).
Под сущностью здесь понимается некоторое цифровое представление объекта реального
мира (например, информация о~персонах). При извлечении сущностей возникает проб\-ле\-ма
их разрешения: из различных ресурсов можно извлечь различную информацию об одном
и~том же объекте реального мира. Проб\-ле\-ма разрешения сущностей ориентирована на
решение таких задач, как идентификация сущностей, выявление дубликатов, удаление
дубликатов, установление связей между сущностями, сопоставление сущностей
с~некоторым шаблонным образцом и~др. После разрешения сущностей следует этап их
слияния~--- формирование интегрированных сущностей (содержащих информацию из всех
связанных сущностей). Слияние сущностей является заключительным этапом интеграции
данных. В~работе дан обзор методов разрешения и~слияния сущностей. Рас\-смат\-ри\-ва\-ют\-ся
вопросы адаптации таких методов для применения в~ETL-про\-цес\-се при интеграции
больших данных в~Hadoop. Также рас\-смат\-ри\-ва\-ют\-ся способы программирования методов
разрешения и~слияния сущностей как частей ETL-про\-цес\-са. В~качестве языка
программирования используется HIL (High-Level Integration Language)~--- декларативный
язык, ориентированный на разрешение и~интеграцию сущностей в~Hadoop-инфра\-струк\-туре.}

  \KW{интеграция данных; ETL; разрешение сущностей; слияние сущностей; большие
данные; Hadoop; Jaql; HIL}

\DOI{10.14357/19922264140412}

\vskip 10pt plus 9pt minus 6pt

\thispagestyle{headings}

\begin{multicols}{2}

\label{st\stat}

\section{Введение}


  В течение нескольких последних лет информатика стала играть все возрастающую роль
в~широком наборе научных дисциплин, особенно заметную из-за существенных проблем,
вызванных взрывоподобным ростом данных в~таких науках.\linebreak
 X-информатика образовалась
как совокупность академических дисциплин, направленных на применение средств
информатики для федерализации, организации и~анализа данных в~конкретных областях
науки с~интенсивным использованием данных (НИИД): X\,=\,астро-, био-, гео-, нейро- и~пр.

  Сложность использования данных в~НИИД усугубляется еще и~вследствие естественной
разнородности моделей обрабатываемых данных, в~которых представляют тексты, графы,
структурированную и~слабоструктурированную информацию и~пр. Разнообразие
обрабатываемой информации вызывается, в~частности, не только большим числом
источников поступления обрабатываемой информации, но и~разнообразием объектов
исследования, непрерывным и~быстрым совершенствованием инструментов, вызывающим
адекватные изменения структуры и~содержания накапливаемой информации. Это приводит
к необходимости использования неоднородной, распределенной информации, накопленной
в~течение значительного периода наблюдений технологически различными инструментами.

  Для анализа больших объемов накапливаемых данных используются современные
распределенные инфраструктуры обработки массивных данных (например, Hadoop~[1, 2]).
Основной особенностью подобных инфраструктур является почти линейная горизонтальная
масштабируемость (производительность системы растет линейно относительно числа узлов
кластера), а~также высокая отказоустойчивость (отказ любого узла кластера не должен
влиять на работоспособность системы в~целом).

  Главным достоинством подобных инфраструктур является возможность анализировать
и~обрабатывать разноструктурированные данные, например реляционные, XML, JSON,
NoSQL, текстовые и~др. При этом возникает проблема интеграции информации,
извлекаемой из таких разноструктурированных данных.

  Процесс интеграции данных (рассматриваемый здесь как ETL-про\-цесс) можно
представить состоящим из следующих этапов:
  \begin{itemize}
\item сопоставление схем;
\item интеграция схем;
\item трансформация данных;
\item разрешение сущностей (Entity Resolution~[3--5]);
\item слияние сущностей (Data Fusion~[6]).
\end{itemize}

  В данной работе рассматриваются последние два этапа. При интеграции сырых
разноструктурированных данных задачей ETL-про\-цес\-са является извлечение сущностей
из исходных коллекций, их разрешение, трансформация и~загрузка в~интегрированное
хранилище. Под сущностью здесь понимается некоторое цифровое представление объекта\linebreak
реального мира (например, информация о~персонах). При извлечении сущностей возникает
проб\-ле\-ма их разрешения: из разных ресурсов можно извлечь разную информацию об одном
и~том же\linebreak объекте реального мира. В~общем случае под термином разрешения сущностей
(entity resolution (ER)~[3--5, 7--10]) понимают извлечение информации об одной и~той же
сущности реального мира из разнообразных структурированных, слабоструктурированных
и~неструктурированных коллекций данных и~приведение извлеченных данных
к~унифицированному представлению. При этом применяются методы извлечения,
сопоставления, группирования, связывания устранения дублирования различных
представлений информации. Подходы к~разрешению сущностей рассматриваются
в~разд.~2. Слияние сущностей является заключительным этапом интеграции
данных. Под слиянием сущностей~[6, 11--13] понимается образование интегрированного
представления информации об одной и~той же же сущности реального мира, полученной из разных
источников. Операции и~процедуры, ис\-поль\-зу\-емые при слиянии сущностей, приведены
в~разд.~3.

  В разд.~4 приводится описание средств программирования в~среде Hadoop,
а~также обоснование выбора в~работе средств (языки Jaql и~HIL). Наконец, в~разд.~5
показаны примеры программирования методов разрешения сущностей и~слияния данных
как части ETL-про\-цес\-са в~Hadoop.

\section{Методы разрешения сущностей}

  Этап разрешения сущностей важен для сохранения исходной информации
в~интегрированной коллекции. Кроме того, важно обнаруживать дуб\-ли\-ка\-ты сущностей,
поскольку, например, увеличение числа узлов и~ребер в~сетевых задачах может
существенно удлинять время работы простейших алгоритмов (например, поиска
кратчайшего пути). Алгоритмы разрешения сущностей (включая поиск дубликатов~---
duplicate detection) часто используются и~во всевозможных поисковых системах, таких как
Google, Amazon и~др. Аналогичная проблема встает остро в~различных агрегаторах
информации (например, новостных агрегаторах).

В общем случае процесс разрешения сущностей включает следующие этапы~\cite{8-vov}:
\begin{itemize}
\item подготовка данных;
\item выбор методов сопоставления значений;
\item определение методов разрешения пар сущностей;
\item определение зависимостей (constraints).
\end{itemize}

  \subsection{Методы сопоставления значений}

  Важным действием для успешного разрешения сущностей является подготовка данных,
которая включает нормализацию схем и~нормализацию данных. Нормализация схем~---
непростая задача, подробное ее рассмотрение выходит за рамки данной работы
и~содержится в~работах по интеграции данных в~традиционных архитектурах или
в~инфраструктурах больших данных. Ниже представлен пример списка действий, которые
могут быть отнесены к нормализации схем:
  \begin{itemize}
\item сопоставление атрибутов схем (например, <<контактный телефон>>
и~<<мобильный телефон>>);
\item слияние атрибутов (например, <<полный адрес>> образуется из атрибутов
<<город>>, <<индекс>>, <<улица>>, \ldots);
\item слияние множественных значений и~списков (например, <<контактные телефоны>>
и~<<основной номер телефона>>, <<дополнительный номер телефона>>)
 и~др.
\end{itemize}

  Нормализация данных может включать приведение к строчному или заглавному регистру;
удаление разделителей; поиск и~исправление опечаток; поиск сокращений и~аббревиатур
и~замена их на полные стандартные формы; использование словарей для нормализации
строк и~многое другое. Нормализация данных, так же как и~нормализация схем, не
рассматривается в~данной статье.

  Для сопоставления сущностей важно определиться с~выбором метода оценки сходства
(similarity) значений. Рассматриваются как булевы, так и~вещественные меры сходства.
Следующий список включает примеры часто используемых методов оценки сходства
значений:
  \begin{itemize}
\item эквивалентность булевых предикатов;\\[-13pt]
\item вычисление функции сходства простых значений (расстояние Левенштейна~[14],
алгоритм Сми\-та--Ва\-тер\-ма\-на~[14]);\\[-13pt]
\item вычисление функции сходства множеств (коэффициент Жаккара~[14], коэффициент
сходства Дайса~[14], коэффициент Адара~[15]);\\[-13pt]
\item вычисление функции сходства векторов (коэффициент косинусов~[14],
статистическая мера TFIDF (term frequency\,--\,inverse document frequency)~[14]);\\[-13pt]
\item оценка сходства на основе выравнивания (сходство Джа\-ро--Винк\-ле\-ра~[14],
статистическая мера Soft-TFIDF~[16], расстояние Монг--Эл\-ка\-на~[17]);\\[-13pt]
\item оценка сходства фонетических данных (алгоритм сравнения двух строк по их
звучанию Soundex~[14]);\\[-13pt]
\item оценка сходства, основанная на переводе (может использоваться для нормализации
аббревиатур);\\[-13pt]
\item оценка сходства, основанная на знаниях о~предметной области.
\end{itemize}

  Также существуют специальные методы для определения сходства отношений. Меры,
используемые для отношений, обычно основаны на сходстве множеств и~предполагают
использование функций вычисления сходства множеств.

\vspace*{-3pt}

  \subsection{Методы сопоставления пар сущностей}

  \vspace*{-3pt}

  \subsubsection{Традиционные методы сопоставления пар сущностей}

  Пусть даны две коллекции объектов с~атрибутами: author, venue, paper. Значение
некоторой меры сходства (одной из приведенных в~подразд.~2.1) для конкретного атрибута
будем обозначать

\vspace*{-3pt}

\noindent
\begin{multline*}
\mathrm{XX}\mbox{-}\mathrm{match}\mbox{-}\mathrm{score}
(\mathrm{author}\mbox{-}\mathrm{match}\mbox{-}\mathrm{score},\\
  \mathrm{venue}\mbox{-}\mathrm{match}\mbox{-}\mathrm{score},
  \mathrm{paper}\mbox{-}\mathrm{match}\mbox{-}\mathrm{score})\,.
\end{multline*}

\vspace*{-3pt}

  Традиционным методом сравнения объектов является подсчет сходства некоторым
алгоритмом (см.\ подразд.~2.1) для каждого из атрибутов неза-\linebreak\vspace*{-12pt}

\columnbreak

\noindent
висимо. Затем реализуется подсчет
взвешенной суммы.

  Например:

  \vspace*{-4pt}

  \noindent
  \begin{align*}
 & 0{,}5  \mathrm{autor}\mbox{-}\mathrm{match}\mbox{-}\mathrm{score}+
  0{,}2\mathrm{venue}\mbox{-}\mathrm{match}\mbox{-}\mathrm{score}\\
&  +\;  0{,}3\mathrm{paper}\mbox{-}\mathrm{match}\mbox{-}\mathrm{score}\,.
  \end{align*}

  \vspace*{-4pt}

  Недостатком такого подхода является сложность выбора весов для каждого из атрибутов
и~сложность выбора порога сходства сущностей.

  Другой метод предполагает задание булевого обобщенного правила, где условия
накладываются на каждый атрибут независимо.

  Например:

  \vspace*{-4pt}

  \noindent
  \begin{align*}
&(\mathrm{author\mbox{-}match\mbox{-}score > 0{,}7}\\
&\hspace*{10mm}\mathrm{AND\ venue\mbox{-}match\mbox{-}score >0{,}8)}\\
  &\mathrm{OR\ (paper\mbox{-}match\mbox{-}score > 0{,}9}\\
&\hspace*{10mm}\mathrm{AND\
  venue\mbox{-}match\mbox{-}score>0{,}9)}\,.
  \end{align*}

  \vspace*{-4pt}

  Недостатком этого подхода является сложность формулирования подобных правил
вручную.



  \subsubsection{Методы машинного обучения для~сопоставления пар
сущностей}

  Для сопоставления пар сущностей применяют также специальные методы машинного
обучения, которые позволяют автоматизировать процесс формулирования критериев для
сопоставления сущностей. Использование таких методов основано на применении теории
Фел\-ле\-ги и~Сантера~[14] для связывания сущностей. Рассмотрим этот подход подробнее.

  Пусть даны коллекции $A$ и~$B$.

  Пусть $r$~--- это пара $r(x,y)$, где $x\hm\in {A}$, $y\hm\in {B}$.

  Пусть $\gamma \hm=\gamma(r)$~--- это вектор сравнения, например:
    \begin{multline*}
  \gamma(r) = \{x.\mathrm{author} = y.\mathrm{author},x.\mathrm{venue}=y.\mathrm{venue},\\
  x.\mathrm{paper}=y.\mathrm{paper}\}\,,
\end{multline*}
  $\gamma(r) = \{\mathrm{true}, \mathrm{false}, \mathrm{true}\}$~--- пример, в~случае если
  $x.\mathrm{author}\hm=y.\mathrm{author}$, $x.\mathrm{venue}\hm\not= y.\mathrm{venue}$,
  $x.\mathrm{paper}\hm=y.\mathrm{paper}$.

  Пусть $M$~--- множество всех пар, являющихся дубликатами.

  Пусть $U$~--- множество всех пар, не являющихся дубликатами.

  Тогда правило для определения сходства сущностей можно описать следующей
формулой:
  $$
  R(r)= \fr{m(\gamma)}{u(\gamma)} = \fr{P(\gamma\vert r\in M)}{P(\gamma \vert r\in U)}\,.
  $$


  Определим два порога $T_I$ и~$t_U$, такие что
  \begin{itemize}
  \item $R(r)\leq t_I$~--- объекты (пара) не являются дубликатами;\\[-13pt]
\item $R(r)>t_I\ \mathrm{AND}\ R(r)<t_u$~--- невозможно определить, являются ли объекты (пара)
дубликатами или нет;
\item $R(r)\geq t_u$~--- объекты (пара) являются дубликатами.
\end{itemize}

  Правилом связывания, обозначаемым $L(t_I,t_U)$, называется пара порогов~$t_I$
и~$t_U$.

  При подобном подходе учитываются стандартные для задачи проверки статистических
гипотез ошибки первого и~второго рода. Ошибки первого рода~--- два объекта не являются
дубликатами ($r(x,y)\hm\in U$), однако правило~$L$ относит их к дуб\-ли\-ка\-там. Ошибки
первого рода обозначаются бук\-вой~$\mu$ и~их можно описать формулой:
  $$
  \mu= P(L_{\mathrm{match}}\vert U) =\sum\limits_\gamma u(\gamma) P\left(L_{\mathrm{match}}\vert
\gamma\right)\,.
  $$

  Ошибки второго рода~--- два объекта являются дубликатами ($r(x,y)\hm\in M$), однако
правило~$L$ определяет, что это не дубликаты. Ошибки второго рода означаются
буквой~$\lambda$ и~их можно описать формулой:
  $$
  \lambda= P(L_{\mathrm{nonmatch}}\vert M) =
  \sum\limits_\gamma m(\gamma) P\left(
L_{\mathrm{nonmatch}} \vert \gamma\right).
  $$

  Оптимальным правилом связывания $L^*(t_I^*,t_U^*)$ называется такое правило,
которое соответствует ограничениям на ошибки первого и~второго рода для правила,
  а~так\-же ограничения на неопределенности. Эти ограничения выражаются следующими
формулами:
\begin{itemize}
\item
  ограничения на ошибки:
  $$
  P\left( L^*_{\mathrm{match}}\vert U\right) \leq \mu\,;\qquad
  P\left( L^*_{\mathrm{nonmatch}}\vert M\right) \leq
\lambda\,;
  $$
\item
  ограничения на неопределенности:
  \begin{align*}
  P\left( L^*_{\mathrm{uncertain}}\vert U\right) &\leq P\left( L_{\mathrm{uncertain}} \vert U\right)\,;\\
  P\left( L^*_{\mathrm{uncertain}} \vert M\right)&\leq P\left( L_{\mathrm{uncertain}}\vert M\right)\,.
\end{align*}
\end{itemize}

  Нахождение оптимального правила является основной задачей при использовании теории
Феллеги и~Сантера. Классические (переборные) методы при таком подходе работают
неэффективно, поэтому нахождение оптимального правила достигается с~помощью средств
машинного обучения, например можно использовать наивный байесовский классификатор.
Одна из основных проблем при этом заключается в~том, что для вычисления $P(\gamma \vert
r \hm\in M)$ и~$P(\gamma\vert r \hm\in U)$ необходимы знания о~том, какие объекты
являются дубликатами, а~какие нет (знания о~множествах~$M$ и~$U$).

  Для разрешения сущностей применяются различные реализации подходов, основанных на
алгоритмах машинного обучения и~использовании теории Феллеги и~Сантера, например
использование:
  \begin{itemize}
\item деревьев решений~[18];
\item метода опорных векторов~[19, 20];
\item ансамблей классификаторов~[21];
\item метода условных случайных полей~[22].
\end{itemize}

  К недостаткам этих подходов можно отнести несбалансированность результирующих
классифицированных множеств (так, в~результате образуется значительно больше
непохожих объектов, чем похожих), а~также высокую вероятность того, что объект не будет
причислен ни к какому классу (из-за неопределенности). Но оба этих недостатка могут быть
устранены путем тонкой настройки алгоритмов. Ключевой проблемой при использовании
методов машинного обучения при сравнении пар сущностей является выбор обучающего
множества.

  Выделяют следующие методы классификации сущностей, не требующие построения
обучающей выборки:
  \begin{itemize}
\item обучение без учителя или с~частичным привлечением учителя~\cite{14-vov, 23-vov};
\item методы с~активным обучением;
\item ансамбли классификаторов~\cite{25-vov, 24-vov};
\item доказуемая оптимизация точ\-ности/пол\-но\-ты~\cite{26-vov, 27-vov};
\item краудсорсинг~\cite{28-vov, 29-vov}.
\end{itemize}

  Подводя итог методам разрешения пар сущностей, выделим методы, основанные на мерах
сходства, и~методы, основанные на использовании машинного обучения. Общим
недостатком первой группы методов является сложность формулирования критериев
сходства (подбор весов или явных формул). Методы машинного обучения лишены этого
недостатка в~силу своей структуры, но при этом ключевой проблемой является выбор
обучающего множества, да и~сами методы значительно сложнее. Перспективными (но все
еще мало из\-учен\-ны\-ми) представляются методы машинного обуче\-ния, не требующие
изначального определения обучающего множества, такие как методы, основанные на
активном обучении и~краудсор\-синге.
{\looseness=-1

}

\begin{figure*}[b] %fig1
\vspace*{1pt}
 \begin{center}
 \mbox{%
 \epsfxsize=157.76mm
 \epsfbox{vov-1.eps}
 }
 \end{center}
 \vspace*{-9pt}
\Caption{Различные аспекты проблемы слияния данных}
\end{figure*}


  \subsection{Использование ограничений} %2.3

  После того как определен метод разрешения конкретных пар сущностей, можно
определить зависимости. Далее представлены примеры зависимостей, используемых для
установления сходства сущностей:
  \begin{itemize}
\item транзитивность: если М1 и~М2 похожи и~М2 и~М3 похожи, то и~М1 и~М3 похожи;
\item эксклюзивность: если М1 и~М2 похожи, то М3 не может быть похож на М2;
\item функциональные зависимости: если М1 и~М2 похожи, то М3 и~М4 должны быть
похожи.
\end{itemize}

  Транзитивность часто используется в~методах удаления дубликатов, а~эксклюзивность
используется в~методах установления связей между сущностями.

  В заключение можно отметить, что разрешение сущностей является быстро развиваемой
областью. Исследуются новые меры сходства~\cite{14-vov}, ведутся работы по применению
перспективных методов машинного обучения~[24--29]. Развивается применение
функциональных зависимостей при очистке данных (data cleaning)~[30--32]. Ведутся работы
по построению сущностей с~наиболее представительными данными (включающими данные
из разнообразных дубликатов~--- методы канонизации сущностей~[33]). Также исследуются
методы, в~которых решения по сходству двух сущностей принимаются на основе анализа
совокупности сущностей, применения вероятностных логик сходства, латентной модели
Дирихле~[34--36].

\section{Методы слияния данных}

  Под слиянием данных~\cite{6-vov, 12-vov, 11-vov} понимается образование
интегрированного представления информации об одной и той же сущности реального мира,
полученной из разных источников данных. Процесс слияния данных включает следующие
задачи: слияние записей о~сущностях, разрешение возможных конфликтов, обнаружение
и~удаление ошибочных данных. Методы слияния данных, кратко рассмотренные в~данном
разделе, исследованы в~Потсдамском университете~\cite{11-vov}. Различные аспекты
проблемы слияния данных представлены на рис.~1.


  \subsection{Типы конфликтов при слиянии данных}

  Различают два типа конфликтов: конфликты, вызванные неопределенными значениями,
и~конфликты, вызванные противоречивыми значе\-ниями.

  Неопределенность означает, что в~одном источнике данных содержатся неизвестные
значения (null), а~в~другом~--- известные. Проблема заключается в~том, что семантика
неопределенных значений (null) может сильно отличаться. Различают три варианта:
неизвестные значения, несуществующие значения (например, атрибут <<имя супруга>>
всегда будет null для неженатых), скрытые значения (такие данные, которые по ка\-ким-то
причинам не позволено видеть).

  Противоречивость значений означает появление двух различных ненулевых (not null)
значений. Возможны различные стратегии обработки подобных конфликтов, о~чем
рассказывается в~сле\-ду\-ющем подразделе.



  \subsection{Стратегии разрешения конфликтов}

  Различают следующие подходы к разрешению конфликтов:
  \begin{itemize}
\item игнорирование конфликтов;
\item избегание конфликтов;
\item разрешение конфликтов.
\end{itemize}

  Стратегия игнорирования конфликтов предполагает извлечение всей доступной
информации.\linebreak\vspace*{-12pt}

\pagebreak

\end{multicols}

  \begin{table}\small
  \begin{center}

  \tabcolsep=5pt
  \begin{tabular}{|l|p{34mm}|c|p{40mm}|}
%  \hline
  \multicolumn{4}{c}{Примеры функций для разрешения конфликтов}\\[6pt]
  \hline
  \multicolumn{1}{|c|}{Функция}&\multicolumn{1}{c|}{Описание}&Стратегия&\multicolumn{1}{c|}{Пример
конфликта}\\
  \hline
Min, Max, Sum, Count, Avg&Обычная агрегация&Разрешение конфликта&Подсчет зарплаты
(средней или максимальной), подсчет возраста или количества детей\\
\hline
Random&Случайное значение&Разрешение конфликта&Размер участка\\
\hline
Longest, Shortest&Самое короткое или длинное значение&Разрешение
конфликта&Например, для имен\\
\hline
Choose (source)&Значение из конкретного ресурса&Избежание конфликта&Например, для
финансовых данных, если принято решение доверять информации из Yahoo больше, нежели
другим ресурсам\\
\hline
Choose Depending (val, col)&Выбирается значение в~зависимости от значения в~другом
атрибуте&Избежание конфликта&Например, если выбран атрибут <<город>> из одного
ресурса, то <<почтовый индекс>> разумно взять из того же самого ресурса\\
\hline
Vote&Голосование, решение по большинству&Разрешение конфликта&Например, для
подсчета рейтинга\\
\hline
Coalesce&Выбор первого ненулевого значения&Избежание конфликта&Например, для
имен\\
\hline
Group, Concat&Группировка или конкатенация всех значений&Избежание
конфликта&Например, для отзывов о~продуктах\\
\hline
MostRecent&Выбор наиболее свежего значения (недавно обновленного)&Разрешение
конфликта&Например, если интересует последний адрес местожительства\\
\hline
Escalate&Сохранение всех конфликтующих значений, с~тем чтобы пользователь сам решил,
какое выбрать&Игнорирование конфликта&Например, для атрибута <<пол>> сложно
придумать объективные причины выбора того или иного значения\\
\hline
\multicolumn{1}{|c|}{$\ldots$}&\multicolumn{1}{c|}{$\ldots$}&
\multicolumn{1}{|c|}{$\ldots$}&\multicolumn{1}{c|}{$\ldots$}\\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{multicols}{2}

\noindent
 Например, для строк это может быть обычная конкатенация строк,
а~пользователь уже сам решает, какие данные верны.

  Стратегия избегания конфликтов предполагает выбор данных на основе самих данных (по
некоторому алгоритму) или на основе метаданных. Примером функции на основе данных
может служить функция coalesce (выбор первого ненулевого значения) или функция выбора
самого длинного значения.

Примером функций на основе метаданных может выступать
выбор в~зависимости от самого источника (например, известно, что один из источников
наиболее достоверный). Другим примером является функция, выбирающая значение из того
источника, в~котором большее число значений было выбрано для других атрибутов.



  Стратегии разрешения конфликтов учитывают все значения и~выбирают из них
<<достоверное>>. Примером подобной функции могут выступать всевозможные функции
голосования, функции выбора случайного значения, функции среднего значения, функции
наиболее часто встречающегося значения и~др.

  В~таблице представлены примеры функций для разрешения конфликтов.

  \begin{figure*}[b] %fig2
  \vspace*{1pt}
 \begin{center}
 \mbox{%
 \epsfxsize=120.997mm
 \epsfbox{vov-2.eps}
 }
 \end{center}
 \vspace*{-9pt}
   \Caption{Пример операции \textbf{Minimum Union}
  }
%  \end{figure*}
%    \begin{figure*} %fig3
  \vspace*{1pt}
 \begin{center}
 \mbox{%
 \epsfxsize=120.997mm
 \epsfbox{vov-3.eps}
 }
 \end{center}
 \vspace*{-9pt}
  \Caption{Пример операции \textbf{Complementation Union}}
  \end{figure*}

\vspace*{-6pt}

  \subsection{Основные функции разрешения конфликтов}

  Вводится операция {\sf outer union}~\cite{11-vov}, результатом которой
является объединение двух отношений. Если схемы не совпадают, то результирующая схема
является объединением двух исходных схем. Например, пусть даны два отношения:
A~с~набором атрибутов $\{\mathrm{a, b, c, d}\}$ и~отношение~B с~набором атрибутов
$\{\mathrm{c, d, e, f}\}$. Результирующая схема будет содержать набор
атрибутов\;=\;$\{\mathrm{a, b, c, d, e, f}\}$. В~результирующие кортежи для недостающих
атрибутов помещаются нулевые значения. Эта операция не является стандартной
и~отсутствует в~большинстве реляционных систем управления базами данных (СУБД).
В~реляционной алгебре подобная
операция может быть представлена как

\smallskip

  \noindent
  ({\sf  SELECT a, b, c, d, NULL as e, NULL as f FROM A})

\noindent
  {\sf UNION}

\noindent
  ({\sf SELECT NULL as a, NULL as b, c, d, e, f FROM B}).

  Вводится функция {\sf tuple subsumption}~\cite{11-vov}. Говорят, что
кортеж~t1 поглощает другой кортеж~t2 (поглощаемый кортеж), если у них
  \begin{itemize}
\item совпадают схемы;
\item в t2 больше неизвестных (null) значений, чем в~t1;
\item в t2 все известные значения совпадают со значениями в~t1.
\end{itemize}

  Например, пусть даны кортежи $\mathrm{t1} \hm= (5, \mbox{`text'}, \mbox{null}, 7)$
и~$\mathrm{t2} = (5, \mathrm{null}, \mathrm{null}, 7)$. Видно, что каждый атрибут в~t2 либо
совпадает с~аналогичным атрибутом в~t1, либо он null. Для этого примера кортеж~t1
поглощает кортеж~t2.

  Вводится функция {\sf tuple complementation}~\cite{11-vov}. Говорят, что
кортежи~t1 и~t2 дополняют друг друга, если
  \begin{itemize}
\item у них совпадают схемы;
\item они не совпадают;
\item значения соответствующих атрибутов в~t1 и~t2 совпадают, либо одно из них не
определено, либо оба не определены;
\item t1 и~t2 имеют как минимум один атрибут, значения которого совпадают.
\end{itemize}

  Например, пусть даны кортежи $\mathrm{t1} \hm= (5, \mbox{`text'}, \mathrm{null},
\mathrm{null})$ и~$\mathrm{t2} \hm= (5, \mathrm{null}, \mathrm{null}, 7)$. Видно, что кортежи
дополняют друг друга. Результатом операции дополнения для этих двух кортежей будет
новый кортеж $\mathrm{t} \hm= (5, \mbox{`text'}, \mathrm{null}, 7)$.


  \begin{figure*} %fig4
  \vspace*{1pt}
 \begin{center}
 \mbox{%
 \epsfxsize=120.997mm
 \epsfbox{vov-4.eps}
 }
 \end{center}
 \vspace*{-7pt}
   \Caption{Пример операции \textbf{Full Disjunction}}
   \vspace*{3pt}
  \end{figure*}

\vspace*{-6pt}

  \subsection{Операторы слияния данных}

  Различают два основных подхода к слиянию данных. Эти подходы основаны на операции
объединения (union-based) или на операции соединения (join-based). Различают следующие
основные операции.

  \textbf{Minimum Union}~\cite{11-vov} (union-based). Операция представляет собой
выполнение операции {\sf outer union}, а затем удаление из результата всех
поглощаемых (subsumed~\cite{11-vov}) кортежей. Пример операции представлен на рис.~2.


  \textbf{Complemetation Union}~\cite{11-vov} (union-based). Операция
представляет собой выполнение операции {\sf outer union}, а~затем дополнение
(complementation) всевозможных кортежей. Пример операции представлен на рис.~3.



  \textbf{Grouping and Aggregation}~\cite{11-vov} (union-based). Операция
предполагает выполнение {\sf outer union}, а~затем группировку по общему атрибуту
и~применение функции агрегации к остальным атрибутам. Пример операции на языке SQL
представлен ниже.
\smallskip

\noindent
{\sf   WITH OU AS ( }

\noindent
\hspace*{3pt}{\sf   (SELECT A, B, C, NULL AS D FROM U1)}

\noindent
\hspace*{12pt}{\sf UNION (ALL)}

\noindent
\hspace*{3pt}{\sf (SELECT A, B, NULL AS C, D FROM U2)),}


\noindent
{\sf SELECT A, MAX(B),  MIN(C), SUM(D)}

\noindent
{\sf FROM 	OU}

\noindent
{\sf GROUP BY A}

\smallskip

\textbf{Full Disjunction}~\cite{37-vov} (join-based). Операция представляет собой
{\sf full outer join} (стандартную реляционную операцию), после чего
применяется {\sf subsumption} к результату. Пример представлен на рис.~4.



  \textbf{Match Join}~\cite{11-vov} (union-\;+\;join-based). В операции выбираются
всевозможные комбинации значений атрибутов, после чего выполняется
{\sf full
outer join}. Фактически реализуется {\sf outer union} двух коллекций. Затем
определяется $N\hm-1$ вспомогательных отношений, где $N$~--- число атрибутов,
  а~каж\-дое из отношений содержит по два атрибута: один общий и~какой-то другой.
После чего происходит {\sf full outer join} ($N\hm-1$)-го отношения. Пример
реализации операции на языке SQL представлен ниже.

\smallskip

\noindent
{\sf   WITH}

\noindent
{\sf   \hspace*{3pt}OU(A,B,C,D) AS (}

\noindent
{\sf   \hspace*{3pt}(SELECT A, B, C, NULL AS D FROM U1)}

\noindent
{\sf  \hspace*{6pt}UNION}

\noindent
{\sf   \hspace*{3pt}(SELECT  A, B, NULL AS C, D FROM U2))},

\noindent
\ \ \ \ \ //\ $\leftarrow$\ \textbf{Outer Union}

\noindent
{\sf   \hspace*{3pt}B\_V(A,B) AS (SELECT DISTINCT A, B FROM OU)},


\noindent
\ \ \ \ \  //\ $\leftarrow$\ \textbf{1-е отношение} ($N=4$)

\noindent
  {\sf \hspace*{3pt}C\_V(A,C) AS (SELECT DISTINCT A, C FROM OU)},

  \noindent
\ \ \ \ \  // \ $\leftarrow$\ \textbf{ 2-е отношение} ($N=4$)

\noindent
  {\sf \hspace*{3pt}D\_V(A,D) AS (SELECT DISTINCT A, D FROM OU),}

\noindent
\ \ \ \ \ //\ $\leftarrow$\ \textbf{3-е отношение} ($N=4$)

\noindent
  {\sf SELECT A, B, C, D}

\noindent
  {\sf FROM B\_V FULL OUTER JOIN C\_V FULL OUTER

  \noindent
  \ \ \ \ \  JOIN D\_V}
  //\ $\leftarrow$\ \textbf{Full Outer Join}

 \textbf{Merge} (union-\;+\;join-based). Операция объединяет операции соединения
и~объединения. Для каждого общего атрибута формируются две версии значений, нулевые
значения удаляются функцией COALESCE (выбор первого ненулевого значения). Пусть
даны два отношения: A~с~набором атрибутов $\{\mathrm{a, b, c}\}$ и~B с~набором
атрибутов $\{\mathrm{a, b, d}\}$. Пусть a~--- конфликтующий атрибут, b~--- атрибут
с~нулевыми значениями. Пример реализации операции на языке SQL представлен ниже,
а~результат показан на рис.~5.

\noindent
{\sf   (SELECT A.a, COALESCE(A.b, B.b), A.c, B.d}

\noindent
  {\sf FROM A LEFT OUTER JOIN B ON A.a\;=\;B.a)}

\noindent
{\sf   UNION}

\noindent
{\sf   (SELECT B.a, COALESCE(B.b, A.b), A.c, B.d}

\noindent
{\sf   FROM A RIGHT OUTER JOIN B ON A.a\;=\;B.a)}



  \textbf{Grouping and Aggregation} (union-based). Операция представляет собой
группировку по некоторому атрибуту, а~затем использование разнообразных агрегирующих
функций. В~качестве достоинства данного подхода можно выделить его реализацию
в~большинстве СУБД и~эффективное выполнение. Пример реализации на SQL представлен
ниже.

  \begin{figure*} %fig5
  \vspace*{1pt}
 \begin{center}
 \mbox{%
 \epsfxsize=128.851mm
 \epsfbox{vov-5.eps}
 }
 \end{center}
 \vspace*{-9pt}
  \Caption{Пример операции \textbf{Merge}}
  \end{figure*}


\noindent
{\sf  WITH OU AS (}

\noindent
{\sf   \hspace*{3pt}(SELECT A, B, C, NULL AS D FROM U1)}

\noindent
{\sf         \hspace*{6pt}UNION (ALL)}

\noindent
{\sf    \hspace*{3pt}(SELECT A, B, NULL AS C, D FROM U2)),}

\noindent
{\sf   SELECT A, MAX(B), MIN(C), SUM(D)}

\noindent
{\sf   FROM OU}

\noindent
{\sf   GROUP BY A}

\textbf{Data Fusion оператор}~\cite{13-vov}~--- \textbf{Fuse By} (union-based).
В~некоторых системах пошли дальше использования стандартных операций
группировки и~агрегации. Ключевое слово FUSE BY используется вместо GROUP BY,
и~семантика у него аналогична. Вмес\-то использования стандартных функций агрегации
используется встроенная функция RESOLVE, которой параметром передается само значение
и~имя функции разрешения конфликтов. Пример реализации на SQL представлен ниже.

\noindent
{\sf SELECT ID,}

\noindent
{\sf  \hspace*{3pt}RESOLVE(Title, Choose(IMDB)),}

\noindent
{\sf   \hspace*{3pt}RESOLVE(Year, Max),}

\noindent
{\sf  \hspace*{3pt}RESOLVE(Director, COALESCE),}

\noindent
{\sf   \hspace*{3pt}RESOLVE(Rating, COALESCE),}

\noindent
{\sf   \hspace*{3pt}RESOLVE(Genre, Concat)}

\noindent
{\sf   FUSE FROM IMDB, Filmdienst}

\noindent
{\sf   FUSE BY (ID)}

\noindent
{\sf   ON ORDER Year DESC}

  \section{Разрешение сущностей в~больших данных}

  Для манипулирования большими разноструктурированными данными служат
  Hadoop-инф\-ра\-струк\-ту\-ры~[1, 2], предоставляющие масштабируемое хранилище
и~обеспечивающие высокую \mbox{скорость} анализа больших данных за счет распределенной их
обработки. Для применения методов разрешения сущностей в~такой среде нужна
\textit{адаптация} алгоритмов для их распределенного выполнения на различных узлах
Hadoop-клас\-тера.

  В среде Hadoop реализована парадигма распределенного программирования для анализа
данных Map-Reduce~\cite{38-vov, 39-vov}, называемая по именам основных функций.
Вначале на всех узлах кластера обрабатываются блоки данных независимо друг от друга
(Map). После чего данные группируются по заранее выбранным для алгоритма ключам
и~поступают на выполнение на один или более узлов в~зависимости от алгоритма (Reduce).

  Таким образом, для реализации любого алгоритма в~Hadoop-инфра\-струк\-ту\-ре
требуется его адап\-тация к виду Map-Reduce. Другим вариантом яв\-ля\-ется реализация
алгоритма на одном из языков \mbox{высокого} уровня, таких как Pig~[40], Hive~[41], Jaql~[42]. Все
эти языки автоматически переписывают программы, реализованные на них,
  в~Map-Reduce-при\-ло\-же\-ния для выполнения на Hadoop-клас\-тере.

  В случае больших данных и~распределенных инфраструктур традиционные подходы
требуют доработок. Различают два основных метода разрешения сущностей над большими
данными: разбиение данных на блоки (blocking~[43, 44]) и~распределенный метод
разрешения сущностей.

  Суть разбиения на блоки заключается в~сле\-ду\-ющем. Пусть имеется 1000~компаний
в~1000~городах. Требуется сравнить компании. Алгоритм полного попарного сравнения
потребует 10$^{12}$ сравнений. При этом если предположить, что компании из разных
городов не могут совпадать, то потребуется 10$^9$ сравнений. Ключевой проблемой данного
подхода является выбор критерия, по которому разбиваются данные.

Различают два
основных метода: основанный на хэш-функ\-ции~\cite{8-vov} и~основанный на сходстве
соседей~\cite{8-vov}. Метод, основанный на хэш-функ\-ции, предполагает разбиение на
блоки по хэш-клю\-чу. Основной проблемой алгоритма является выбор хэш-функ\-ции.
Метод, основанный на сходстве соседей, предполагает, что совпадать могут только объекты,
похожие по некоторой мере. Все объекты сортируются по ка\-ко\-му-то признаку (ключу~---
простому или составному, уникальность ключа не требуется). После этого выбирается
размер окна, внутри которого объекты сравниваются. Проблемой данного метода является
выбор ключа сортировки.

  Распределенный метод разрешения сущностей предполагает реализацию традиционных
алгоритмов этого семейства в~виде Map-Reduce-при\-ло\-же\-ния, что требует зачастую
полного пересмотра исходного алгоритма. Другой вариант~--- реализация алгоритма
разрешения сущностей на специализированных языках, чему будет посвящен сле\-ду\-ющий
раздел. Третий вариант~--- использование специализированных инструментов,
направленных на распределенное выполнение методов разрешения сущностей над
Hadoop~[45].

\vspace*{-6pt}

\section{Реализация операций разрешения сущностей и~слияния
данных в~среде Hadoop}

\vspace*{-2pt}

  Язык HIL~[46]~--- декларативный язык, ориентированный
на разрешение и~интеграцию сущностей в~Hadoop инфраструктуре. HIL компилируется
в~язык Jaql~[43, 44], который, в~свою очередь, автоматически переписывается
  в~Map-Reduce, если этого требует алгоритм.

  \vspace*{-6pt}

  \subsection{Реализация методов разрешения сущностей}

  \vspace*{-2pt}

  Пусть даны структуры данных, включающие три атрибута: id, value, name. Тогда
простейшее правило разрешения сущностей на языке HIL будет выглядеть следующим
образом:

{\sf \noindent
  declare \textbf{Duplicated}: ?;

\noindent
  declare \textbf{Generated}: ?;

\noindent
  declare \textbf{Deduplicated}: ?;

  \vspace*{6pt}

\noindent
  create link \textbf{Deduplicated} as

\noindent
  select

\noindent
  [gen: [id: g.id, name: g.name, value: g.value],

\noindent
  dup: [id: d.id, name: d.name, value: d.value]]

\noindent
  from Generated g, Duplicated d

\noindent
  match using

\noindent
    \hspace*{3pt}rule\_id: g.id\;=\;d.id,

\noindent
    \hspace*{3pt}rule\_name: g.name\;=\;d.name,

\noindent
    \hspace*{3pt}rule\_value: g.value\;=\;d.value;
    }

  В этом примере используется простое сопо\-став\-ле\-ние сущностей по совпадению значений.
Если требуется ввести какую-то функцию меры для значений, это можно реализовать
внешней функцией Jaql:
{\sf

\noindent
  @jaql\{

\noindent
  {\textbf{compareValue}} =

  javaudf("org.ipiran.similarity.ValueSimilarity");

\noindent
  \}
  }

  После этого такую функцию можно вызывать из языка HIL:

{\sf
\noindent
  declare compareValue: function ? to ?;

\noindent
  declare Duplicated: ?;

\noindent
  declare Generated: ?;

\noindent
  declare Deduplicated: ?;

  \vspace*{6pt}

\noindent
  create link Deduplicated as

\noindent
  select

\noindent
  [gen: [id: g.id, name: g.name, value: g.value],

\noindent
  dup: [id: d.id, name: d.name, value: d.value]]

\noindent
  from Generated g, Duplicated d

\noindent
  match using

\noindent
  rule\_id:

\noindent
    \hspace*{3pt}{\textbf{compareValue}}(g.id, d.id)\;$>$\;0.7,

\noindent
  rule\_name:

\noindent
    \hspace*{3pt}{\textbf{compareValue}}(g.name, d.name)\;$>$\;0.7,

\noindent
  rule\_value:

\noindent
    \hspace*{3pt}{\textbf{compareValue}}(g.value, d.value)\;$>$\;0.7;
    }

  Можно также ввести меру для сравнения объектов целиком.

  Пусть описана функция
{\sf compareObject}, которая принимает на вход объекты. Тогда правило на языке HIL
изменится, так как в~этом случае используется другой вид правил:

{\sf

\noindent
  insert into Deduplicated

\noindent
  select

\noindent
  [gen: [id: g.id, name: g.name, value: g.value],

\noindent
  dup: [id: d.id, name: d.name, value: d.value],

\noindent
  value: {\textbf{compareObject}}(g,d)]

\noindent
  from Generated g, Duplicated d

\noindent
  where {\textbf{compareObject}}(g, d)\;$>$\;0.7;
  }

  Во всех этих случаях происходит сравнение всех объектов со всеми, сложность подобного
сравнения $O(n^2)$. Несмотря на то что сравнения будут выполняться независимо
и~распределены на всех узлах кластера (так как HIL переписывается в~Jaql, а~тот, в~свою
очередь, в~Map-Reduce), время их выполнения может быть довольно большим. Для
уменьшения числа сравнений, как было описано в~разд.~4, можно разбивать
данные на блоки.

  Пусть имеется функция {\sf calcHash}, которая вычисляет хэш для объектов. В~результате
функция может выдавать столько уникальных значений, на сколько блоков требуется
разбить данные. Тогда, объединив правила, рассмотренные выше, выбрав вначале те
объекты, что совпадают по хэш-функ\-ции, а~далее, вычислив общую меру, можно получить
результат за более короткое время:

{\sf

\noindent
  declare {\textbf{calcHash}}: function ? to ?;

\noindent
  insert into GeneratedHash

\noindent
  select [\$.*, hash: {\bfseries\textit{calcHash}}(\$.*)]

\noindent
  from Generated;

\noindent
  insert into DuplicatedHash

\noindent
  select [\$.*,hash: {\textbf{calcHash}}(\$.*)]

\noindent
  from Duplicated;

 \vspace*{6pt}

\noindent
  create link Deduplicated as

\noindent
  select [

\noindent
  \hspace*{3pt}gen: [id: g.id, name: g.name, value:   g.value],

\noindent
  \hspace*{3pt}dup: [id: d.id, name: d.name, value: d.value]]

\noindent
  from GeneratedHash g, DuplicatedHash d

\noindent
  match using

\noindent
  \hspace*{3pt}rule\_id: g.hash\;=\;d.hash;

\noindent
  insert into Measured

\noindent
  select [gen: dd.gen, dup: dd.dup, value:

  \noindent
  \hspace*{6pt}{\textbf{compareObject}}(dd.gen, dd.dup)]

\noindent
  from Deduplicated dd

\noindent
  where {\textbf{compareObject}}(dd.gen, dd.dup)\;$>$\;0.8
  }

  \subsection{Реализация методов слияния данных}

     Будем считать, что этап разрешения сущностей уже пройден и~дана некоторая
коллекция Deduplicated, где уже установлены соответствия одним из вышеперечисленных
способов. Например, пусть имеются две коллекции: A (id, a, b, c) и~B (id, a, b, d). Атрибуты
a, b, c, d могут содержать null-значения, атрибуты id совпадают. Ниже дан пример подобных
данных для коллекции~А в~формате JSON:

{\sf
\noindent
  [\{"a":null,"b":null,"c":"wmqhxfgmac",

  \noindent
  "id":919132322\},

\noindent
  \{"a":null,"b":null,"c":"wmqhxfgmac",

  \noindent
  "id":919132322\}]
}
  Тогда коллекция разрешенных сущностей может быть получена следующим образом:

{\sf
\noindent
  create link Deduplicated as

\noindent
  select


\noindent
[gen: [id: a.id, a:a.a, b:a.b, c:a.c],

\noindent
  dup:  [id: b.id, a:b.a, b:b.b, d:b.d]]

\noindent
  from A a, B b

\noindent
  match using

\noindent
  \hspace*{3pt}rule1: a.id\;=\;b.id;
  }

  Рассмотрим теперь реализацию Minimum Union и~оператор Fusion~\cite{13-vov} на языке
HIL.

  Как было определено в~разд.~3, \textbf{Minimum Union}~--- это
последовательное применение операций {\sf outer union}
и~{\sf subsumption}~\cite{11-vov}. {\sf Outer
Union} фактически реализуется с~помощью индекса {\sf FusionIndex}. Использование индекса
оправдано, так как существует несколько записей, описывающих одну сущность. Ключом
является атрибут id. Ниже представлена реализация операции {\sf Outer Union}:

{\sf
\noindent
  insert into {\textbf{FusionIndex}}![id: f.gen.id] select [a: f.gen.a, b:
f.gen.b, c: f.gen.c] from Deduplicated f;

  \vspace*{6pt}

\noindent
  insert into {\textbf{FusionIndex}}![id: f.dup.id] select [a: f.dup.a, b: f.dup.b, d:
f.dup.d] from Deduplicated f;
}

  Далее для реализации subsumption требуется удалить все ненужные кортежи. Это делается
на языке Jaql. Для этого нужна функция, которая бы определяла, поглощается ли один
кортеж другим. К~сожалению, в~языке Jaql нет возможностей написания общих (generic)
методов, универсальных для всех коллекций, поэтому функцию сравнения можно
реализовать на Java и~подключить к~языку Jaql подобно тому, как демонстрировалось
в~подразд.~5.1 на примере функций вычисления меры. Либо же можно реализовать функцию
для сравнения конкретных коллекций на языке Jaql, как показано ниже:

{\sf
 \noindent
{\textbf{is\_subsumed}} = fn(i,j) ((


 \noindent isnull(j.a) or (i.a\;==\;j.a) ) and (isnull(j.b) or

 \noindent
 \ (i.b\;==\;j.b))  and (isnull(j.c) or (i.c\;==\;j.c)) and

 \noindent
 \ (snull(j.d) or (i.d\;==\;j.d)) and (i!\;=\;j));
  }

  Функция \textbf{is\_subsumed(i,j)} проверяет, поглощает ли один кортеж другой
при помощи попарного сравнения атрибутов или проверки на null.

{\sf \noindent
{\textbf{removeSubsumed}}\;=\;fn (a) (b = a,

\noindent
  subs = for (i0 in b) [a\;$\to$\;filter is\_subsumed(i0,\$)],

  s = subs\;$\to$\;expand,

\noindent
  a\;$\to$\;filter not \$ in s);
}

  Функция \textbf{removeSubsumed} удаляет все поглощенные записи из кортежа. Здесь
реализован наивный алгоритм, который попарно для каждого кортежа находит все
поглощенные им и~удаляет их.

{\sf
\noindent
{\textbf{minUnion}}\;=\;fn(id,a) ( \{id:id, minunion:


\noindent
\ {\textbf{removeSubsumed}}(a)\});
}

  Функция \textbf{minUnion} нужна для построения результирующих кортежей при
реализации Minimum Union. С~ее помощью операцию Minumum Union можно описать
следующим образом на языке HIL:

{\sf \noindent
  insert into {\textbf{MinimumUnion}}

\noindent
  select {\textbf{minUnion}}(i.dup.id,

\noindent
  \hspace*{10mm}{\textbf{FusionIndex}}![id : i.dup.id])

\noindent
  from Deduplicated i;
  }

  Для каждого id достаются все соответствующие записи и~удаляются те, которые ими
поглощаются.

  Оператор \textbf{Data Fusion}~\cite{13-vov} представляет собой особый вид функции,
использующий группировку для преодоления конфликтов. Основная идея заключается
в~группировке различных представлений одной и~той же сущности по общему атрибуту,
а~затем в~применении функций разрешения конфликтов для всех остальных атрибутов,
сливая данные в~одну сущность. Различают два вида стратегии для функций разрешения
конфликтов:
  \begin{enumerate}[(1)]
\item deciding-стратегия заключается в~выборе ка\-ко\-го-то одного значения каким-то
способом (минимум, максимум, случайное значение);
\item mediating-стратегия заключается в~агрегации всех значений (среднее значение,
сумма).
\end{enumerate}

  Пусть имеются две коллекции: A (id, name, age) и~B (id, name, info), пример которых дан
ниже:

{\sf
\noindent
  A

\noindent
  [\{"id":760046903,"name":null,"age":null\},

\noindent
  \{"id":15009544, "name":
"zvqcsxkzxk",

\noindent
"age":938781652\}]

  \vspace*{6pt}

\noindent
  B

\noindent
  [\{"id":15009544, "name":null,
"info":null\},

\noindent
  \{"id":760046903,
"name":"pjltaghyug","info":null\}]

}

  Пусть для них пройден этап разрешения сущностей и~построена коллекция Deduplicated,
как описано выше в~этом разделе. Пусть также для этих данных построен индекс
FusionIndex, как показано выше для операции Minimum Union. Тогда оператор Data Fusion на
языке HIL может быть описан следующим образом:

{\sf
\noindent
  @jaql\{

\noindent
  {\textbf{average}} = fn(\$a) avg(\$a[*].age);

\noindent
  {\textbf{any}} = fn(\$a) any(\$a[*].name);

\noindent
  {\textbf{concat}} = fn (\$a) strJoin(\$a[*].info,"\_");

\noindent
  \}


  \vspace*{3pt}

\noindent
insert into {\textbf{Fused}}

\noindent
select [

\noindent
id: i.dup.id,

\noindent
age:

\noindent
    \hspace*{3pt}{\textbf{average}}(FusionIndex![id: i.dup.id]),

\noindent
name:

\hspace*{6pt}

\noindent
{\textbf{any}}(FusionIndex![id: i.dup.id]),

\noindent
info:

\noindent
    \hspace*{3pt}{\textbf{concat}}(FusionIndex![id: i.dup.id])]

\noindent
from Deduplicated i;

}

  Функции вычисления среднего, выбора случайного ненулевого значения, а также
конкатенации реализованы на Jaql. Данное правило образует коллекцию \textbf{Fused},
причем для атрибута {\sf age} будет подсчитано среднее значение, для имени {\sf name}
выбрано любое ненулевое значение, а~для атрибута {\sf info} будет получена
конкатенация всех доступных значений. Таким образом, в~данном примере показана
реализация обеих стратегий для функций разрешения конфликтов в~операторе Data Fusion.

\section{Заключение}

  Рассмотренные методы и~операции извлечения и~интеграции информации о~сущностях
реального мира, представленной сырыми разноструктурированными коллекциями данных,
позволяют программировать интеграционные потоки вида ETL для образования
интегрированных структурированных данных, которые могут быть использованы
в~приложениях для дальнейшего анализа и~обработки. В~статье рассмотрены методы
разрешения сущностей и~слияния данных. В~статье показаны способы программирования
методов и~операций извлечения и~интеграции информации о~сущностях реального мира,
включая методы слияния данных, на декларативном языке HIL.


{\small\frenchspacing
 {%\baselineskip=10.8pt
 \addcontentsline{toc}{section}{References}
 \begin{thebibliography}{99}
\bibitem{1-vov}
\Au{White T.} Hadoop: The definitive guide.~--- 3rd ed.~--- O'Reilly Media, 2012.
688~p.
\bibitem{2-vov}
Apache Hadoop 2.5.1. {\sf http://hadoop.apache.org}.

\bibitem{5-vov} %3
\Au{Naumann F., Herschel~M.} An introduction to duplicate detection.
Synthesis lectures on
data management.~--- Morgan \& Claypool, 2010. Lecture No.\,3. 87~p.

\bibitem{3-vov} %4
\Au{Christen P.} Data matching~---  concepts and techniques for record linkage, entity
resolution, and duplicate detection. Data-centric systems and applications
ser.~--- Springer, 2012. 272~p.

\bibitem{4-vov} %5
\Au{Fan W., Geerts F.} Foundations of data quality management. Synthesis lectures on data
management.~--- Morgan \& Claypool, 2012. Lecture No.\,29. 217~p.


\bibitem{6-vov} %6
\Au{Bleiholder J., Naumann F.} Data fusion~// ACM Computing Surveys (CSUR), 2009.
Vol.~41. Iss.~1. Article No.\,1. doi: 10.1145/1456650.1456651.


\bibitem{9-vov} %7
\Au{K$\ddot{\mbox{o}}$pcke H., Thor A., Rahm~E.} Evaluation of entity resolution approaches
on real-world match problems~// Proc. VLDB Endowment, 2010. Vol.~3. Iss.~1-2.
P.~484--493.
\bibitem{10-vov} %8
\Au{K$\ddot{\mbox{o}}$pcke H., Rahm E.} Frameworks for entity matching: A~comparison~//
Data Knowledge Engineering, 2010. Vol.~69. Iss.~2. P.~197--210.
doi: 10.1016/j.datak. 2009.10.003.
\bibitem{7-vov} %9
\Au{Ganti V., Das Sarma A.} Data cleaning, a~practical perspective. Synthesis lectures on
data management.~--- Morgan \& Claypool, 2013. Lecture No.\,36. 85~p.
\bibitem{8-vov} %10
\Au{Getoor L., Machanavajjhala~A.} Entity resolution for big data~// KDD'13: 19th ACM
SIGKDD Conference on Knowledge Discovery and Data Mining Proceedings, 2013.
P.~1527--1527.

\bibitem{13-vov} %11
\Au{Bleiholder J., Naumann~F.} Declarative data fusion~--- syntax, semantics, and
implementation~// East European Conference on Advances in Databases and Information
Systems (ADBIS) Proceedings, 2005. P.~58--73.

\bibitem{12-vov} %12
\Au{Luna Dong X., Naumann F.} Data fusion~--- resolving data conflicts in integration~//
Proc. VLDB Endowment, 2009. Vol.~2. Iss.~2. P.~1654--1655.

\bibitem{11-vov} %13
\Au{Bleiholder J.} Data fusion and conflict resolution in integrated
information systems.~--- Potsdam: Hasso-Plattner-Institut, 2010. D.Sc. Diss. 184~p.


\bibitem{14-vov} %14
\Au{Winkler W.\,E.} Overview of record linkage and current research directions.
Research
report ser. (Statistics \#\,2006-2).~---
Washington, DC: Statistical Research Division, U.S. Census Bureau, 2006.
{\sf http://www.census.gov/srd/papers/pdf/rrs2006-02.pdf}.
\bibitem{15-vov}
\Au{Adamic L.\,A., Adar E.} Friends and neighbors on the Web~// Social networks, 2003.
Vol.~25. No.\,3. P.~211--230.
\bibitem{16-vov}
\Au{Bilenko M., Mooney R., Cohen~W., Ravikumar~P., Fienberg~S.} Adaptive name matching
in information integration~// IEEE Intell. Syst., 2003. Vol.~18. No.\,5. P.~16--23.
\bibitem{17-vov}
Monge--Elkan distance function.
{\sf http://www. gabormelli.com/RKB/Monge-Elkan\_Distance\_Function}.
\bibitem{18-vov}
\Au{Cochinwala M., Kurienb~V., Lalka~G., Shasha~D.} Efficient data reconciliation~//
Inform. Sci. Int.~J., 2001. Vol.~137. Iss.~1-4. P.~1--15.
\bibitem{19-vov}
\Au{Bilenko M., Mooney R.} Adaptve duplicate detecton using learnable string similarity
measures~// KDD'03: 9th ACM SIGKDD  Conference (International) on Knowledge Discovery
and Data Mining Proceedings, 2003. P.~39--48.
\bibitem{20-vov}
\Au{Christen P.} Automatic record linkage using seeded nearest neighbour and support vector
machine classification~// KDD'08:  14th ACM SIGKDD Conference (International) on
Knowledge Discovery and Data Mining  Proceedings, 2008. P.~151--159.
\bibitem{21-vov}
\Au{Chen Z., Kalashnikov D.\,V., Mehrotra~S.} Exploiting context analysis for combining
multiple entity resolution systems~// SIGMOD'09: 2009 ACM SIGMOD Conference
(International) on Management of Data Proceedings, 2009. P.~207--218.
\bibitem{22-vov}
\Au{Gupta R., Sarawagi S.} Answering table augmentaton queries from unstructured lists on the
Web~// Proc. VLDB Endowment, 2009. Vol.~2. Iss.~1. P.~289--300.
\bibitem{23-vov}
\Au{Ravikumar P., Cohen W.} A~hierarchical graphical model for record linkage~// UAI'04:
20th Conference on Uncertainty in Artificial Intelligence Proceedings, 2004. P.~454--461.

\bibitem{25-vov} %24
\Au{Tejada S., Knoblock C.\,A., Minton~S.} Learning object identification rules for information
integration~// Inform. Syst. Data Extraction Cleaning Reconciliation, 2001.
Vol.~26. Iss.~8. P.~607--633.

\bibitem{24-vov} %25
\Au{Sarawagi S., Bhamidipaty A.} Interactive deduplication using active learning~// KDD'02:
8th ACM SIGKDD Conference (International) on Knowledge Discovery and Data Mining
Proceedings, 2002. P.~269--278.

\bibitem{26-vov} %26
\Au{Arasu A., G$\ddot{\mbox{o}}$tz M., Kaushik~R}. On active learning of record matching
packages // SIGMOD'10: 2010 ACM SIGMOD Conference (International) on Management of
Data Proceedings, 2010. P.~783--794.
\bibitem{27-vov}
\Au{Bellare K., Iyengar~S, Parameswaran~A.\,G., Rastogi~V.} Active sampling for entity
matching // KDD'12: 18th ACM SIGKDD  Conference (International) on Knowledge Discovery
and Data Mining Proceedings, 2012. P.~1131--1139.
\bibitem{28-vov}
\Au{Adam K., Wu E., Karger~D., Madden~S., Miller~R.} Human-powered sorts and joins~//
Proc. VLDB Endowment, 2011. Vol.~5. Iss.~1. P.~13--24.
\bibitem{29-vov}
\Au{Wang J., Kraska T., Franklin~M.\,J., Feng~J.} CrowdER: Crowdsourcing Entity
Resolution~// Proc. VLDB Endowment, 2012. Vol.~5. Iss.~11. P.~1483--1494.
\bibitem{30-vov}
\Au{Ananthakrishna R., Chaudhuri~S., Ganti~V.} Eliminating fuzzy duplicates in data
warehouses~// VLDB'02:  28th Conference (International) on Very Large Data Bases
Proceedings, 2002. P.~586--597.
\bibitem{31-vov}
\Au{Fan W., Geerts F., Jia~X., Kementsietsidis~A.} Conditional functional dependencies for Data
cleaning~// ICDE'07: 23rd IEEE Conference (International) on Data Engineering Proceedings,
2007. P.~746--755.
\bibitem{32-vov}
\Au{Fan W.} Dependencies revisited for improving data quality~// PODS'08:  27th ACM
SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems Proceedings, 2008.
P.~159--170.
\bibitem{33-vov}
\Au{Benjelloun O., Garcia-Molina~H., Menestrina~D., Su~Q., Whang~S.\,E., Widom~J.}
Swoosh: A~generic approach to Entity Resolution~// VLDB Int.~J., 2009.
Vol.~18. Iss.~1. P.~255--276.
\bibitem{34-vov}
\Au{Bhattacharya I., Getoor L.} Collective Entity Resolution in relational data~// ACM
Transactions on Knowledge Discovery from Data (TKDD), 2007. Vol.~1. Iss.~1. Article No.\,5.
doi: 10.1145/1217299.1217304.
\bibitem{35-vov}
\Au{Bhattacharya I., Getoor L.} A~latent Dirichlet model for unsupervised Entity Resolution~//
6th SIAM Conference (International) on Data Mining Proceedings, 2007. P.~47--58.
\bibitem{36-vov}
\Au{Broecheler M., Getoor~L.} Probabilistic similarity logic~// UAI'10:  26th Conference on
Uncertainty in Artificial Intelligence Proceedings, 2010. P.~73--82.
\bibitem{37-vov}
\Au{Rajaraman A., Ullman~J.\,D.} Integrating information by outerjoins and full disjunctions~//
PODS'96: 15th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database
Systems Proceedings, 1996. P.~238--248.
\bibitem{38-vov}
\Au{Dean J., Ghemawat S.} MapReduce: Simplified data processing on large clusters~//
Comm. ACM, 2008. Vol.~51. Iss.~1. P.~107--113.
\bibitem{39-vov}
MapReduce Tutorial. {\sf http://hadoop.apache.org/docs/\linebreak r1.2.1/mapred\_tutorial.html}.
\bibitem{40-vov}
Apache Pig Project. {\sf http://pig.apache.org}.
\bibitem{41-vov}
The Apache Hive data warehouse. {\sf http://hive. apache.org}.
\bibitem{42-vov}
IBM InfoSphere BigInsights Version~3.0, Jaql reference.~--- 2014.
{\sf
http://www-01.ibm.com/support/\linebreak knowledgecenter/SSPT3X\_3.0.0/com.ibm.swg.im.\linebreak infosphere.biginsights.jaql.doc/doc/c
0057749.html}.
\bibitem{43-vov}
\Au{Das Sarma A., Jain A., Machanavajjhala~A., Bohannon~P.} An automatic blocking
mechanism for large-scale de-duplication tasks~// CIKM'12:  21st ACM Conference
(International) on Information and Knowledge Management Proceedings, 2012. P.~1055--1064.
\bibitem{44-vov}
\Au{Papadakis G., Ioannou E., Nieder$\acute{\mbox{e}}$e~C., Palpanas~T., \mbox{Nejdl}~W.} Beyond
100 million entities: Large-scale blocking-based resolution for heterogeneous data~//
\mbox{WSDM'12}:
5th ACM Conference (International) on Web Search and Data Mining Proceedings, 2012.
P.~53--62.
\bibitem{45-vov}
\Au{Kolb L., Thor A., Rahm E.} Dedoop: Efficient deduplication with Hadoop~// Proceedings of
the VLDB Endowment, 2012. Vol.~5. Iss.~12. P.~1878--1881.
\bibitem{46-vov}
\Au{Hern$\acute{\mbox{a}}$ndez M., Koutrika G., Krishnamurthy~R., Popa~L.,
Wisnesky~R.}
HIL: A~high-level scripting language for entity integration~// EDBT'13: 16th Conference
(International) on Extending Database Technology Proceedings, 2013. P.~549--560.
 \end{thebibliography}

 }
 }

\end{multicols}

\vspace*{-6pt}

\hfill{\small\textit{Поступила в редакцию 09.11.14}}

%\newpage

\vspace*{10pt}

\hrule

\vspace*{2pt}

\hrule

%\vspace*{12pt}

\def\tit{METHODS OF ENTITY RESOLUTION AND DATA FUSION\\
IN~THE~ETL-PROCESS AND THEIR IMPLEMENTATION IN~THE~HADOOP~ENVIRONMENT}

\def\titkol{Methods of entity resolution and~data fusion
in~the~ETL-process and their implementation in the Hadoop environment}

\def\aut{A.\,E.~Vovchenko$^1$, L.\,A.~Kalinichenko$^{1,2}$,
and~D.\,Yu.~Kovalev$^1$}

\def\autkol{A.\,E.~Vovchenko, L.\,A.~Kalinichenko,
and~D.\,Yu.~Kovalev}

\titel{\tit}{\aut}{\autkol}{\titkol}

\vspace*{-9pt}

\noindent
$^1$Institute of Informatics Problems, Russian Academy of Sciences,
44-2~Vavilov Str., Moscow 119333, Russian\linebreak
$\hphantom{^1}$Federation

\noindent
$^2$Faculty of Computational Mathematics and Cybernetics,
M.\,V.~Lomonosov Moscow State University,
1-52~Lenin-\linebreak
$\hphantom{^1}$skiye Gory, GSP-1, Moscow 119991, Russian Federation

\def\leftfootline{\small{\textbf{\thepage}
\hfill INFORMATIKA I EE PRIMENENIYA~--- INFORMATICS AND
APPLICATIONS\ \ \ 2014\ \ \ volume~8\ \ \ issue\ 4}
}%
 \def\rightfootline{\small{INFORMATIKA I EE PRIMENENIYA~---
INFORMATICS AND APPLICATIONS\ \ \ 2014\ \ \ volume~8\ \ \ issue\ 4
\hfill \textbf{\thepage}}}

\vspace*{6pt}


  \Abste{Entities extraction, their transformation and loading
  in the integrated repository are the main problem of data integration.
  These actions are part of the ETL-process (extract--transform--loading).
An entity is a~digital representation of a real world object (for example,
  information about a~person). Entity resolution takes care of duplicate detection,
  deduplication, record linkage, object identification, reference matching,
  and other ETL-related tasks. After the entity resolution step, entities should
  be merged into the one reference entity (containing information from all
  related entities). Data fusion is the final step in the data integration
  process. The paper gives an overview of the entity resolution and data fusion
  methods. Also, the paper presents the techniques for programming the entity
  resolution and data fusion methods for implementing the ETL-process in the
  Hadoop environment.  High-Level Integration Language (HIL),
  a~declarative language that focuses on resolution and fusion of
 entities in the  Hadoop-infrastructure, is used in this part of the paper.}

 \vspace*{1pt}

  \KWE{data integration; ETL; entity resolution; data fusion; big data; Hadoop; Jaql; HIL}

  \DOI{10.14357/19922264140412}

\vspace*{-12pt}


\Ack
\noindent
This work was supported by the Russian Foundation for Basic Research
(projects 13-07-00579 and 14-07-00548), Institute of informatics Problems
of the Russian Academy of Sciences (IPI RAN) (theme 38.25
``Specification and problem solving of data analysis in conceptual terms
of subject areas with intensive use of data''
of the state task for IPI RAN), and the Presidium of the Russian Academy
of Sciences (Basic Research Program No.\,16 ``Fundamental problems of
system programming'').


\vspace*{3pt}

  \begin{multicols}{2}

\renewcommand{\bibname}{\protect\rmfamily References}
%\renewcommand{\bibname}{\large\protect\rm References}



{\small\frenchspacing
 {%\baselineskip=10.8pt
 \addcontentsline{toc}{section}{References}
 \begin{thebibliography}{99}


\bibitem{1-vov-1}
\Aue{White, T.} 2012. Hadoop: The definitive guide. 3rd ed.
O'Reilly Media. 688~p.
\bibitem{2-vov-1}
Apache Hadoop 2.5.1. Available at: {\sf http://hadoop. apache.org/}
(accessed November~01, 2014).

\bibitem{5-vov-1} %3
\Aue{Naumann, F., and M. Herschel}. 2010.
\textit{An introduction to duplicate detection}.
Synthesis lectures on data management.  Morgan \& Claypool. Lecture No.\,3. 87~p.

\bibitem{3-vov-1} %4
\Aue{Christen, P.} 2012.
\textit{Data matching~--- concepts and techniques for record linkage, entity resolution,
and duplicate detection}. {Data-centric systems and applications} ser.
Springer. 272~p.
\bibitem{4-vov-1} %5
\Aue{Fan, W., and F. Geerts.} 2012. \textit{Foundations of data quality management}.
Synthesis lectures on data management.
Morgan \& Claypool. Lecture No.\,29. 217~p.

\bibitem{6-vov-1}
\Aue{Bleiholder, J., and F.~Naumann}. 2009.
Data fusion. \textit{ACM Computing Surveys (CSUR)} 41(1). Article No.\,1.
doi: 10.1145/1456650.1456651.

\bibitem{9-vov-1} %7
\Aue{K$\ddot{\mbox{o}}$pcke, H., A.~Thor, and E.~Rahm}.
2010. Evaluation of entity resolution approaches on real-world match problems.
\textit{Proc. VLDB Endowment} 3(1-2):484--493.
\bibitem{10-vov-1} %8
\Aue{K$\ddot{\mbox{o}}$pcke, H., and E.~Rahm}. 2010. Frameworks for
entity matching: A~comparison. \textit{Data Knowledge Engineering} 69(2):197--210.
doi: 10.1016/j.datak.2009.10.003.

\bibitem{7-vov-1} %9
\Aue{Ganti, V., and A. Das Sarma}. 2013. Data cleaning: A~practical perspective.
{Synthesis lectures on data management}.  Morgan \& Claypool.
Lecture No.\,36. 85~p.
\bibitem{8-vov-1} %10
\Aue{Getoor, L., and A.~Machanavajjhala}.
2013. Entity resolution for big data. \textit{19th ACM SIGKDD
Conference (International) on Knowledge Discovery and Data Mining (KDD'13)
Proceedings}. Chicago. 1527--1527.

\bibitem{13-vov-1} %11
\Aue{Bleiholder, J., and F. Naumann}. 2005. Declarative data fusion~---
syntax, semantics, and implementation. \textit{East European Conference on
Advances in Databases and Information Systems (ADBIS) Proceedings}. Tallinn. 58--73.


\bibitem{12-vov-1} %12
\Aue{Dong, L.\,X., and F.~Naumann}. 2009. Data fusion~---
resolving data conflicts in Integration.
\textit{Proc. VLDB Endowment} 2(2):1654--1655.

\bibitem{11-vov-1} %13
\Aue{Bleiholder, J.} 2010. Data fusion and conflict resolution in integrated
information systems.  Potsdam. D.Sc. Diss. 184~p.


\bibitem{14-vov-1} %14
\Aue{Winkler, W.\,E.} 2006.
Overview of record linkage and current research directions.
 Research report ser. No.\,2006-2.
Washington, DC: Statistical Research Division, U.S. Census Bureau. 44~p. Available at:
{\sf http:// www.census.gov/srd/papers/pdf/rrs2006-02.pdf} (accessed November~01, 2014).
\bibitem{15-vov-1}
\Aue{Adamic, L.\,A., and E.~Adar}. 2003. Friends and neighbors on the Web.
\textit{Social Networks} 25:211--230.
\bibitem{16-vov-1}
\Aue{Bilenko, M., R. Mooney, W.~Cohen, P.~Ravikumar, and S.~Fienberg}.
2003. Adaptive name matching in information integration.
\textit{IEEE Intell. Syst.} 18(5):16--23.
\bibitem{17-vov-1}
Monge--Elkan distance function. Available at:
{\sf http://\linebreak www.gabormelli.com/RKB/Monge-Elkan\_Distance\_ Function}
(accessed November~01, 2014).
\bibitem{18-vov-1}
\Aue{Cochinwala, M., V. Kurienb, G.~Lalka, and D.~Shasha}.
2001. Efficient data reconciliation.
\textit{Inform. Sci. Int.~J.} 137(1-4):1--15.
\bibitem{19-vov-1}
\Aue{Bilenko, M., and R.~Mooney}. 2003.
Adaptve duplicate detecton using learnable string similarity measures.
\textit{9th ACM SIGKDD  Conference (International) on Knowledge Discovery and
Data Mining (SIGKDD 2003) Proceedings}. Washington. 39--48.
\bibitem{20-vov-1}
\Aue{Christen, P.} 2008. Automatic record linkage using seeded nearest
neighbour and support vector machine classification.
\textit{14th ACM SIGKDD  Conference (International) on Knowledge Discovery and
Data Mining (KDD'2008) Proceedings}. Las Vegas. 151--159.
\bibitem{21-vov-1}
\Aue{Chen, Z., D.\,V.~Kalashnikov, and S.~Mehrotra}. 2009.
Exploiting context analysis for combining multiple entity resolution systems.
\textit{2009 ACM SIGMOD  Conference (International) on Management of Вata (SIGMOD 2009)
Proceedings}. Providence. 207--218.
\bibitem{22-vov-1}
\Aue{Gupta, R., and S.~Sarawagi}. 2009.
Answering table augmentaton queries from unstructured lists on the Web.
\textit{Proc. VLDB Endowment} 2(1):289--300.
\bibitem{23-vov-1}
\Aue{Ravikumar, P., and W.~Cohen}. 2004. A~hierarchical
graphical model for record linkage. \textit{20th Conference on Uncertainty in
Artificial Intelligence (UAI 2004) Proceedings}.  Virginia. 454--461.

\bibitem{25-vov-1} %24
\Aue{Tejada, S., C.\,A. Knoblock, and S.~Minton}. 2001.
Learning object identification rules for information integration.
\textit{Inform. Syst. Data Extraction Cleaning Reconciliation} 26(8):607--633.

\bibitem{24-vov-1} %25
\Aue{Sarawagi, S., and A.~Bhamidipaty}. 2002.
Interactive deduplication using active learning.
\textit{8th ACM SIGKDD  Conference (International) on Knowledge Discovery and
Data Mining (KDD 2002) Proceedings}. Edmonton. 269--278.

\bibitem{26-vov-1}
\Aue{Arasu, A., M.~G$\ddot{\acute{o}}$tz, and R.~Kaushik}. 2010.
On active learning of record matching packages.
\textit{2010 ACM \mbox{SIGMOD}  Conference (International)
on Management of Data Proceedings}.  Indianapolis. 783--794.
\bibitem{27-vov-1}
\Aue{Bellare, K., S.~Iyengar, A.\,G.~Parameswaran, and V.~Rastogi}. 2012.
Active sampling for entity matching. \textit{18th ACM SIGKDD
Conference (International) on Knowledge Discovery and Data Mining (KDD 2012) Proceedings}. Beijing. 1131--1139.
\bibitem{28-vov-1}
\Aue{Adam, K., E. Wu, D.~Karger, S.~Madden, and R.~Miller}.
2011. Human-powered sorts and joins. \textit{Proc. VLDB Endowment} 5(1):13--24.
\bibitem{29-vov-1}
\Aue{Wang, J., T. Kraska, M.\,J.~Franklin, and J.~Feng}. 2012.
CrowdER: Crowdsourcing Entity Resolution.
\textit{Proc. VLDB Endowment} 5(11):1483--1494.
\bibitem{30-vov-1}
\Aue{Ananthakrishna, R., S.~Chaudhuri, and V.~Ganti}. 2002.
Eliminating fuzzy duplicates in data warehouses. \textit{28th Conference (International) on
Very Large Data Bases (VLDB 2002)
Proceedings}. Hong Kong. 586--597.
\bibitem{31-vov-1}
\Aue{Fan, W., F. Geerts, X.~Jia, and A.~Kementsietsidis}. 2007.
Conditional functional dependencies for data cleaning. \textit{2007 IEEE
23rd  Conference (International) on Data Engineering Proceeding}. Istanbul. 746--755.
\bibitem{32-vov-1}
\Aue{Fan, W.} 2008. Dependencies revisited for improving data quality.
\textit{27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems
(PODS 2008) Proceedings}.  Vancouver.  159--170.
\bibitem{33-vov-1}
\Aue{Benjelloun, O., H.~Garcia-Molina, D.~Menestrina, Q.~Su, S.\,E.~Whang, and
J.~Widom}. 2009. Swoosh: A~generic approach to Entity Resolution.
\textit{VLDB Int.~J.} 18(1):255--276.
\bibitem{34-vov-1}
\Aue{Bhattacharya, I., and L.~Getoor}. 2007.
Collective Entity Resolution in relational data.
\textit{ACM Trans. Knowledge Discovery Data (TKDD)} 1(1). Article No.\,5.
doi: 10.1145/1217299.1217304.
\bibitem{35-vov-1}
\Aue{Bhattacharya, I., and L.~Getoor}. 2007. A~latent
Dirichlet model for unsupervised Entity Resolution.
\textit{6th SIAM  Conference (International) on Data Mining Proceedings}. Maryland. 47--58.
\bibitem{36-vov-1}
\Aue{Broecheler, M., and L.~Getoor}. 2010.
Probabilistic similarity logic. \textit{26th Conference on Uncertainty in Artificial Intelligence
Proceedings}. Corvallis. 73--82.
\bibitem{37-vov-1}
\Aue{Rajaraman, A., and J.\,D.~Ullman}. 1996. Integrating information by
outerjoins and full disjunctions. \textit{15th ACM SIGACT-SIGMOD-SIGART Symposium
on Principles of Database Systems (PODS1996) Proceedings}. Montreal. 238--248.
\bibitem{38-vov-1}
\Aue{Dean, J., and S.~Ghemawat}. 2008. MapReduce: Simplified
data processing on large clusters.
\textit{Comm. ACM} 51(1):107--113.
\bibitem{39-vov-1}
MapReduce tutorial. Available at:
{\sf http://hadoop. apache.org/docs/r1.2.1/mapred\_tutorial.html} (accessed November~01, 2014).
\bibitem{40-vov-1}
Apache Pig Project. Available at: {\sf http://pig.apache.org/} (accessed November~01, 2014).
\bibitem{41-vov-1}
The Apache Hive data warehouse. Available at:
{\sf http:// hive.apache.org/} (accessed November~01, 2014).
\bibitem{42-vov-1}
IBM InfoSphere BigInsights Version~3.0, Jaql reference.
Available at: {\sf http://www-01.ibm.com/\linebreak
support/knowledgecenter/SSPT3X\_3.0.0/com.ibm.swg. im.infosphere.biginsights.jaql.doc/doc/c0057749.html} (accessed November~01, 2014).
\bibitem{43-vov-1}
\Aue{Sarma, D.\,A., A.~Jain, A.~Machanavajjhala, and P.~Bohannon}.
2012. An automatic blocking mechanism for large-scale de-duplication tasks.
\textit{21st ACM  Conference (International) on Information and Knowledge Management
Proceedings}. Maui. 1055--1064.
\bibitem{44-vov-1}
\Aue{Papadakis, G., E.~Ioannou, C.~Nieder$\acute{\mbox{e}}$e, T.~Palpanas, and
W.~Nejdl}. 2012. Beyond 100~million entities: Large-scale blocking-based
resolution for heterogenous data. \textit{5th ACM  Conference (International) on
Web Search and Data Mining Proceedings}. Seattle. 53--62.
\bibitem{45-vov-1}
\Aue{Kolb, L., A. Thor, and E.~Rahm}. 2012. Dedoop: Efficient deduplication with
Hadoop. \textit{Proceedings of the VLDB Endowment} 5(12):1878--1881.
\bibitem{46-vov-1}
\Aue{Hern$\acute{\mbox{a}}$ndez, M., G.~Koutrika, R.~Krishnamurthy, L.~Popa, and
R.~Wisnesky}. 2013. HIL: A~high-level scripting language for entity integration.
\textit{16th  Conference (International) on Extending Database Technology (EDBT'13)
Proceedings}.  Genoa. 549--560.
\end{thebibliography}

 }
 }

\end{multicols}

\vspace*{-6pt}

\hfill{\small\textit{Received November 9, 2014}}

\vspace*{-18pt}

\Contr

\noindent
\textbf{Vovchenko Alexey E.} (b.\ 1984)~---
Candidate of Science (PhD) in technology, senior researcher,
Institute of Informatics Problems, Russian Academy of Sciences;
44-2 Vavilov Str., Moscow 119333, Russian Federation;
alexey.vovchenko@gmail.com

\vspace*{3pt}

\noindent
\textbf{Kalinichenko Leonid A.} (b.\ 1937)~---
Doctor of Science in physics and mathematics, professor; Head of Laboratory,
Institute of Informatics Problems,
Russian Academy of Sciences;
44-2 Vavilov Str., Moscow 119333, Russian Federation;
professor, Faculty of Computational Mathematics and Cybernetics,
M.\,V.~Lomonosov Moscow State University, 1-52  Leninskiye Gory, GSP-1, Moscow 119991, Russian Federation;
 leonidk@synth.ipi.ac.ru

\vspace*{3pt}

\noindent
\textbf{Kovalev Dmitry  Yu.} (b.\ 1988)~---
junior researcher, Institute of Informatics Problems,
Russian Academy of Sciences, 44-2 Vavilov Str., Moscow 119333, Russian Federation;
 dm.kovalev@gmail.com




\label{end\stat}

\renewcommand{\bibname}{\protect\rm Литература}
