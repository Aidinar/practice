\def\stat{rudoi}

\def\tit{АЛГОРИТМЫ ИНДУКТИВНОГО ПОРОЖДЕНИЯ СУПЕРПОЗИЦИЙ ДЛЯ~АППРОКСИМАЦИИ ИЗМЕРЯЕМЫХ ДАННЫХ$^*$}

\def\titkol{Алгоритмы индуктивного порождения суперпозиций для аппроксимации измеряемых данных}

\def\autkol{Г.\,И.~Рудой, В.\,В.~Стрижов}

\def\aut{Г.\,И.~Рудой$^1$, В.\,В.~Стрижов$^2$}

\titel{\tit}{\aut}{\autkol}{\titkol}

{\renewcommand{\thefootnote}{\fnsymbol{footnote}}\footnotetext[1]
{Работа выполнена при поддержке РФФИ, грант №\,12-07-13118.}}

\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{Московский физико-технический институт, rudoy@forecsys.ru}
\footnotetext[2]{Вычислительный центр Российской академии наук 
им.~А.\,А. Дородницына, strijov@ccas.ru}

\vspace*{-3pt}

\Abst{Исследуется алгоритм индуктивного порождения допустимых существенно
  нелинейных моделей. Предлагается алгоритм, порождающий все возможные
  суперпозиции заданной сложности за конечное число шагов. Приводятся
  результаты вычислительного
  эксперимента по выбору оптимальной модели, аппроксимирующей синтетический
  набор данных.}
  
  \vspace*{-1pt}

\KW{символьная регрессия; нелинейные модели; индуктивное порождение;
    сложность моделей}
    
    \vspace*{-3pt}
    
    \vskip 12pt plus 9pt minus 6pt

      \thispagestyle{headings}

      \begin{multicols}{2}

            \label{st\stat}

\section{Введение}

В~ряде приложений~\cite{duffy:1999:srised, Barmpalexis201175}
возникает задача восстановления некоторой функциональной зависимости
по набору известных данных. При этом предполагается, что эксперт
должен иметь возможность проинтерпретировать полученную модель
в контексте предметной области.

Одним из методов, позволяющих получать интерпретируемые модели, является
символьная регрессия~[3--7],
согласно которой известные данные приближаются некоторой математической
формулой, например $\sin x^2 \hm+ 2x $ или $\log x \hm- {e^x}/{x} $.
Эти формулы являются произвольными суперпозициями функций из некоторого
заданного набора. Одна из возможных реализаций описываемого метода
предложена Джоном Коза~\cite{Koza1998GP, Koza1998Intro}, использовавшим
эволюционные алгоритмы для реализации символьной регрессии. Зелинка с соавторами
предложили дальнейшее развитие этой идеи~\cite{Zelinka2008}, получившее
название аналитического программирования.

Алгоритм построения требуемой математической модели в аналитическом
программировании выглядит следующим образом:
дан набор примитивных функций, из которых можно строить различные формулы
(например, степенная функция, $+$, $\sin$, $\tan$). Начальный набор формул
строится либо произвольным образом, либо на базе некоторых предположений
эксперта. Затем на каждом шаге производится оценка каждой из формул согласно
функции ошибки либо другого функционала качества~\cite{Tirsin2005}. На базе
этой оценки у некоторой части формул случайным образом заменяется одна
элементарная функция на другую (например, $\sin$ на $\cos$ или $+$ на
$\times$), а у некоторой другой части происходит взаимный попарный обмен
подвыражениями.

Получаемая формула является математической моделью исследуемого
процесса или явления, т.\,е.\ представляет собой математическое
отношение, описывающее основные закономерности, присущие этому
явлению~\cite{Pavlovsky2000}.

Алгоритм индуктивного порождения моделей, предложенный в~настоящей работе,
свободен от некоторых типичных проблем известных методов, упомянутых,
например, в~\cite{Zelinka2008}. Вот главные из них:
\begin{itemize}
  \item порождение рекурсивных суперпозиций, суперпозиций, содержащих
    несоответствующее используемым функциям число аргументов, и~т.\,д.
    (в~предложенном алгоритме эти проб\-ле\-мы не возникают по построению);
  \item несовпадение области определения некоторой примитивной функции и области
    значений ее аргументов (возможно, тоже некоторых суперпозиций);
  \item порождение слишком сложных суперпозиций.
\end{itemize}

Для любой выборки можно построить такой многочлен, который пройдет через
все точки выборки, но при этом число параметров такого многочлена линейно
растет с объемом выборки. Кроме того, такой многочлен неинтерпретируем
экспертами. Предложенный в настоящей работе алгоритм решает проблему
порождения слишком сложных суперпозиций введением дополнительного штрафа
за сложность. Кроме того, так как ис\-поль\-зу\-емые признаки объектов выборки
учитываются при расчете сложности, применение подобного штрафа обеспечивает
выбор суперпозиций, использующих меньшее число признаков, т.\,е.\ проводит
отбор признаков.

Во~второй части работы формально поставлена задача построения алгоритма
индуктивного по\-рож\-де\-ния моделей. Затем, в~третьей час\-ти, строится искомый
алгоритм для частного случая беспараметрических моделей и~доказывается его
корректность, а затем алгоритм обобщается на случай моделей, имеющих параметры.
В~четвертой час\-ти оценивается количество порожденных предложенным алгоритмом
моделей на каждой итерации. В~пятой час\-ти предлагается метод выбора
допустимых моделей из множества всех порожденных моделей. В~седьмой час\-ти
описывается адаптированный стохастический алгоритм порождения моделей,
результаты работы которого на синтетических данных приведены в~восьмой
части настоящей работы.

\section{Постановка задачи}

Пусть дана выборка
\begin{multline*}
D = \left\{ (\mathbf{x}_i, y_i) \mid i \in \{1, \dots, N\},\right.\\
           \left. \mathbf{x}_i \in \mathbb{X} \subset \mathbb{R}^n,
            y_i \in \mathbb{Y} \subset \mathbb{R} \right\},
\end{multline*}
где $N$~--- число элементов выборки, $\mathbf{x}_i$~--- вектор значений
свободных переменных для $i$-го элемента выборки, $y_i$~--- значение зависимой
переменной для $i$-го элемента выборки,
$\mathbb{X}$~--- множество значений независимых переменных, лежащее в
$\mathbb{R}^n$, $\mathbb{Y}$~--- множество значений зависимой переменной.

Требуется выбрать параметрическую функцию
$f : \Omega \times \mathbb{X} \rightarrow \mathbb{R}$ из
порождаемого множества $\mathcal{F} \hm= \{ f_r \}$, где $\Omega$~--- пространство
параметров, до\-став\-ля\-ющую минимум некоторому заданному функционалу качества~$Q$,
зависящему от функционала ошибки~$S$ на данной выборке~$D$ и сложности суперпозиции~$C(f)$.

Таким образом, для множества всех суперпозиций
$$
\mathcal{F} = \{ f_r \mid
            f_r : (\boldsymbol{\omega}, \mathbf{x}) \mapsto y \in \mathbb{Y},
            r \in \mathbb{N} \}
$$
требуется найти такой индекс $\hat{r}$, при котором функция $f_r$ среди всех
$f \hm\in \mathcal{F}$ доставляет минимум функционалу качества~$Q$ при данной
выборке~$D$:
\begin{equation*}
  \label{eq:hat_r}
  \hat{r} = \arg \min\limits_{r \in \mathbb{N}} Q (f_r \mid \boldsymbol{\hat{\omega}_r}, D)\,,
\end{equation*}
где $\boldsymbol{\hat{\omega}}_r$~--- оптимальный вектор параметров функции
$f_r$ для каждой $f \hm\in \mathcal{F}$ при данной выборке~$D$:
\begin{equation*}
%  \label{eq:hat_omega}
  \boldsymbol{\hat{\omega}_r} = 
  \arg \min\limits_{\boldsymbol{\omega} \in \Omega} S(\boldsymbol{\omega} \mid f_r, D)\,.
\end{equation*}

Сформулируем также постановку теоретической задачи. Для этого сначала
введем понятие суперпозиции функций.

Если множество значений $\mathbb{Y}_i$ функции $f_i$ содержится в области
определения $\mathbb{X}_{i+1}$ функции $f_{i+1}$, т.\,е.\
$$
f_i : \mathbb{X}_i \to \mathbb{Y}_i \subset \mathbb{X}_{i+1}\,,\enskip i = 1, 2, \dots, \theta - 1\,,
$$
то функция
$$
f_\theta \circ f_{\theta-1} \circ \dots \circ f_1\,, \enskip \theta \geq 2\,,
$$
определяемая равенством
$$
(f_\theta \circ f_{\theta-1} \circ \dots \circ f_1) (\mathbf{x}) =
  f_{\theta} (f_{\theta-1} (\cdots (f_1 (\mathbf{x}))))\,, 
  \ x \in \mathbb{X}_1,
$$
называется \textit{сложной функцией}~\cite{MathEnc1984_4} или
\textit{суперпозицией функций} $f_1, f_2, \dots, f_\theta$.

Таким образом, получаем

\smallskip

\noindent
\textbf{Определение~1.}
\textit{Суперпозиция функций~--- функция, представленная как композиция нескольких
  функций.}
  
  \smallskip


Пусть $G = \{ g_1, \dots, g_l \}$~--- множество данных порождающих
функций, а именно: для каждой $g_i \hm\in G$ заданы
\begin{itemize}
  \item сама функция $g_i$ (например, $\sin$, $\cos$, $\times$);
  \item арность функции и~порядок следования аргументов;
  \item домен ($\text{dom}\, g_i$) и кодомен ($\text{cod}\, g_i$) функции;
  \item область определения $\mathcal{D} g_i \subset \text{dom}\, g_i$ и~область
    значений $\mathcal{E} g_i \subset \text{cod}\, g_i$.
\end{itemize}
Требуется построить упомянутую функцию~$f$ как суперпозицию порождающих
функций из заданного множества~$G$.

Поясним различие между последними двумя пунктами. Например, $\text{dom}\, f$
показывает, значения из какого множества принимает функция~$f$ (целые чис\-ла,
действительные чис\-ла, декартово произведение целых чи\-сел и $\{0, 1\}$,
и~т.\,п.). Область определения же показывает, на каких значениях из
$\text{dom}\, f$ функция $f$ определена и имеет смысл. Так, для функции
$f(x_1, x_2) \hm= \log_{x_1} x_2$:
\begin{gather*}
  \text{dom}\, f = \mathbb{R} \times \mathbb{R}\,,\quad 
  \text{cod}\, f = \mathbb{R}\,;
\\
  \mathcal{D} f = \left\{ (x_1, x_2) \vert x_1 \in (0; 1) \cup (1; +\infty), x_2 \in (0; +\infty) \right\};
\\
  \mathcal{E} f = (-\infty; +\infty)\,.
\end{gather*}

Требуется также:
\begin{itemize}
  \item построить алгоритм $\mathfrak{A}$, за конечное число итераций
    порождающий любую конечную суперпозицию данных примитивных функций;
  \item указать способ проверки изоморфности двух суперпозиций.
\end{itemize}

Заметим, что для примитивных функций  не требуются свойства их непорождаемости
в наиболее общей формулировке типа принципиальной невозможности породить
в ходе работы искомого алгоритма суперпозицию, изоморфную некоторой функции из~$G$. 
Такое требование является слишком ограничивающим. В~частности, невозможно
было бы иметь в~$G$ одновременно, например, функции $\text{id}$, $\exp$
и~$\log$, так как $\text{id}\,\equiv \log \circ \exp$.

В~дальнейшем будем также считать, что суперпозиция, соответствующая
единственной свободной переменной ($f(\mathbf{x}) \hm= x_i$), эквивалентна
функции вида $\text{id}\,x_i$.

\section{Алгоритм индуктивного порождения допустимых суперпозиций}

Условимся считать, что каждой суперпозиции~$f$ сопоставлено дерево~$\Gamma_f$,
эквивалентное этой суперпозиции и строящееся следующим образом:
\begin{itemize}
  \item в~вершинах $V_i$ дерева~$\Gamma_f$ находятся соответствующие
    порождающие функции $g_s, s \hm= s(i)$;
  \item число дочерних вершин у некоторой вершины~$V_i$ равно арности
    соответствующей функции~$g_s$;
  \item порядок смежных некоторой вершине~$V_i$ вершин соответствует порядку
    аргументов соответствующей функции~$g_{s(i)}$;
  \item в~листьях дерева~$\Gamma_f$ находятся свободные переменные~$x_i$
    либо числовые па\-ра\-мет\-ры~$\omega_i$;
  \item порядок вершин~$V_i$ в~смысле уровня вершин определяет порядок
    вычисления примитивных функций: дерево вычисляется снизу вверх,
    т.\,е.\ сначала подставляются конкретные значения свободных переменных,
    затем вычисляются значения в~вершинах, все дочерние вершины которых~---
    свободные переменные, и так далее до тех пор, пока не останется
    единственная вершина, бывшая корнем дерева. Она и содержит результат
    соответствующего выражения.
\end{itemize}

Таким образом, вычисление значения вы\-ра\-жения~$f$ в некоторой точке с данным
вектором\linebreak параметров $\boldsymbol{\omega} \hm= \{ \omega_1, \omega_2, \dots, \omega_\eta\}$
эквивалентно подстановке соответствующих значений свободных перемен\-ных~$x_i$
и параметров $\omega_i$ в дерево~$\Gamma_f$, где $x_i$ --- компоненты
вектора признакового описания объекта~$\mathbf{x}$.

Заметим важное свойство таких деревьев: каж\-дое поддерево $\Gamma_f^i$
дерева $\Gamma_f$, соответствующее вершине~$V_i$, также соответствует
некоторой суперпози-\linebreak\vspace*{-12pt}
\begin{center}  %fig1
\vspace*{1pt}
\mbox{%
 \epsfxsize=48.539mm
 \epsfbox{rud-1.eps}
 }
% \end{center}

 \vspace*{6pt}
{{\figurename~1}\ \ \small{Дерево выражения $\sin (\ln x_1) + {x_2^3}/{2}$}}
\end{center}


%\pagebreak

\vspace*{12pt}

\addtocounter{figure}{1}

\noindent
ции, являющейся составляющей исходной суперпозиции~$f$.

Для примера рассмотрим дерево, со\-от\-вет\-ст\-ву\-ющее суперпозиции $f \hm= \sin (\ln x_1) + 
{x_2^3}/{2}$ (рис.~1).
Здесь точками обозначены аргументы функций. Как видно, корнем дерева является
вершина, соответствующая операции сложения, которая должна быть выполнена
в последнюю очередь. Операция сложения имеет два различных поддерева,
соответствующих двум аргументам этой операции. Заметим также, что здесь не
использованы операции типа <<разделить на два>> или <<возвести в~куб>>.
Вместо этого используются операции деления и возведения в степень в~общем
виде, а в данном конкретном дереве соответствующие аргументы зафиксированы
соответствующими константами.

\smallskip


\noindent
\textbf{Алгоритм порождения суперпозиций.} Сначала определим понятие
\textit{глубины суперпозиции}:

\smallskip

\noindent
\textbf{Определение~2.}
\textit{Глубина суперпозиции $f$~--- максимальная глубина дерева $\Gamma_f$.}

\smallskip

Теперь опишем итеративный алгоритм $\mathfrak{A^*}$, порождающий суперпозиции,
не содержащие параметров. Описанный алгоритм породит любую суперпозицию
конечной глубины за конечное число шагов.

Пусть дано множество примитивных функций $G \hm= \{ g_1, \dots, g_l \}$ и
множество свободных переменных $X \hm= \{ x_1, \dots, x_n \}$. Для удобства будем
исходить из предположения, что множество $G$ состоит только из унарных
и~бинарных функций, и~разделим его соответствующим образом на два подмножества:
$G \hm= G_b \cup G_u \mid G_b \hm= \{ g_{b_1}, \dots, g_{b_k} \}$, 
$G_u \hm= \{ g_{u_1}, \dots, g_{u_l} \}$,
где $G_b$~--- множество всех бинарных функций, а $G_u$~--- множество всех
унарных функций из~$G$. Потребуем также наличия $\text{id}$ в~$G_b$.

\smallskip

\noindent
\textbf{Алгоритм~1.}
  Алгоритм $\mathfrak{A^*}$ итеративного порождения суперпозиций.
\begin{enumerate}[1.]
  \item Перед первым шагом зададим начальные значения множества
    $\mathcal{F}_0$ и вспомогательного индексного множества~$\mathcal{I}$,
    служащего для запоминания, на какой итерации впервые встречена
    каждая суперпозиция:
    \begin{equation*}
      \mathcal{F}_0 = X\,;\quad
      \mathcal{I} = \left\{ (x, 0) \mid x \in X \right\}\,.
\end{equation*}
  \item Для множества $\mathcal{F}_i$ построим вспомогательное множество~$U_i$,
    состоящее из суперпозиций, полученных в результате применения функций
    $g_u \hm\in G_u$ к элементам~$\mathcal{F}_i$:
    $$
      U_i = \left\{ g_u \circ f \mid g_u \in G_u, f \in \mathcal{F}_i \right\}\,.
$$
  \item Аналогичным образом построим вспомогательное множество~$B_i$ для
    бинарных функций $g_b \hm\in G_b$:
    $$
      B_i = \left\{ g_b \circ (f, h) \mid g_b \in G_b, f, h \in \mathcal{F}_i \right\}\,.
$$
  \item Обозначим $\mathcal{F}_{i+1} = \mathcal{F}_i \cup U_i \cup B_i$.
  \item Для каждой суперпозиции~$f$ из~$\mathcal{F}_{i+1}$ добавим пару
    $(f, i+1)$ в~множество $\mathcal{I}_f$, если суперпозиция~$f$ еще там
    не присутствует.
  \item Перейдем к~следующей итерации, п.~2.
\end{enumerate}

Тогда $\mathcal{F} \hm= \cup_{i=0}^\infty \mathcal{F}_i$~--- множество всех
возможных суперпозиций конечной длины, которые можно построить из
данного множества примитивных функций.

Вспомогательное множество~$\mathcal{I}$ позволяет запоминать, на какой
итерации была впервые встречена каждая суперпозиция. Это необходимо, так
как каждая суперпозиция, впервые порожденная на $i$-й итерации, будет
порождена так\-же и на любой итерации после~$i$. Одной из возможностей
избежать необходимости в этом множестве является построение
$\mathcal{F}_{i+1}$ как $\mathcal{F}_{i+1} \hm= U_i \cup B_i$ (без
$\mathcal{F}_i$), а множества~$U_i$ и~$B_i$ строить следующим образом:
\begin{align*}
  U_i &= \left\{ g_u \circ f \mid g_u \in G_u, f \in \cup_{j=0}^{i} \mathcal{F}_j \right\}\,;
\\
  B_i &= \left\{ g_b \circ (f, h) \mid g_b \in G_b, f, h \in \cup_{j=0}^{i} \mathcal{F}_j \right\}\,.
\end{align*}

Алгоритм $\mathfrak{A^*}$ очевидным образом обобщается на случай, когда
множество~$G$ содержит функции произвольной (но конечной) арности.
Действительно, для такого обобщения достаточно строить аналогичным образом
вспомогательные множества для этих функций, а именно: для множества функций~$G_n$ 
арности~$n$ построить вспомогательное множество $H_i^n$ вида
$$
H_i^n = \left\{ g \circ (f_1, f_2, \dots, f_n) \mid g \in G_n, f_j \in \mathcal{F}_i \right\}\,.
$$

В~этих обозначениях $U_i \hm\equiv H_i^1$, а $B_i \hm\equiv H_i^2$.

Тогда множество $\mathcal{F}_{i+1} \hm= \mathcal{F}_i \cup_{n=0}^{n_{\max}} H_i^n$,
где $n_{\max}$~--- максимальное значение арности функций из~$G$.

\smallskip

\noindent
\textbf{Теорема~1.}
\textit{Алгоритм $\mathfrak{A^*}$ действительно породит любую конечную суперпозицию
  за конечное число шагов.}

\smallskip

\noindent
Д\,\,о\,к\,а\,з\,а\,т\,е\,л\,ь\,с\,т\,в\,о\,.\ \ 
  Чтобы убедиться в~этом, \mbox{найдем} номер итерации, на которой будет по\-рож\-де\-на
  некоторая произвольная конечная суперпозиция~$f$. Чтобы найти этот номер,
  пронумеруем вершины графа~$\Gamma_f$ по следующим правилам:
  \begin{itemize}
    \item если это вершина со свободной переменной, то она имеет номер~0;
    \item если вершина $V$ соответствует унарной функции, то она имеет номер
      $i+1$, где $i$~--- номер дочерней для этой функции вершины;
    \item если вершина $V$ соответствует бинарной функции, то она имеет номер
      $i+1$, где $i = \max (l, r)$, а $l$ и $r$~--- номера соответственно
      первой и второй дочерней вершины.
  \end{itemize}

  Нумеруя вершины графа $\Gamma_f$ таким образом, можно получить номер вершины,
  соответ\-ст\-ву\-ющей корню графа. Это и будет номером итерации, на которой получена
  суперпозиция~$f$.

  Иными словами, для любой суперпозиции можно указать конкретный номер
  итерации, на которой она будет получена, что и~требовалось.


\smallskip

В~предложенных ранее методах построения суперпозиций~\cite{Zelinka2008}
необходимо было самостоятельно следить за тем, чтобы в~ходе работы алгоритма
не возникало <<зацикленных>> суперпозиций типа $f(x, y) \hm= g (f(x, y), x, y)$.
Заметим, что в предложенном алгоритме $\mathfrak{A^*}$ такие суперпозиции
не могут возникнуть по построению.

\smallskip

\noindent
\textbf{Порождение моделей с параметрами.}
Алгоритм $\mathfrak{A^*}$, описанный выше, не позволяет получать выражения, содержащие численные
параметры $\boldsymbol{\omega}$ суперпозиции $f(\boldsymbol{\omega}, \mathbf{x})$.
Покажем, однако, на примере конструирования множеств $U_i$ и~$B_i$, как
исходный алгоритм $\mathfrak{A^*}$ может быть расширен путем введения параметров
\begin{align*}
U_i &= g_u \circ (\alpha f + \beta) \,;
\\
B_i &=  g_b \circ (\alpha f + \beta, \psi h + \phi) \,.
\end{align*}
Будем обозначать этот расширенный алгоритм как~$\mathfrak{A}$. Здесь
параметры $\alpha$, $\beta$ зависят только от комбинации $g_u, f$ (или
$g_b, f, h$ для $\alpha$, $\beta$, $\psi$, $\phi$). Соответственно, для
упрощения их индексы опущены. Иными словами, предполагается, что
каждая суперпозиция, полученная на предыдущих итерациях, входит
в порождаемую на следующей итерации, будучи умноженной на некоторый
коэффициент и с константной поправкой.

Очевидно, при таком добавлении параметров $\alpha$, $\beta$, $\psi$,
$\phi$ не происходит изменения мощности получившегося множества
суперпозиций, поэтому алгоритм и~выводы из него остаются
корректными. В~частности, исходный алгоритм является частным случаем
данного при $\alpha \hm\equiv \psi \hm\equiv 1$, $\beta \hm\equiv \phi \hm\equiv 0$.

Переменные $\alpha, \beta, \psi, \phi$ являются параметрами модели. 
В~практических приложениях можно оптимизировать значения этих параметров у
получившихся суперпозиций, например, алгоритмом 
Ле\-вен\-бер\-га--Марк\-вард\-та~\cite{Marquardt1963Algorithm, more:78}.

Заметим также, что такая модификация алгоритма позволяет получить единицу,
например, для построения суперпозиций типа ${1}/{x}$:
$1 \hm= \alpha\ id\ x + \beta \mid \alpha = 0, \beta \hm= 1$.

Отдельно подчеркнем, что параметры $\boldsymbol{\omega}$ у разных
суперпозиций различны. Однако, так как каж\-дый из па\-ра\-мет\-ров зависит только
от со\-от\-вет\-ст\-ву\-ющей комбинации функций, к которым он относит\-ся, конкретные
значения параметров не учитываются при поиске одинаковых суперпозиций.
Иными словами, при тестировании суперпозиций на равенство сравниваются лишь
структуры соответствующих им деревьев и значения в узлах, соответствующих
функциям и свободным переменным.

Заметим, что и~этот алгоритм очевидным образом обобщается на случай
множества~$G$, содержащего функции произвольной арности.

\section{Число возможных суперпозиций}

Оценим число суперпозиций, получаемых после каждой итерации
алгоритма~$\mathfrak{A}$. Очевидно, с учетом вышеупомянутых оговорок
касательно сравнения параметризованных суперпозиций, это число равно
аналогичному числу для алгоритма~$\mathfrak{A^*}$.

Итак, пусть дано $n$ независимых переменных: $| X | \hm= n$, а мощность
множества~$G$ распишем через мощности его подмножеств функций соответствующей
арности: $| G_1 | \hm= l_1$, $| G_2 | \hm= l_2, \dots$, $| G_p | \hm= l_p$. На нулевой
итерации имеем $P_0 \hm= n$ суперпозиций.

На первой итерации дополнительно порож\-да\-ется

\noindent
$$
P_1 = l_1 n + l_2 n^2 + \dots + l_n n^p = \sum\limits_{i=1}^p l_i P_0^i\,,
$$
и суммарное число суперпозиций после первой итерации
$$
\hat{P}_1 = P_1 + P_0 = \sum\limits_{i=1}^p l_i P_0^i + P_0\,.
$$

Как было замечено ранее, суперпозиции, по\-рож\-ден\-ные на $k$-й итерации, будут
также порождены и на любой следующей после $k$ итерации, поэтому суммарное
число суперпозиций после второй итерации будет равно
$$
\hat{P}_2 = \sum\limits_{i=1}^p l_i \hat{P}_1^i\,.
$$

И вообще, после $k$-й итерации будет порождено
$$
\hat{P}_k = \sum\limits_{i=1}^p l_i \hat{P}_{k-1}^i\,.
$$

Оценим порядок роста количества функций, порожденных после $k$-й итерации.

\smallskip

\noindent
\textbf{Теорема~2.}
\textit{Пусть в множестве примитивных функций $G$ содержится $l_p$ функций арности
  $p \hm> 1$ и ни одной функции арности $p \hm+ k \mid k \hm> 0$ и имеется $n \hm> 1$
  независимых переменных. Тогда справедлива следующая оценка чис\-ла
  суперпозиций, порожденных алгоритмом $\mathfrak{A}$ после $k$-й итерации:}
  $$
  \left\vert \mathcal{F}_k \right\vert = \mathcal{O} 
  \left(l_p^{\sum_{i=0}^{k-1} p^i} n^{p^k}\right)\,.
  $$


\smallskip

\noindent
Д\,\,о\,к\,а\,з\,а\,т\,е\,л\,ь\,с\,т\,в\,о\,.\ \ 
  Оценим сначала порядок рос\-та для случая, когда есть лишь одна $m$-ар\-ная
  функция и $n$ свободных переменных.

  После первой итерации алгоритма будет по\-рож\-де\-но $n^m \hm+ n$ суперпозиций.
  После второй~--- $(n^m + n)^m \hm+ n^m + n$, что можно оценить как\linebreak
  $(n^m)^m \hm= n^{m^2}$. И~вообще, после $k$-й итерации чис\-ло
  суперпозиций можно оценить как $n^{m^k}$.

  Видно, что для оценки скорости роста количества порожденных суперпозиций
  можно учитывать только функции с наибольшей арностью.

  Рассмотрим теперь случай, когда имеется не одна функция арности~$m$, а
  $l_m$ таких функций. Тогда на первой итерации порождается $l_m n^m \hm+ n$
  суперпозиций, на второй:
  $$
  l_m (l_m n^m + n)^m + l_m n^m + n \approx l_m^{m+1} n^{m^2}\,,
$$
  на третьей, с учетом этого приближения:
  $$
  l_m (l_m^{m+1} n^{m^2})^m = l_m l_m^{m(m+1)} n^{m^3} = l_m^{m^2 + m + 1} n^{m^3}\,.
$$
  И~вообще, скорость роста количества порожденных суперпозиций можно оценить
  как:
  $$
  \left\vert \mathcal{F}_k \right\vert = \mathcal{O} 
  \left(l_m^{\sum_{i=0}^{k-1} m^i} n^{m^k}\right)\,.
  $$
  Таким образом, получаем оценку в общем случае, когда в множестве $G$ содержится
  $l_p$ функций ар\-ности~$p$ и ни одной функции ар\-ности $p \hm+ k \mid k\hm > 0$:
  $$
\left\vert \mathcal{F}_k \right\vert = \mathcal{O} 
\left(l_p^{\sum_{i=0}^{k-1} p^i} n^{p^k}\right)\,.
  $$


%\smallskip

\section{Множество допустимых суперпозиций}

Предложенный выше алгоритм позволяет получить действительно все возможные
суперпозиции, однако не все они будут пригодны в~практических приложениях:
например, $\ln x$ имеет смысл только при $x \hm> 0$, а ${x}/{0}$ не имеет
смысла вообще никогда. Выражения типа ${x}/{\sin x}$ имеют смысл только
при $x \hm\neq \pi k$.

Таким образом, необходимо введение понятия множества \textit{допустимых}
суперпозиций, т.\,е.\ таких суперпозиций, которые в условиях данной
задачи корректны.

\smallskip

\noindent
\textbf{Определение~3.}
\textit{Допустимая суперпозиция $f$~--- такая суперпозиция, значение которой
  определено для любой комбинации значений свободных переменных, область
  значений $\mathbb{X}$ которых определяется конкретной задачей,
  $\mathbb{X} \subset \mathbb{R}^n$, где $n$~--- число свободных переменных.}


\smallskip

Одним из способов построения только допустимых суперпозиций является
модификация предложенного алгоритма таким образом, чтобы отслеживать
совместность областей определения и \mbox{областей} значений соответствующих
функций в ходе построения суперпозиций. Для свободных переменных это,
в свою очередь, означает необходимость задания областей значений
$\mathbb{X}$ пользователем при решении конкретных задач.

Таким образом, можно сформулировать очевидное \textit{достаточное условие
недопустимости} суперпозиции:

\smallskip

\noindent
\textbf{Определение~4.}
  Достаточное условие недопустимости суперпозиции~$f$: в соответствующем дереве
  $\Gamma_f$ хотя бы одна вершина~$V_i$ имеет хотя бы одну дочернюю вершину~$V_j$ 
  такую, что область значений функции $g_{s(j)}$ шире, чем область
  определения функции $g_{s(i)}$:
  $$
  \exists i, j : V_i \in \Gamma_f, V_j \in \Gamma_f \wedge \exists \kappa :
    \kappa \in \mathcal{E} g_{s(j)} \wedge \kappa \notin \mathcal{D} g_{s(i)}\,.
$$


\smallskip

Говоря, что область значений функции~$f$ шире области определения функции~$g$, 
имеем в~виду, что существует, по крайней мере, одно значение функции~$f$, 
не входящее в область определения функции~$g$.

Подчеркнем, что, хотя свободные переменные могут принимать, например, все
значения из~$\mathbb{R}$, выбором множества~$\mathbb{X}$ можно обеспечить
возможность использования их в качестве аргументов функций с более узкой,
чем $\mathbb{R}$, но не менее узкой, чем $\mathbb{X}$, областью определения,
если это не противоречит данной выборке.

Для построения множества допустимых суперпозиций достаточно построить
множество всех возможных суперпозиций при помощи алгоритма~$\mathfrak{A}$,
а затем удалить из этого множества все суперпозиции, не удовлетворяющие
сформулированному признаку.

\section{Алгоритм итеративного стохастического порождения суперпозиций}

Несмотря на то что построенный ранее итеративный алгоритм~$\mathfrak{A}$ по\-рож\-де\-ния
суперпозиций позволяет получить за конечное число шагов произвольную
суперпозицию, для практических применений он непригоден в~связи с чрезмерной
вычислительной сложностью, как и~любой алгоритм, реализующий полный перебор.
Вместо него предлагается использовать стохастические алгоритмы и~ряд эвристик,
позволяющих на практике получать за приемлемое время результаты,
удовлетворяющие заранее заданным условиям. В~данном разделе описывается
практически реализуемый вариант алгоритма~$\mathfrak{A}$, который и был использован
в~вычислительном эксперименте. Опишем вспомогательный алгоритм 
случайного порождения суперпозиции.

\smallskip

\noindent
\textbf{Алгоритм~2.} 
  Алгоритм случайного порождения суперпозиции $\mathcal{RF}$.

  Вход:
  \begin{itemize}
    \item набор пороговых значений $0 < \xi_1 < \xi_2 \hm< \xi_3 \hm< 1$;
    \item максимальная глубина порождаемой суперпозиции Td.
  \end{itemize}


\smallskip

Алгоритм работает следующим образом. Генерируется случайное чис\-ло~$\xi$ на
интервале $(0; 1)$ и рассматриваются следующие случаи:
\begin{itemize}
  \item $\xi \leq \xi_1$: результатом алгоритма является некоторая случайно
    выбранная свободная переменная;
  \item $\xi_1 < \xi \leq \xi_2$: результатом алгоритма является    числовой
    параметр;
  \item $\xi_2 < \xi \leq \xi_3$: результатом алгоритма является некоторая
    случайно выбранная унарная функция, для определения аргумента которой
    данный алгоритм рекурсивно запускается еще раз;
  \item $\xi_3 < \xi$: результатом алгоритма является некоторая случайно
    выбранная бинарная функция, аргументы которой порождаются аналогичным
    образом.
\end{itemize}
При этом порождение тривиальных суперпозиций (свободных переменных и
параметров) запрещено: на самом первом шаге пороговые значения масштабируются
таким образом, чтобы всегда порождалась унарная или бинарная функция.
Аналогично при превышении значения~Td пороговые значения масштабируются
таким образом, чтобы был порожден узел, соответствующий свободной переменной
или параметру, и алгоритм за\-вер\-шился.

Каждой порожденной суперпозиции~$f$ ставится в
соответствие ее \textit{качество}~$Q_f$, рассчитываемое исходя из функционала ошибки~$S_f$ 
этой суперпозиции на выборке~$D$ и ее сложности $C_f$~---
числа узлов в соответствующем графе~$\Gamma_f$. Функционал~$Q_f$ выбирается эвристически
с учетом следующих естественных соображений:
\begin{itemize}
  \item из двух суперпозиций одинаковой слож\-ности~$C_f$ выбирается обеспечивающая
    более оптимальное значение функционала ошибки~$S_f$;
  \item из двух суперпозиций, имеющих одно и то же значение функционала ошибки~$S_f$,
    выбирается суперпозиция, обладающая меньшей слож\-ностью~$C_f$.
\end{itemize}

\noindent
\textbf{Алгоритм~3.}
  Итеративный алгоритм стохастического порождения суперпозиций.

  Вход:
  \begin{itemize}
    \item множество порождающих функций~$G$, со\-сто\-ящее только из унарных
      и бинарных функций;
    \item регрессионная выборка~$D$;
    \item $N_{\max}$~--- максимальное число одновременно рассматриваемых
      суперпозиций;
    \item $I_{\max}$~--- максимальное число итераций алгоритма;
    \item $\hat{Q}$~--- минимальное значение функционала~$Q_f$:
    \begin{equation}
  \label{eq:q_f}
  Q_f = \fr{1}{1 + S_f} \left(\alpha + \fr{1 - \alpha}
  {1 + \exp \left({C_f}/{\beta} - \tau\right)}\right)\,,
\end{equation}
где $\alpha$~--- некоторый коэффициент влияния штрафа за сложность, $0 \hm\ll \alpha \hm< 1$,
$\beta$~--- коэффициент строгости штрафа за сложность, $\beta \hm> 0$, а
$\tau$~--- коэффициент, характеризующий желаемую сложность модели;
    \item $\gamma_{\mathrm{mut}}$~--- доля суперпозиций, подверженных случайной
      замене узлов их деревьев;
    \item $\gamma_{\mathrm{cross}}$~--- доля суперпозиций, для которых выполняется
      случайный обмен поддеревьями;
    \item прочие параметры, используемые в~\eqref{eq:q_f} и алгоритме~2.
  \end{itemize}


\noindent
\begin{enumerate}
  \item Инициализируется упорядоченный набор $\mathcal{X}_f$ суперпозиций,
    а~именно: порождается $N_{\max}$ суперпозиций алгоритмом~2.
  \item Оптимизируются параметры~$\boldsymbol{\omega}$ суперпозиций
    из~$\mathcal{X}_f$ алгоритмом Ле\-вен\-бер\-га--Марк\-вард\-та.
  \item Выполняются простейшие преобразования, упрощающие суперпозицию:
    например, выражения вида $0 \cdot x$ заменяются на~0.
  \item Вычисляется значение~$Q_f$ для каждой еще не оцененной суперпозиции~$f$ 
  из~$\mathcal{X}_f$: для нее рассчитывается значение функционала ошибки~$S_f$ 
  на выборке~$D$ и ставится в соответствие значение~$Q_f$. Для
    суперпозиций, при вычислении~$Q_f$ которых была хотя бы раз получена
    ошибка вычислений из-за несовпадения областей определений и значений,
    принимается $Q_f \hm= -\infty$.
  \item Набор суперпозиций~$\mathcal{X}_f$ сортируется согласно значениям
    функционала~$Q_f$.
  \item Суперпозиции с наименьшими значениями~$Q_f$ удаляются из массива~$\mathcal{X}_f$ 
  до тех пор, пока его размер не станет равен~$N_{\max}$.
  \item Отбирается некоторая часть~$\gamma_{\mathrm{mut}}$ суперпозиций с наименьшими
    значениями~$Q_f$ из~$\mathcal{X}_f$. У~этой час\-ти происходит случайная замена
    одной функции или свободной переменной на другую: генерируются две случайные величины,
    одна из которых служит для выбора вершины дерева~$\Gamma_f$, которую
    предстоит изменить, а другая~--- для выбора нового элемента для этой вершины.
    Замена такова, что сохраняется структура суперпозиции, т.\,е.\
    в случае замены функции сохраняется арность, а свободная переменная
    заменяется только на другую свободную переменную. Исходные
    суперпозиции сохраняются в массиве~$\mathcal{X}_f$.
  \item Повторяются шаги 4--5.
  
  \begin{figure*} %fig2
\vspace*{1pt}
 \begin{center}
 \mbox{%
 \epsfxsize=112.519mm
 \epsfbox{rud-2.eps}
 }
 \end{center}
 \vspace*{-9pt}
  \Caption{Поверхности функции $Q_f$ для некоторых $\beta$ (\textit{1}~--- $\beta\hm=0{,}1$; 
  \textit{2}~--- 1; \textit{3}~--- $\beta\hm=5$)
    и фиксированного $\tau = 5$}
  \label{fig:fitness_surph}
\end{figure*}

 
  
  
  \item Производится случайный обмен поддеревьями у $\gamma_{\mathrm{cross}}$ суперпозиций
    с наибольшими значениями $Q_f$. Вершины, соответствующие этим поддеревьям,
    выбираются случайным образом. При этом исходные суперпозиции сохраняются
    в~$\mathcal{X}_f$.
    

Таким образом, чем лучше результаты суперпозиции и чем она проще, тем ближе
значение функционала~$Q_f$ к~$1$.


  \item Повторяются шаги 2--5.
  \item Проверяются условия останова: если либо чис\-ло итераций превышает
    $I_{\max}$, либо в~массиве $\mathcal{X}_f$ находится суперпозиция со значением~$Q_f$, 
    большим $\hat{Q}$, то алгоритм останавливается
    и результатом считается суперпозиция с наибольшим значением~$Q_f$, иначе
    осуществляется переход к шагу~2.
\end{enumerate}

\section{Вычислительный эксперимент}

В~вычислительном эксперименте вос\-ста\-нав\-ли\-ва\-ет\-ся функциональная зависимость
$y \hm= 2 \cosh \sqrt{(x_1^2\hm + x_2^2)/2}$, соответствующая фигуре вращения
цепной линии. При этом значения зависимой
переменной~$y$ были искусственно зашумлены аддитивной добавкой из
распределения $\mathcal{N} (0, 0{,}1)$ и соответствующая ей переменная
присутствовала во множестве используемых свободных переменных.

В качестве функционала ошибки~$S$ используется сумма квадратов
регрессионных остатков для данной суперпозиции~$f$ с вектором параметров
$\boldsymbol{\omega}$ при регрессионной выборке~$D$:
\begin{equation}
  \label{eq:sse_expr}
  S(\boldsymbol{\omega}, f, D) = \sum\limits_{i=1}^N (y_i - f (\boldsymbol{\omega}, 
  \mathbf{x}_i))^2\,.
\end{equation}

Значение функционала ошибки~$S$ при подстановке исходной незашумленной
функциональной зависимости составляет $\approx 4{,}29$, сложность исходной
суперпозиции~--- 14.

\begin{table*}\small
\begin{center}
\Caption{Результаты вычислительного эксперимента для предложенного алгоритма}
  \label{tabl:results}
  \vspace*{2ex}

\begin{tabular}{| c | c | l | c | c | c |} 
  \hline
    $N$ & $i$   & \multicolumn{1}{c|}{Суперпозиция}  & $S_f$                & $C_f$ & $Q_f$             \\ 
    \hline
    &&&&&\\[-9pt]
    1   & 13    & $ 1{,}0002 \left(2{,}72^{\sqrt{x \cdot x + y \cdot y}/2} + 
    2{,}56^{\sqrt{x \cdot x + y \cdot y}/{-1{,}93}}\right)$ & 
    $\approx 4{,}10$     & 29    & $\approx 0{,}010$    \\ 
    \hline
    &&&&&\\[-9pt]
    2   & \hphantom{9}9     & $ 2{,}001 \cosh \fr{\sqrt{x \cdot x + y \cdot y}}{1{,}999}$& 
    $\approx 4{,}25$   & 14    & $\approx 0{,}188$   \\ 
    \hline
  \end{tabular}
  \end{center}
\end{table*}

\begin{table*}\small
\begin{center}
  \Caption{Результаты вычислительного эксперимента для алгоритма~\cite{Zelinka2008}}
  \label{tabl:results_Z}
  \vspace{2ex}
  
  \begin{tabular}{| c | c | c | c | c |} 
  \hline
    $i$ & Суперпозиция  & $S_f$                & $C_f$ & $Q_f$             \\ 
    \hline
    &&&&\\[-9pt]
    29  & $ 2{,}66^{\sqrt{x^2 + y^2}/{2{,}23}} - 
    \fr{x^2 + y^2}{3{,}03} + \fr{x^2 \cdot x^2 + y^2\cdot  y^2}{6{,}3} + 0{,}93$
             & $\approx 6{,}2$     & 43    & $ \approx 0{,}007 $ \\ 
             \hline
  \end{tabular}
  \end{center}
\end{table*}

\begin{figure*} %fig3
\vspace*{1pt}
 \begin{center}
 \mbox{%
 \epsfxsize=160.163mm
 \epsfbox{rud-3.eps}
 }
 \end{center}
 \vspace*{-9pt}
\Caption{Первая порожденная суперпозиция~(\textit{1})
и зашумленные точки выборки~(\textit{2})~(\textit{a}) 
и исходная зависимость~(\textit{3})~(\textit{б})}
\end{figure*}
\begin{figure*} %fig4
\vspace*{-3pt}
 \begin{center}
 \mbox{%
 \epsfxsize=160.163mm
 \epsfbox{rud-4.eps}
 }
 \end{center}
 \vspace*{-11pt}
  \Caption{Вторая порожденная суперпозиция~(\textit{1}) и зашумленные точки выборки~(\textit{2})~(\textit{a}) 
  и исходная зависимость~(\textit{3})~(\textit{б})}
\end{figure*}

В данной работе используется функционал~$Q_f$ вида~(\ref{eq:q_f}).
Значения параметров~$\alpha$, $\beta$ и~$\tau$
выбираются экспертно исходя из предположений
о виде искомой суперпозиции и моделируемом явлении.

Второй множитель в~\eqref{eq:q_f} выполняет роль штрафа за слишком
большую сложность суперпозиции, что позволяет выбирать более простые модели,
избегая эффекта переобучения и экстремальных случаев вроде порождения
интерполяционных полиномов. На рис.~\ref{fig:fitness_surph}
приведены поверхности~$Q_f$ для различных значений~$\beta$ при фиксированном
$\tau \hm= 5$.



Использованные параметры алгоритма~3: $N_{\max} \hm= 200, I_{\max} \hm= 50,
\hat{Q} \hm= 0{,}95, \tau \hm= 20, \alpha \hm= 0{,}05$, $\beta \hm= 1$, 
$\gamma_{\mathrm{mut}} \hm= {1}/{3}$,
$\gamma_{\mathrm{cross}} \hm= {1}/{3}$. При отсутствии улучшения результатов в~течение
нескольких итераций подряд алгоритм~3 также завершался.

Результаты вычислительного эксперимента приведены в табл.~\ref{tabl:results}.
Указан номер итерации~$i$, на которой суперпозиция была впервые
получена, сама суперпозиция, среднеквадратичная ошибка~\eqref{eq:sse_expr} и сложность в
смысле числа узлов в соответствующем графе выражения. Числовые коэффициенты
в приведенных формулах и значения функционала~$S_f$ искусственно округлены до
нескольких значащих цифр.

Алгоритм запускался для двух разных наборов элементарных функций.
В обоих случаях элементарные функции включали 
в себя стандартные арифметические операции и операцию возведения в степень. 
Для удобства возведение в степень~${1}/{2}$ (и близкие ей) заменено в таблице 
на операцию извлечения корня.


В первом случае в наборе отсутствовала функция~$\cosh$. При этом по результатам
10 запусков наилучшей суперпозицией, полученной предложенным алгоритмом,
оказалась функция за номером~1 из табл.~\ref{tabl:results}. Видно, что выражение
в скобках близко определению $\cosh x = ({e^x + e^{-x}})/2$,
однако разные значения оснований степенных функций могут затруднить экспертный
анализ полученного выражения, которое само по себе является достаточно громоздким.

Во втором случае набор элементарных функций также включал в себя функцию~$\cosh$, 
результату этого выражения соответствует суперпозиция за номером~2.
Включение $\cosh$ в~$G$ позволило существенно быстрее подобрать искомую функцию, и сложность
получившейся суперпозиции также существенно меньше.

Кроме того, предложенный алгоритм сравнивался с алгоритмом~\cite{Zelinka2008},
в котором суперпозиции кодировались бинарной строкой и применялись стандартные
генетические алгоритмы на получавшихся строках; во множестве используемых
функций также отсутствовала функция~$\cosh$.



Наилучшая суперпозиция, полученная алгоритмом~\cite{Zelinka2008} по результатам
10~запусков, приведена в табл.~\ref{tabl:results_Z}. Полученная суперпозиция
имеет существенно более высокую сложность, чем суперпозиции, перечисленные в
табл.~\ref{tabl:results}.

На рис.~3 отображены изометрические
проекции первой из приведенных в табл.~\ref{tabl:results} суперпозиций. На
рис.~3\textit{а} данная суперпозиция сравнивается с точками синтезированной
зашумленной выборки, на рис.~3\textit{б}  она же приведена вместе
с исходной незашумленной зависимостью. Аналогичные проекции
приведены для второй суперпозиции на рис.~4.

\vspace*{-6pt}

\section{Заключение}

В~работе исследованы индуктивные алгоритмы порождения допустимых существенно
нелинейных суперпозиций. Предложен переборный алгоритм, порождающий все
возможные суперпозиции заданной сложности за конечное число шагов.
Сформулированный алгоритм решает некоторые типичные проблемы предложенных ранее методов.
Описан стохастический алгоритм индуктивного порождения существенно нелинейных
суперпозиций и приведены результаты вычислительного эксперимента на синтетических
данных. Описанный алгоритм выбирает менее точные, но более простые
модели, что позволяет избежать переобучения и выполнить простейший отбор признаков.

\vspace*{-6pt}

{\small\frenchspacing
{%\baselineskip=10.8pt
\addcontentsline{toc}{section}{Литература}
\begin{thebibliography}{99}

\bibitem{duffy:1999:srised} 
\Au{Duffy~J., Engle-Warnick~J.} Using symbolic regression to infer strategies 
from experimental data~// Evolutionary\linebreak\vspace*{-12pt}\columnbreak

\noindent
 Computation in Economics and Finance, 2002. 
Vol.~100.  P.~61--84.

\bibitem{Barmpalexis201175} %2
\Au{Barmpalexis~P., Kachrimanis~K., Tsakonas~A., Georgarakis~E.} 
Symbolic regression via genetic programming in the optimization of 
a controlled release pharmaceutical formulation~// Chemometrics and 
Intelligent Laboratory Systems, 2011. Vol.~107. No.~1. P.~75--82.

\bibitem {davidson:2000:snrea} %3 
\Au{Davidson J.\,W., Savic D.\,A., Walters G.\,A.} Symbolic and numerical 
regression: Experiments and applications~// Developments in Soft Computing, 2001. 
Vol.~6. P.~175--182.

\bibitem {strijov07poisk} %4
\Au{Стрижов В.\,В.} 
Поиск параметрической регрессионной модели в индуктивно заданном множестве~// 
Вычислительные технологии, 2007. T.~1. C.~93--102.

\bibitem {Strijov08InductMethods}  %5
\Au{Стрижов В.\,В.} Методы индуктивного порождения регрессионных моделей.~--- М.:~ВЦ~РАН, 2008.


\bibitem {reference/ml/X10vc} %6
\Au{Sammut C., Webb  G.\,I.} Symbolic regression~// Encyclopedia of Machine Learning.~---  
Berlin: Springer, 2010.


\bibitem {StrijovW10}  %7
\Au{Strijov V.\,V., Weber G.\,W.} Nonlinear regression model generation using 
hyperparameter optimization~// Computers and Mathematics with Applications, 2010. Vol.~60. No.\,4. P.~981--988.

\bibitem {Koza1998GP} 
\Au{Koza J.\,R.} 
Genetic programming~// Encyclopedia of Computer Science and Technology, 1998. Vol.~39. No.\,24. P~29--43.

\bibitem {Koza1998Intro} 
\Au{Koza J.\,R.} Introduction to genetic algorithms.~--- Cambridge: MIT Press, 1998.

\bibitem {Zelinka2008} 
\Au{Zelinka I., Oplatkova Z., Nolle L.} Analytic programming and symbolic 
regression by means of arbitrary evolutionary algorithms~// Int.\ 
J.~Simulation Syst. Sci. Technol., 2005. Vol.~6. No.\,9. P~44--56.

\bibitem {Tirsin2005} 
\Au{Тырсин А.\,Н.} 
Об эквивалентности знакового и наименьших модулей методов построения линейных моделей~// 
Обозрение прикладной и промышленной математики, 2005. Т.~12. №\,4. C.~879--880.

\bibitem {Pavlovsky2000} \Au{Павловский Ю.\,Н.} Имитационные 
модели и системы.~--- М.:~Фазис, 2000.

\bibitem {MathEnc1984_4} \Au{Битюцков В.\,И., Войцеховский М.\,И., Иванов А.\,Б.} 
Математическая энциклопедия. Т.~4.~--- М.:~Советская энциклопедия, 1984.

\bibitem {Marquardt1963Algorithm} 
\Au{Marquardt D.\,W.} An algorithm for least squares estimation of nonlinear parameters~// 
J.~Soc. Ind. Appl. Math., 1963. Vol.~11. No.\,2. P.~431--441.

\label{end\stat}


\bibitem {more:78} \Au{More J.\,J.} 
The Levenberg--Marquardt algorithm: Implementation and theory~// 
Lecture Notes in Mathematics 630: Numerical Analysis.~--- Berlin: Springer-Verlag,
1978. P.~105--116.
\end{thebibliography}
}
}

\end{multicols}