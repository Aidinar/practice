\def\stat{stupnikov}

\def\tit{ВЕРИФИЦИРУЕМОЕ ОТОБРАЖЕНИЕ МОДЕЛИ ДАННЫХ, ОСНОВАННОЙ НА~МНОГОМЕРНЫХ МАССИВАХ, 
В~ОБЪЕКТНУЮ~МОДЕЛЬ ДАННЫХ$^*$}

\def\titkol{Верифицируемое отображение модели данных, основанной на~многомерных массивах, 
в~объектную модель данных}

\def\autkol{С.\,А.~Ступников}

\def\aut{С.\,А.~Ступников$^1$}

\titel{\tit}{\aut}{\autkol}{\titkol}

{\renewcommand{\thefootnote}{\fnsymbol{footnote}}\footnotetext[1] {Работа 
выполнена при поддержке РФФИ (проект 11-07-00402-а). Статья рекомендована к 
публикации в журнале Программным комитетом конференции <<Электронные 
библиотеки: перспективные методы и технологии, электронные коллекции>> 
(RCDL-2012).}}

\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{Институт проблем информатики Российской академии наук, 
ssa@ipi.ac.ru}

\vspace*{-6pt}       

\Abst{Рассматривается отображение модели данных, основанной на 
многомерных мас\-си\-вах (ММ-мо\-де\-ли), в объектную модель данных. Изложены 
общие принципы отображения ММ-мо\-де\-лей в объектные модели данных. 
Рассмотрено отображение конкретной модели~--- Array Data Model (ADM), 
использующейся в системе управления базами данных (СУБД) SciDB, в язык СИНТЕЗ, 
использующийся в качестве канонической модели данных в технологии предметных 
посредников. Проиллюстрирован метод верификации отображения~--- доказательства 
сохранения информации и семантики операций при отображении. Верификация 
осуществляется при помощи формального языка спецификаций AMN. Практической 
целью работы ставилось создание базы для виртуальной или материализованной 
интеграции ресурсов, основанных на многомерных массивах.}

\vspace*{-1pt}

\KW{многомерные массивы; объектная модель данных; отображение моделей 
данных; интеграция баз данных}

\vspace*{-6pt}

\vskip 14pt plus 9pt minus 6pt

      \thispagestyle{headings}

      \begin{multicols}{2}

            \label{st\stat}
            

\section{Введение}

        Развитие науки и промышленности, широкое распространение 
информационных технологий ведет к накоплению огромных объемов данных 
как в науке, так и в бизнесе. Данные могут быть как наблюдательными, 
экспериментальными, так и полученными в ходе компьютерного 
моделирования. Данные таких масштабов (часто измеряемых уже в петабайтах) 
называются <<большими данными>> (Big Data)~\cite{1-stu}. Они плохо 
поддаются обработке и анализу в рамках широко известных технологий баз 
данных, опирающихся в основном на реляционную модель данных.
        
        Именно поэтому развиваются различные модели данных, нацеленные на 
параллельную обработку и анализ данных в распределенных средах~--- гридах 
и облаках. Важными видами таких моделей являются модели данных, 
основанные на многомерных массивах (array-based data models, или ADM) 
и называемые далее ММ-мо\-де\-ля\-ми. Родственны данным моделям 
так называемые <<кубы данных>>, используемые в 
OLAP (online analytical processing) тех\-но\-ло\-гии~[2--4]. 
Исследования ММ-мо\-де\-лей начались достаточно 
давно~\cite{4-stu, 5-stu} и продолжают развиваться. В~данной статье 
рассматривается конкретная модель, а именно модель, используемая в СУБД 
SciDB~\cite{6-stu}.
        
        История SciDB начинается с 2007~г., когда на симпозиуме по 
экстремально большим базам данных (XLDB~--- extremely large data bases) 
представителями науки и 
промышленности был сделан вывод о том, что существующие СУБД не в 
состоянии манипулировать объемами данных, которые появятся в ближайшем 
будущем. Одним из примеров поставщиков таких данных служит строящийся 
телескоп LSST (Large Synoptic Survey Telescope)~\cite{7-stu}. Был также сделан 
вывод о необходимости разработки СУБД нового поколения, которая должна 
удовлетворять, в частности, следующим требованиям~\cite{8-stu}:
        \begin{itemize}
\item модель данных основывается на многомерных массивах, а не на 
кортежах;
\item модель хранения базируется на версионности, а не на обновлении 
значений;
\item масштабируемость до сотен петабайт и высокая отказоустойчивость;
\item СУБД является свободно распространяемым программным 
обеспечением.
\end{itemize}

        Некоторое время спустя был запущен международный проект под 
руководством Майкла Стоунбрейкера, целью которого стало создание новой 
СУБД, получившей название SciDB. В~настоящее 
время свободно распространяется очередная версия системы для операционных
сис\-тем (ОС) Ubuntu и  RedHat.
        
        Целью данной статьи является исследование вопроса о верифицируемом 
отображении ММ-мо\-де\-лей, и в частности ADM~\cite{9-stu}, 
использующейся в системе SciDB, в объектные 
модели данных для виртуальной или материализованной интеграции ресурсов 
при создании федеративных баз данных или хранилищ данных. 
        
        При материализованной интеграции предполагается создание 
хранилища данных (warehouse), в которое загружаются ресурсы, подлежащие 
интеграции. В~процессе загрузки происходит преобразование данных из схемы 
ресурса в общую схему хранилища.
        
        Виртуальная же интеграция рассматривается в статье применительно к 
предметным посредникам~\cite{10-stu}. Предметные посредники представляют 
собой специальный вид программного обеспечения (ПО), образующий 
промежуточный слой между пользователем (приложением) и неоднородными 
информационными ресурсами. При этом данные из ресурсов не 
материализуются в посреднике. Федеративная схема посредника, описывающая 
некоторую предметную область, создается независимо от существующих 
ресурсов. Ресурсы, релевантные предметной области, затем регистрируются в 
посреднике~--- их схемы связываются специальными семантическими 
отображениями с федеративной схемой. Исполнительная среда посредников 
предо\-став\-ля\-ет возможность пользователям (приложениям) задавать запросы 
(программы) к посреднику в терминах федеративной схемы. Эти запросы 
переписываются в частичные запросы над информационными ресурсами, а 
затем исполняются на ресурсах. Результаты частичных запросов объединяются 
и выдаются пользователю также в терминах федеративной схемы.
        
        Важным понятием технологии систем интеграции баз данных является 
каноническая модель, служащая общим языком, унифицирующим 
разнообразные модели ресурсов.
        
        Необходимым предусловием интеграции ресурсов, основанных на 
многомерных массивах, является построение отображения соответствующей\linebreak 
ММ-мо-де\-ли в каноническую модель данных, сохраняющего информацию и 
семантику операций языка манипулирования данными (ЯМД)~\cite{11-stu}. 
Это обусловлено тем, что семантические отображения, связывающие 
федеративную схему и схемы ресурсов, нужно проводить в единой 
(канонической) модели~\cite{12-stu}. Отображение должно быть 
верифицируемым~--- доказуемо правильным. 
        
        В качестве канонической модели в данной работе рассматривается язык 
СИНТЕЗ~\cite{13-stu}~--- комбинированная слабоструктурированная и 
объектная модель данных, нацеленная на разработку предметных посредников 
для решения задач в средах неоднородных ресурсов. Разработан прототип 
программных средств для поддержки среды предметных посредников с языком 
СИНТЕЗ в роли канонической модели~\cite{14-stu}.
        
        С точки зрения предметных посредников СУБД, основанные на 
многомерных массивах, пред\-став\-ля\-ют собой новый вид ресурсов, подлежащих 
интеграции в посредниках вместе с привычными ресурсами~--- реляционными 
и объектными СУБД, веб-сер\-ви\-са\-ми и~т.\,д. 
        
        Нужно отметить, что ADM подвергается некоторой критике со стороны 
исследователей, продолжающих развитие моделей, основанных на 
многомерных массивах. Так, авторы языка SciQL~\cite{15-stu} отмечают, что 
язык ADM является смесью SQL и деревьев алгебраических операций. По их 
мнению, язык для СУБД, основанных на многомерных массивах, должен быть 
интегрирован с синтаксисом и семантикой SQL:2003. Несмотря на эти 
замечания, модель ADM представляет несомненный практический интерес для 
интеграции баз данных. SciDB используется как в научных проектах, связанных 
с LSST (предполагается после запуска телескопа) и физикой высоких энергий, 
так и в коммерческих, связанных с генетикой, страхованием, финансами. 
Сравнительное тестирование SciDB с СУБД Postgres и статистическим ПО R 
показало преимущества SciDB по производительности и масштабируемости.
        
        Статья организована следующим образом. В~разд.~2 рассмотрены и 
проиллюстрированы основные принципы отобра\-же\-ния модели данных ADM в 
язык СИНТЕЗ. Принципы обобщены на случай моделей, отличных от ADM и 
СИНТЕЗ. В~разд.~3 рассмотрен метод доказательства сохранения информации 
и семантики операций при отоб\-ра\-же\-нии моделей с использованием 
формального языка спецификаций AMN~\cite{16-stu}. Метод 
проиллюстрирован на структурах данных и операциях ЯМД моделей SciDB и 
СИНТЕЗ. В~разд.~4 рассмотрены некоторые родственные исследования и 
направления дальнейшей работы.

\vspace*{6pt}

\section{Отображение модели ADM в~язык СИНТЕЗ}

\vspace*{2pt}

        SciDB поддерживает два языка для работы с массивами: AQL (Array 
Query Language) и AFL (Array\linebreak Functional Language). Язык AQL является 
        SQL (Structured Query Language)
        по\-доб\-ным декларативным языком, включающим как операции 
языка описания данных (ЯОД), так и операции ЯМД. Язык AFL представляет собой функциональный язык 
манипулирования массивами, операции которого можно объединять в 
композиции. Допускается использование операций AFL в запросах AQL.
        
        Операции языков и отображение будут иллюстрироваться на 
адаптированных примерах из сценария применения SciDB в области 
оптической астрономии~\cite{17-stu}, а также на простых примерах из 
документации SciDB~\cite{9-stu}.

\subsection{Отображение языка определения данных}

        Отображение ЯОД в данном разделе описывается независимо от вида 
интеграции~--- виртуальной или материализованной.
        
        Основной единицей определения данных в модели ADM является 
массив, имеющий конечное количество {измерений} $d_1, d_2, \ldots , 
d_n$~[9]. Длиной измерения называется количество упорядоченных значений в 
этом измерении. По умолчанию типом измерения являются 64-бит\-ные целые 
числа. Поддерживаются также нецелочисленные измерения, например строки 
или числа с плавающей точкой. Каждая комбинация значений измерений 
соответствует ячейке массива, которая может содержать конечное количество 
значений, называемых \textit{атрибутами}. Типом атрибута может быть один 
из встроенных типов ADM~\cite{9-stu}.
        
        Основная операция ЯОД ADM~--- создание массива~--- выглядит 
следующим образом:
        \begin{verbatim}
CREATE ARRAY source
< ampExposureId: int64 NULL, 
   filterId: int8,
   apMag: double >
[ ra(double), de(double), objectId=0:*];
\end{verbatim}

        Создается массив оптических источников {\sf source}, измерениями 
которого являются координаты {\sf ra} и {\sf de} типа {\sf double} и целочисленный 
идентификатор объекта. Для целочисленного измерения указаны его нижняя (0) 
и верхняя (<<*>>, обозна\-ча\-ющая бесконечность) границы. Ячейка массива 
состоит из трех атрибутов: {\sf ampExposureId}, {\sf filterId}, 
{\sf apMag}. Указано, что 
атрибут {\sf ampExposureId} может принимать неопределенное значение {\sf NULL}. 
В~данном примере приведены только некоторые из реально используемых 
атрибутов и измерений.
        
        В языке СИНТЕЗ создание массива представляется определением 
одноименного класса:
        \begin{verbatim}
{ source; in: class;
  instance_type:{
  double ra;
  ra2long: {in: function; 
            params: {-ret/long}; };
  double de;
  de2long: {in: function; 
            params: {-ret/long}; };
  long objectId; metaslot lower: 0;  
  higher: inf; end
  objectIdBounds: {in: invariant;
    {{all s(source(s) -> s.objectId >= 0)}}
  };
  long ampExposureId;
  short filterId;
  double apMag;
  key: { unique; { ra, de, objectId } };
  definiteness: {obligatory;
    { ra, de, objectId, filterId, apMag } };
  };
}
\end{verbatim}

        Как измерения, так и атрибуты, составляющие ячейку, представляются в 
языке СИНТЕЗ атрибутами типа экземпляров ({\sf instance\_type}) класса. Между 
встроенными типами ADM ({\sf int8}, {\sf int64}, {\sf double} и~др.)\ и встроенными 
типами языка \mbox{СИНТЕЗ} ({\sf short}, {\sf long}, {\sf double}) устанавливается взаимно 
однозначное соответствие. Совокупность атрибутов, со\-от\-вет\-ст\-ву\-ющих 
измерениям, объявляется уникальной (инвариант {\sf key}, выражаемый 
встроенным утверждением {\sf unique}). Объявляется также, что атрибуты, 
соответствующие измерениям и не-{\sf NULL} атрибутам ADM, должны быть 
определены у всех экземпляров класса (инвариант {\sf definiteness}, выражаемый 
встроенным утверждением {\sf obligatory}).
        
        Таким образом обеспечивается сохранение отличи\-тель\-ных свойств 
многомерных массивов (<<кубов данных>>), существенным образом 
раз\-ли\-ча\-ющих измерения и атрибуты, со\-став\-ля\-ющие \mbox{ячейку}:
        \begin{itemize}
\item по набору значений измерений однозначно определяется набор 
значений атрибутов ячейки (уникальность измерений);
\item ячейка массива всегда определяется полным набором значений 
измерений (определенность измерений).
\end{itemize}

        Заметим также, что отсутствие в коллекции объекта с некоторым 
набором значений измерений означает \textit{пустую ячейку} в массиве.
        
        Для нецелочисленных измерений {\sf ra} и {\sf de} в языке СИНТЕЗ кроме 
атрибутов определяются функции {\sf ra2long}, {\sf de2long}, преобразующие 
нецелочисленные значения в целочисленные. Необходимость при\-вне\-се\-ния этих 
функций вызвана следующим. При попытке описать операции, характерные для 
ММ-мо\-де\-лей, в объектной модели (в частности, в языке СИНТЕЗ) 
выясняется необходимость применения принципиально различных механизмов 
работы с целочисленными и нецелочисленными измерениями. Это вызвано 
различием типов измерений, возможной неравномерностью шага измерения 
и~т.\,д.\linebreak Для того чтобы обеспечить возможность единообразного описания 
операций над цело\-чис\-лен\-ными и нецелочисленными измерениями и 
необходимы функции, приводящие нецелочисленные\linebreak измерения к 
целочисленным.
        
        Ограничения, связанные с нижними и верхними границами 
целочисленных измерений, пред\-став\-ля\-ют\-ся в языке СИНТЕЗ, во-пер\-вых, 
мета\-слотом соответствующего атрибута (например,\linebreak {\sf objectId}). В~метаслоте 
хранится метаинформация, связанная с атрибутом как с отдельной сущностью 
языка. В~данном случае метаслот включает два слота {\sf lower} и {\sf higher}, 
отвечающих соответственно верхней и нижней границе измерения. 
        Во-вто\-рых, создается инвариант (например, {\sf objectIdBounds}), 
предикативная спецификация которого устанавливает ограничения на значения 
измерения для каждого из объектов класса, отвечающего массиву. 
Спецификация инварианта имеет вид формулы первого порядка, где {\sf all}~--- 
квантор существования, <<\verb -> >> --- импликация.
        
        Необходимо отметить, что массив представляется в объектной модели 
множеством объектов класса (фактически кортежей значений атрибутов). При 
этом наблюдается некоторое противоречие со стремлением создателей 
        ММ-мо\-де\-лей \mbox{отойти} от моделей, основанных на кортежах. Однако в 
контексте интеграции ресурсов ММ-мо\-де\-ли это лишь один класс из 
большого множества разнообразных классов моделей данных. Представление 
специфических ММ-мо\-де\-лей в объектной модели является методологически 
и технически гораздо более простым и естественным, нежели использование 
многомерных массивов в качестве канонической модели.
        
        Изложенные принципы отображения ЯОД могут быть обобщены на 
случай, когда канонической является объектная или 
        объ\-ект\-но-ре\-ля\-ци\-он\-ная модель, отличная от языка СИНТЕЗ. 
Также не принципиален выбор модели данных, основанной на многомерных 
массивах. В~общем виде принципы отображения ЯОД выглядят следующим 
образом:
        \begin{itemize}
\item массив отображается в коллекцию типизированных объектов (класс) 
объектной модели;
\item измерения и атрибуты, составляющие ячейку массива, отображаются в 
атрибуты типа экземпляров класса;
\item между встроенными типами модели, основанной на многомерных 
массивах, и встроенными типами объектной модели устанавливается 
взаимно однозначное соответствие;
\item совокупность атрибутов, соответствующих измерениям, объявляется 
уникальной (при помощи механизма ключей, утверждений или 
инвариантов);
\item атрибуты, соответствующие измерениям и не-{\sf NULL} атрибутам ячейки 
массива, объявляются определенными (при помощи утверждений или 
инвариантов);
\item для нецелочисленных измерений в типе экземпляров дополнительно 
определяются методы, преобразующие нецелочисленные значения в 
целочисленные;
\item ограничения, связанные с нижними и верхними границами 
целочисленных измерений, отображаются при помощи инвариантов или 
встроенных утверждений о кардинальности соответствующих атрибутов. 
В~случае использования инвариантов при отображении границы измерений 
представляются также метаданными атрибута.
\end{itemize}

\subsection{Отображение языка манипулирования данными}

        При интеграции баз данных для установления семантических 
соотношений между схемами ресурсов и федеративной схемой необходимо 
отображение ЯОД исходной модели в каноническую. Язык манипулирования данными канонической 
модели, напротив, необходимо отображать в ЯМД исходной модели. Это 
связано с тем, что запросы к посреднику в канонической модели необходимо 
отображать в запросы к ресурсам.
        
        Отметим отличие виртуальной и материализованной интеграции. При 
виртуальной интеграции отображение ЯМД обеспечивает возможность 
трансляции программ на языке посредника в запросы на языке ресурсов. 
        
        В случае материализованной интеграции данные извлекаются из ресурса 
и представляются в хранилище в канонической модели. При этом программы 
на языке канонической модели исполняются непосредственно на данных. 
Отоб\-ра\-же\-ние\linebreak ЯМД нужно лишь для того, чтобы убедиться, что отображение 
моделей сохраняет информацию и семантику операций. Семантически 
правильное\linebreak отоб\-ра\-же\-ние служит базой для процесса 
        <<из\-вле\-че\-ния--пре\-образо\-ва\-ния--за\-груз\-ки>> (ETL), 
формирующего из данных ресурса данные хранилища:\linebreak ETL-про\-цесс может 
быть выражен только в терминах канонической модели.
        
        \smallskip
        
        Язык запросов (программ) модели СИНТЕЗ представляет собой 
        Datalog-по\-доб\-ный язык в объектной среде. Программа представляет 
собой набор конъюнктивных запросов (правил) вида 

\noindent
\begin{multline*}
        q(x/T): - C_1(x_1/T_1),\ldots , C_n(x_n/T_n), (X_1,Y_1), 
\ldots \\
\ldots F_m(X_m,Y_m), B\,.
        \end{multline*}
        Тело запроса представляет собой конъюнкцию 
        пре\-ди\-ка\-тов-кол\-лек\-ций, функциональных предикатов и 
ограничения. Здесь $C_i$~--- имена коллекций (классов), $F_i$~--- имена 
функций, $x_i$~--- имена переменных, значения которых пробегают по 
классам, $T_i$~--- типы переменных, $X_j$ и $Y_j$~--- входные и выходные 
параметры функций, $B$~--- ограничение, налагаемое на $x_i$, $X_j$, $Y_j$. 
Предикаты, находящиеся в голове правил, могут быть использованы в телах 
других правил в качестве пре\-ди\-ка\-тов-кол\-лек\-ций. 
        
        В дальнейшем будет часто использоваться запись 
        пре\-ди\-ка\-та-кол\-лек\-ции вида {\sf source([ra, de])}. Неформально это 
означает, что представляют интерес не объекты класса {\sf source} целиком, а 
лишь их атрибуты {\sf ra} и {\sf de}. Формально запись означает сокращение от 
{\sf source(\_/source.inst[ra, de])}. Здесь знак <<{\sf \_}>> обозначает анонимную 
переменную, {\sf source.inst}~--- анонимный тип экземпляров (instance) класса 
{\sf source}, а {\sf ra} и {\sf de}~--- необходимые атрибуты типа экземпляров класса.
        
        Будет также использоваться запись {\sf source([i, j, val1/val])}, означающая 
переименование атрибута {\sf val} в {\sf val1}.
        
        \medskip
        
        При отображении ЯМД будут сначала рассмотрены основные 
конструкции языка программ СИНТЕЗ, соответствующие конструкциям языка 
AQL. Затем будут рассмотрены конструкции \mbox{СИНТЕЗ}, соответствующие 
конструкциям языка AFL.
        
        Начнем рассмотрение с конструкций языка СИНТЕЗ, соответствующих 
конструкциям языка AQL, связанных с {извлечением} данных.
        
%        \smallskip
        
\paragraph*{Предикаты-классы, условия, подзапросы.} Рас\-смот\-рим 
программу, извлекающую координаты ({\sf ra}, {\sf de}) и апертурную звездную 
величину ({\sf apMag}) астрономических источников из класса  {\sf source} с 
условием на фильтр ({\sf filterId}) и апертурную звездную величину, причем 
запрос~{\sf q} использует результаты запроса~{\sf r}:
        \begin{verbatim}
q([ra,de,apMag]) :- r([ra,de,apMag]),
   filterId= #filterId.
r([ra,de,apMag]) :- source([ra,de,apMag]),
   apMag >= #apMag.
\end{verbatim}
Здесь {\sf \#filterId} и {\sf \#apMag}~--- некоторые константы 
соответствующих типов.
        
        Такая программа представляется в AQL сле\-ду\-ющим запросом:
        \begin{verbatim}
SELECT apMag FROM 
  ( SELECT apMag FROM source
    WHERE apMag >= #apMag )
WHERE filterId = #filterId;
\end{verbatim}
        
        Простые условия отображаются в AQL без изменений, рекурсивные 
запросы представляются вложенными запросами. Заметим, что координаты 
{\sf ra} и {\sf de} не указываются в секции {\sf SELECT}~--- они являются измерениями и 
извлекаются по умолчанию.
        
\paragraph*{Соединение классов.} Соединение по определенным атрибутам 
(например, {\sf objectId})
        \begin{verbatim}
q2([ra, de, filterId, uMag]) :- 
    source([ra, de, objectId, fliterId]), 
    objectSummary([objectId, uMag]).
\end{verbatim}
представляется в AQL конструкцией {\sf JOIN-ON}:
\begin{verbatim}
SELECT filterId, uMag INTO q2
FROM source
JOIN objectSummary 
ON source.objectId = objectSummary.objectId;
\end{verbatim}
где массив {\sf objectSummary} имеет вид: 
\begin{verbatim}
CREATE ARRAY objectSummary
<uMag: float NULL,  gMag: float NULL>
[ objectId=0:* ];
\end{verbatim}
        
\paragraph*{Агрегация.} Рассмотрим запрос, возвращающий объекты с 
минимальной звездной величиной {\sf uMag}:
        \begin{verbatim}
q([objectId, uMag]) :-  
  objectSummary(obj/[objectId, uMag]), 
    uMag = min(obj.uMag).
\end{verbatim}

        Запрос представляется в AQL с использованием агрегирующей функции 
того же рода:
        \begin{verbatim}
SELECT uMag
FROM source, 
 (SELECT min(uMag) AS min FROM Source)
WHERE uMag = min;
\end{verbatim}
        
\paragraph*{Группирование.} Рассмотрим запрос, возвра\-ща\-ющий среднее 
значение звездной величины {\sf uMag}, вычисленное на группе по 
идентификатору объекта {\sf filterId}:
        \begin{verbatim}
q([objectId, avgMag]) :- 
    group_by({objectId}, 
       q2(obj/[ra,de,filterId, uMag])),
    avgMag = average(obj.uMag).
\end{verbatim}

        Здесь коллекция {\sf q2}, на которой производится группирование по 
атрибуту {\sf objectId}~--- результат соединения классов {\sf source} и 
{\sf objectSummary}, рассмотренных выше.
        
        Очевидно, в AQL запрос представляется при помощи конструкции 
GROUP BY:
        \begin{verbatim}
SELECT avg(uMag) AS avgMag
FROM q2 GROUP BY objectId;
\end{verbatim}
        
        Рассмотрим конструкции языка СИНТЕЗ, соответствующие 
конструкциям языка AQL и связанные с {изменением} данных.

        
\paragraph*{Обновление.} Рассмотрим запрос, изменяющий значения в 
квадратной матрице (см.\ предыдущий пример) на значения с обратным знаком 
в том случае, если модуль значения больше~5:
        \begin{verbatim}
source(x/[i, j, val]) :- 
    source(x/[i, j, val1/val]), 
       abs(val) > 5, val = -val1.
\end{verbatim}
        
        В AQL данный запрос представляется сле\-ду\-ющим образом:
        \begin{verbatim}
UPDATE source
SET val =  -val WHERE abs(val) > 5;
\end{verbatim}


        
\paragraph*{Удаление.} Рассмотрим программу, удаляющую из базы данных 
класс и все его содержимое:
        \begin{verbatim}
-source(x) :- source(x).; 
delete_frame(source).
\end{verbatim}

        В правилах со знаком минус в голове осуществляется удаление объектов 
из коллекции. В~данном случае из коллекции удаляются все объекты. Функция 
{\sf delete\_frame} удаляет коллекцию как объект из базы данных. Операция <<{\sf ;}>> 
обозначает последовательную композицию программ. В~AQL данный запрос 
представляется при помощи операции {\sf DROP}:
\begin{verbatim}
DROP ARRAY source;
\end{verbatim}

        Рассмотрим принципы отображения конструкций языка СИНТЕЗ, 
соответствующих конструкциям AFL, на примере {расширения элементов 
мас\-си\-ва в подмассивы}. Каждый элемент массива расширя\-ется в подмассив 
определенного размера. Значения всех ячеек подмассива дублируют значение 
оригинальной ячейки. Пример программы, расширяющей каждую ячейку 
матрицы $3\times3$ в подматрицу $2\times2$:
        \begin{verbatim}
q([i,j,val]) :- {x/[i,j,val] | exists y (
  source(y/[i1/i, j1/j, val]) & 
  ( i = i1*2 & j = j1*2 | i = i1*2 +1 & 
  j = j1*2 | i= i1*2 & 
  j= j1*2 + 1 | i= i1*2 +1 & j= j1*2 +1))}.
\end{verbatim}
    Здесь выражение $\{x/T \vert F(x)\}$, где $F$~--- формула со свободной 
переменной~$x$, обозначает конструкцию выделения множества; {\sf exists} 
обозначает квантор существования. 

\columnbreak
        
        В ADM запрос представляется с использованием операции {\sf xgrid}:
        \begin{verbatim}
SELECT * FROM xgrid(source, 2, 2);
\end{verbatim}
        
        Можно заметить, что операция AFL {\sf xgrid} имеет достаточно сложно 
устроенный прообраз в канонической модели (это справедливо и для многих 
других операций). Между тем эти операции являются естественными для 
массивов. Поэтому при интеграции ресурсов, основанных на многомерных 
массивах, в канонической модели возможно использование специального 
класса {\sf array}, инкапсулирующего специфические операции, характерные для 
многомерных массивов:
        \begin{verbatim}
{ array; in: class;
  instance_type: {
  xgrid: { in: function; 
    params: {
     +dimensions/{sequence; 
      type_of_element: string;},
     +scales/{sequence; 
      type_of_element: integer;}};
  };  };
}
\end{verbatim}
        В приведенном примере рассмотрена сигнатура единственной операции 
{\sf xgrid}, параметрами которой являются последовательность имен измерений\linebreak 
{\sf dimensions} и последовательность масштабов увеличения по каждому из 
измерений {\sf scales}. Па\-ра\-мет\-ром операции по умолчанию также считается 
класс\linebreak {\sf array} как коллекция объектов. При отображении ЯОД каждый класс~--- 
образ массива (например, класс {\sf source} из подразд.~2.1) становится подклассом 
класса {\sf array}:
        \begin{verbatim}
{ source; in: class; superclass: array;
  instance_type: { ... };
}
\end{verbatim}

        Аналогично {\sf xgrid}, операциями класса {\sf array} могут быть 
представлены такие операции AFL, как {\sf substitute}, {\sf sort}, 
{\sf multiply} и~т.\,д. 
        
        Заметим, что решение о представлении операций, характерных для 
многомерных массивов, в рамках специального класса канонической модели 
допускает обобщение на объектные канонические модели, отличные от языка 
СИНТЕЗ, и модели, основанные на многомерных массивах, отличные от ADM.
        
        \smallskip
        
        Разработанные отображения ЯОД и ЯМД были частично реализованы на 
языке ATL (ATLAS\linebreak Transformation Language)~\cite{18-stu}. ATL-программы 
пред\-став\-ля\-ют собой де\-кла\-ра\-тив\-но-им\-пе\-ра\-тив\-ные трансформации, 
реализующие отображения произвольных исходных моделей уровня М1 
(согласно классификации MOF~\cite{19-stu}), конформных исходной 
метамодели уровня М2, в целевые модели уровня М1, конформные целевой 
метамодели уровня М2. Модели уровня М1 являются схемами, 
представленными в канонической модели данных или модели ADM; модели 
уровня М2 есть описание абстрактного синтаксиса канонической модели или 
модели ADM. В~качестве метамодели уровня М3, которой конформны 
метамодели уровня M2, рассматривается модель Ecore~\cite{20-stu}. Cинтаксис 
ЯОД и ЯМД ядра канонической информационной модели (языка СИНТЕЗ) и 
модели ADM был представлен в метамодели Ecore. 
        
        Было осуществлено построение ATL-транс\-фор\-ма\-ций, реализующих 
отображения подмножества ЯОД модели ADM в ЯОД канонической модели и 
подмножества ЯМД канонической модели в ЯМД модели ADM. Подмножества 
ЯМД определялись конструкциями ЯОД и ЯМД канонической модели, 
поддерживаемыми в настоящее время в исполнительной среде предметных 
посредников. Поддерживаемый язык запросов канонической модели включает 
правила, в голове которых могут быть пре\-ди\-ка\-ты-кол\-лек\-ции, а в теле~--- 
конъюнкция пре\-ди\-ка\-тов-кол\-лек\-ций, условий соединения коллекций и 
других условий на значения атрибутов типов экземпляров коллекций. 
Условием соединения может быть только равенство атрибутов. 
Поддерживаются основные арифметические предикаты и функции, а также 
термы~--- вызовы функций. 

\section{Сохранение информации и~семантики операций языка манипулирования данными 
при~отображении}
        
        Метод доказательства сохранения информации и семантики операций 
при отображении моделей данных~\cite{21-stu} основывается на представлении 
семантики моделей в формальном языке спецификаций AMN~\cite{16-stu}. 
        
        Язык AMN представляет собой тео\-ре\-ти\-ко-мо\-дель\-ную нотацию, 
основанную на теории множеств и типизированном языке первого порядка. 
Спецификации AMN называются абстрактными машинами. Язык AMN позволяет 
интегрированно рас\-смат\-ри\-вать спецификацию пространства состояний и 
поведения машины (определенного операциями на состояниях). В~AMN 
формализуется специальное отношение между спецификациями~--- 
{уточнение}. Неформально спецификация~$B$ уточняет 
спецификацию~$A$, если пользователь может использовать $B$ вместо~$A$, 
не замечая факта замены~$A$ на~$B$. 
{\looseness=1

}
        
        Идея метода заключается в следующем. Рассмотрим исходную 
модель~$S$ и целевую модель~$T$. Построим отображение~$\theta$ 
модели~$S$ в модель~$T$ (подобно изложенному в предыдущем разделе). 
Выразим семантику моделей в виде абстрактных машин AMN, построив при 
этом машины $M_S$ и $M_T$ соответственно. При этом структуры данных 
моделей~--- классы, массивы~--- представляются переменными машин, 
различные свойства структур данных представляются инвариантами машин, 
характерные операции моделей данных представляются операциями машин. 
Рассматриваемые операции исходной и целевой модели должны быть связаны 
отображением ЯМД. Отображение ЯОД представляется в виде специального 
\textit{склеивающего инварианта}~--- замкнутой формулы, связывающей 
состояния машин~$M_S$ и~$M_T$.
        
        Будем считать отображение~$\theta$ сохраняющим инфор\-ма\-цию и 
семантику операций, если машина~$M_S$, соответствующая исходной модели, 
уточняет машину~$M_T$, соответствующую целевой модели. Уточнение 
доказывается интерактивно при помощи специальных программных 
средств~\cite{22-stu}.
        
        \smallskip
        
        В качестве иллюстрации основных принципов выражения семантики 
моделей ADM и СИНТЕЗ в AMN рассмотрим частичные 
        AMN-спе\-ци\-фи\-ка\-ции, соответствующие данным моделям.
        
        Cпецификация, выражающая семантику объектной модели языка 
СИНТЕЗ, представляется в языке AMN конструкцией {\sf REFINEMENT}:
\begin{verbatim}
REFINEMENT ObjectDM
\end{verbatim}

        Переменные, составляющие пространство состояний объектной модели, 
объявлены в разделе {\sf ABSTRACT\_VARIABLES} машины {\sf ObjectDM} и 
типизируются в разделе {\sf INVARIANT}:
\begin{verbatim}
ABSTRACT_VARIABLES
    typeNames, classNames, attributeNames,
    instanceType, typeAttributes, 
      attributeType,
    unique, obligatory,
    intAttributeLowerBound, 
      intAttributeHigherBound,
    objectIDs, objectType, objectsOfClass,
    integerAttributeValue,
    adtAttributeValue
INVARIANT ...
\end{verbatim}

        Раздел {\sf INVARIANT} содержит формулу, которая состоит из предикатов, 
типизирующих переменные состояния и налагающих различные совместные 
ограничения на переменные. Предикаты соединяются операцией конъюнкции.
        
        Так, имена типов и классов представлены переменными {\sf typeNames} и 
{\sf classNames}, тип которых~--- подмножество множества строк 
({\sf STRING\_Type}):
        \begin{verbatim}
typeNames: POW(STRING_Type) &
classNames: POW(STRING_Type)
\end{verbatim}
        
        \noindent
        Здесь {\sf POW}~--- конструктор множества подмножеств.
        
        Атрибуты (переменная {\sf attributeNames}) пред\-став\-ле\-ны частичной 
функцией (знак <<\verb +-> >>), ставящей в соответствие уникальному идентификатору 
атрибута (натуральному числу из множества {\sf NAT}) имя атрибута (строку):
        \begin{verbatim}
attributeNames: NAT +-> STRING_Type
\end{verbatim}

        Типы экземпляров классов (переменная\linebreak {\sf instanceType}) представлены 
тотальной функцией (знак \verb -> ) из множества имен классов в 
множество имен типов:
        \begin{verbatim}
instanceType: classNames --> typeNames
\end{verbatim}

        Принадлежность атрибутов типам (переменная {\sf typeAttributes}) 
выражена тотальной функцией из множества имен типов в множество 
подмножеств атрибутов:
        \begin{verbatim}
typeAttributes: 
  typeNames --> POW(dom(attributeNames))
\end{verbatim}
        Здесь {\sf dom}~--- операция, возвращающая область определения 
функции, а {\sf dom(attributeNames)}~--- множество имен атрибутов.
        
        Типы значений атрибутов (переменная\linebreak {\sf attributeType}) представлены 
функцией из множества атрибутов в множество идентификаторов встроенных 
типов данных {\sf BuiltInTypes}:
        \begin{verbatim}
attributeType: 
  dom(attributeNames) +-> BuiltInTypes
\end{verbatim}

        Множества уникальных атрибутов типов {\sf unique}\linebreak и множества 
определенных атрибутов типов\linebreak {\sf obligatory} представлены тотальными 
функциями из множества имен типов в множество подмножеств атрибутов:
\begin{verbatim}
unique: 
  typeNames --> POW(dom(attributeNames))&
obligatory: 
  typeNames --> POW(dom(attributeNames))
\end{verbatim}

        Нижние границы целочисленных атрибутов (переменная 
{\sf intAttributeLowerBound}) представлены час\-тич\-ной функцией из множества 
атрибутов в множество целых чисел:
\begin{verbatim}
intAttributeLowerBound: 
  dom(attributeNames) +-> INT
\end{verbatim}

        Аналогично представляются верхние границы.
        
        Идентификаторы объектов (переменная\linebreak {\sf objectIDs}) представлены 
подмножеством натуральных чисел:
        \begin{verbatim}
objectIDs: POW(NAT)
\end{verbatim}

        Типы объектов (переменная {\sf objectType}) представлены тотальной 
функцией из множества объектных идентификаторов в множество имен типов:
\begin{verbatim}
objectType: objectIDs --> typeNames
\end{verbatim}

        Состав классов (переменная {\sf objectsOfClass}) представлен тотальной 
функцией из множества имен классов в множество подмножеств 
идентификаторов объектов:
        \begin{verbatim}
objectsOfClass: 
  classNames --> POW(objectIDs)
\end{verbatim}
        
        Значения атрибутов объектов (переменные\linebreak {\sf integerAttributeValue}, 
{\sf adtAttributeValue} и~др.)\ пред\-став\-ле\-ны функциями из множества атрибутов\linebreak 
в функции из множества идентификаторов объектов в множества значений 
атрибутов. Для простоты рассмотрены лишь функции для целочисленных 
атрибутов и атрибутов со значениями АТД\linebreak (абстрактного типа данных) (объектами):
        \begin{verbatim}
integerAttributeValue: 
 dom(attributeNames) +-> (objectIDs+->INT)& 
adtAttributeValue: 
 dom(attributeNames) +-> (objectIDs+->NAT)
\end{verbatim}
        
        Дополнительные необходимые свойства переменных состояния 
представлены конъюнктивными компонентами инварианта. Так, каждый 
атрибут является атрибутом некоторого типа:
        \begin{verbatim}
        
UNION(tt).(tt:typeNames|typeAttributes(tt))=
    dom(attributeNames)
\end{verbatim}
        Здесь {\sf UNION}~--- родовая операция объединения, в данном случае 
объединяются множества атрибутов {\sf typeAttributes(tt)} по всем именам 
типов~{\sf tt} из множества {\sf typeNames}. 
        
        Никакой атрибут не принадлежит двум типам одновременно:
        \begin{verbatim}
!(t1, t2).(t1: typeNames & t2: typeNames =>
  (typeAttributes(t1) /\ typeAttributes(t2) 
    = {}))
\end{verbatim}
   Здесь <<\verb ! >>~--- знак квантора всеобщности, <<\verb => >>~--- логическая 
импликация, <<\verb /\ >>~--- символ пересечения множеств, <<\verb {} >>~--- пустое 
множество.
        
        Уникальные и определенные атрибуты типа выбираются из множества 
атрибутов типа:
        \begin{verbatim}
!(tt).(tt: dom(unique) => unique(tt) <: 
typeAttributes(tt)) &
!(tt).(tt: dom(obligatory) => 
    obligatory(tt) <: typeAttributes(tt))
\end{verbatim}
        Здесь <<\verb <: >>~--- символ отношения мно\-жес\-во--под\-мно\-жество.
        
        Нижние и верхние границы могут быть определены только для 
целочисленных атрибутов:
        \begin{verbatim}
!(attr).(attr: dom(intAttributeLowerBound)=> 
    attributeType(attr) = Integer) 
\end{verbatim}

        Тип объекта~--- экземпляра класса есть тип экземпляров этого класса:
        \begin{verbatim}
!(cc).(cc: classNames => 
    !(oo).(oo: objectsOfClass(cc) => 
       objectType(oo) = instanceType(cc))) 
\end{verbatim}

        Для каждого атрибута определена ровно одна функция значений:
        \begin{verbatim}
dom(adtAttributeValue) /\ 
  dom(integerAttributeValue) = {} &
dom(adtAttributeValue) \/ 
  dom(integerAttributeValue) = 
    dom(attributeNames)
\end{verbatim}
   Здесь <<\verb \/ >>~--- символ объединения множеств.
        
        Для любого объекта и любого определенного атрибута типа этого 
объекта функция значений атрибута определена на объекте:
        \begin{verbatim}
!(oo, aa).(oo: dom(objectType) & 
  aa: typeAttributes(objectType(oo)) & 
  aa: obligatory(objectType(oo)) =>
      (attributeType(aa) = Integer => 
       oo: dom(integerAttributeValue(aa))) &
      (attributeType(aa) = ADT =>
       oo: dom(adtAttributeValue(aa)))) 
\end{verbatim}

        Для любого объекта и любого целочисленного атрибута типа объекта, 
определенного на объекте и для которого определена нижняя (верхняя) 
граница, значение атрибута не меньше (не больше) нижней (верхней) границы:
        \begin{verbatim}
!(oo, aa).(oo: objectIDs & 
    aa: typeAttributes(objectType(oo)) &
    oo: dom(integerAttributeValue(aa) => 
    (aa: dom(intAttributeLowerBound) =>
        (integerAttributeValue(aa)(oo) >= 
         intAttributeLowerBound(aa))) ) 
\end{verbatim}

        Объект однозначно идентифицируется набором своих уникальных 
атрибутов:
        \begin{verbatim}
!(oo1, oo2).(oo1: objectIDs & 
  oo2: objectIDs &
    objectType(oo1) = objectType(oo2) & 
    unique(objectType(oo1)) /= {} &
    !(aa).(aa: unique(objectType(oo1)) => 
      (attributeType(aa) = Integer =>
        integerAttributeValue(aa)(oo1) =
         integerAttributeValue(aa)(oo2)) &
      (attributeType(aa) = ADT =>
         adtAttributeValue(aa)(oo1) =
          adtAttributeValue(aa)(oo2)) ) => 
    oo1 = oo2 )
\end{verbatim}

        Из всего ЯМД в спецификации рассмотрена единственная операция 
{\sf update} обновления значений атрибута в объектах класса:
        \begin{verbatim}
OPERATIONS
update(cls, attr, exp, cond) =
PRE cls: classNames & 
  attr: typeAttributes(instanceType(cls)) &
  attributeType(attr) = Integer &
  exp: INT --> INT & cond: NAT --> BOOL
THEN
 integerAttributeValue := 
 integerAttributeValue <+ 
 { xx | xx: (NAT*(NAT<->INT)) &
  #(oo, val).( oo: objectsOfClass(cls) & 
  val: INT &
    xx = attr |-> ({oo |-> val}) & 
  (cond(integerAttributeValue(attr)(oo)) 
  = TRUE =>
  val=exp(integerAttributeValue(attr)(oo)))&
  (cond(integerAttributeValue(attr)(oo)) 
  = FALSE => 
  val=integerAttributeValue(attr)(oo)))}
END
\end{verbatim}

        Параметрами операции являются имя класса {\sf cls}, имя целочисленного 
атрибута {\sf attr} типа экземпляров класса, функция {\sf exp}, отвечающая за 
преобразование атрибута, и функция {\sf cond}, отвечающая условию на значение 
атрибута. Пусть {\sf o}~--- некоторый объект класса {\sf cls}, для которого определено 
значение атрибута {\sf attr}, и это значение есть~{\sf v}. Тогда операция {\sf update} 
изменяет значение атрибута на {\sf exp(v)} в случае, если выражение {\sf cond(v)} 
принимает значение <<истина>>, и оставляет значение атрибута без изменений в 
противном случае. Очевидно, такая операция {\sf update} есть обобщение примера 
обновления, рассмотренного в подразд.~2.2. Действительно, для рассмотренного 
примера {\sf cls} есть {\sf source}, {\sf attr} есть {\sf val}, 
{\sf exp(v)}\;=\;-\,{\sf v}, {\sf cond(v)}\;=\;{\sf abs(v)}.
        
        Заметим, что в рассмотренной спецификации для простоты не 
рассмотрены некоторые черты объектной модели, например отношения 
        тип--под\-тип и класс--под\-класс.
        
        \smallskip
        
        Спецификация, выражающая семантику модели ADM, представляется в 
языке AMN конструкцией
        \begin{verbatim}
REFINEMENT ArrayDM
\end{verbatim}

        Переменные, составляющие пространство состояний объектной модели, 
объявлены в разделе {\sf ABSTRACT\_VARIABLES} машины {\sf ArrayDM}:
        \begin{verbatim}
ABSTRACT_VARIABLES
    arrayNames, dimensionNames, 
    cellAttributeNames,
    arrayDimensions, arrayCellAttributes,    
    cellAtrributeType, nullable, 
    dimLowerBound, dimHigherBound,
    cells, dimensionValue, 
    integerCellAttributeValue
\end{verbatim}

        Имена массивов представлены переменной\linebreak 
{\sf arrayNames}; имена измерений~--- переменной\linebreak 
{\sf  dimensionNames}; имена атрибутов ячеек массива~--- переменной 
\mbox{{\sf cellAttributeNames}}; принадлежность измерений массивам~--- переменной 
\mbox{{\sf arrayDimensions}}; принадлежность атрибутов ячеек~--- переменной 
\mbox{{\sf arrayCellAttributes}}; 
тип атрибута ячейки~--- переменной \mbox{{\sf cellAtrributeType}}; 
атрибуты ячеек массивов, которые могут принимать неопределенные 
значения,~--- переменной \mbox{{\sf nullable}}; верхние (нижние) границы измерений~--- 
переменной \mbox{{\sf dimLowerBound}} (\mbox{{\sf dimHigherBound}}); множества 
идентификаторов ячеек массивов~--- переменной 
\mbox{{\sf cells}}, значения измерений в 
ячейках~--- переменной \mbox{{\sf dimensionValue}}; значения атрибутов ячеек~--- 
переменной \mbox{{\sf integerCellAttributeValue}}. Переменные типизируются в разделе 
\mbox{{\sf INVARIANT}} при помощи частичных и тотальных функций аналогично 
переменным, использующимся для придания семантики объектной модели:
        \begin{verbatim}
INVARIANT
   arrayNames: POW(STRING_Type) &
   dimensionNames: NAT +-> STRING_Type &
   cellAttributeNames: NAT +-> STRING_Type &
   arrayDimensions: arrayNames --> 
   POW(dom(dimensionNames)) &
   arrayCellAttributes: arrayNames --> 
     POW(dom(cellAttributeNames)) &
   cellAtrributeType: 
     dom(cellAttributeNames) --> 
       BuiltInTypes &
   nullable: 
     dom(cellAttributeNames) --> BOOL &
   dimLowerBound: 
     dom(dimensionNames) --> INT &
   dimHigherBound: 
     dom(dimensionNames) +-> INT &
   cells: arrayNames --> POW(NAT) & 
   dimensionValue: 
     NAT*dom(dimensionNames) +-> INT  &
   integerCellAttributeValue: 
     NAT*dom(cellAttributeNames) +-> INT &
\end{verbatim}
        Здесь <<\verb * >>~--- знак декартова произведения множеств.
        
        Дополнительные необходимые свойства переменных состояния 
представлены конъюнктивными компонентами инварианта. Так, любая ячейка 
любого массива однозначно идентифицируется набором значений измерений:
        \begin{verbatim}
!(arr, cell1, cell2).(arr: arrayNames & 
  cell1: cells(arr) &  cell2: cells(arr) &
  !(dim).(dim: arrayDimensions(arr) =>
    dimensionValue(cell1, dim) = 
    dimensionValue(cell2, dim)) =>
    cell1 = cell2)
        \end{verbatim}
        
                \vspace*{-6pt}
        
        Для любой ячейки любого массива определены значения всех измерений 
и значение по крайней мере одного атрибута:
        \begin{verbatim}
!(arr, cell).(arr: arrayNames & 
 cell: cells(arr) =>
  !(dim).(dim: arrayDimensions(arr) => 
   (cell |-> dim): dom(dimensionValue)) &
   #(attr).(attr: arrayCellAttributes(arr) & 
    cellAtrributeType(attr) = Integer & 
    (cell, attr): 
      dom(integerCellAttributeValue)) )
        \end{verbatim}
        
        \vspace*{-6pt}
        
        Аналогично объектной модели рассмотрена единственная операция 
ЯМД~--- операция об\-нов\-ле\-ния {\sf update}:
        \begin{verbatim}
OPERATIONS
update(cls, attr, exp, cond) =
PRE cls: arrayNames & 
 attr: arrayCellAttributes(cls) &
  cellAtrributeType(attr) = Integer &
  exp: INT --> INT & cond: NAT --> BOOL
THEN
  integerCellAttributeValue := 
  integerCellAttributeValue <+
  { yy | yy: (NAT*NAT)*INT &
    #(cell, val).(cell: cells(cls) & 
     val: INT & 
    yy = ((cell |-> attr)|-> val) &
    (cond(integerCellAttributeValue(cell, 
     attr)) = TRUE =>
      val = 
       exp(integerCellAttributeValue(cell,
        attr))) &
      (cond(integerCellAttributeValue(cell, 
       attr))= FALSE  =>
    val = 
     integerCellAttributeValue(cell,attr)))}
END   
END
        \end{verbatim}
        
                \vspace*{-6pt}
        
        Сигнатура операции совпадает с сигнатурой операции объектной 
модели. Семантика операции также аналогична: значение~{\sf v} атрибута {\sf attr} 
массива {\sf cls} заменяется на {\sf exp(v)}, если значение {\sf cond(v)} есть 
<<истина>>, и не изменяется в противном случае. 
        
        Заметим, что в данной спецификации для прос\-то\-ты не рассмотрены 
некоторые черты ADM, например нецелочисленные измерения.
        
        \smallskip
        
        Для формального доказательства того, что машина {\sf ArrayDM} уточняет 
машину {\sf ObjectDM}, необходимо построить {инвариант уточнения}, 
связы\-вающий переменные машин, и добавить его к\linebreak инварианту уточняющей 
машины. 
        
        Инвариант формализует принципы отображения ЯОД, изложенные в 
подразд.~2.1, и объединяет их в одну конъюнкцию.
        
        Так, множество имен массивов совпадает с множеством имен классов:
        \begin{verbatim}
classNames = arrayNames
\end{verbatim}

%                \vspace*{-6pt}
        
        Множество идентификаторов и имен измерений и атрибутов ячеек 
совпадает с множеством идентификаторов и имен атрибутов типов экземпляров 
классов:
        \begin{verbatim}
attributeNames = 
  dimensionNames \/ cellAttributeNames
\end{verbatim}

%                \vspace*{-6pt}

        Любому измерению любого массива соответствует атрибут типа 
экземпляра класса, соответствующего этому массиву:
        \begin{verbatim}
!(arr, dim).(arr: arrayNames & 
  dim: arrayDimensions(arr) =>
    #(attr).(attr: 
     typeAttributes(instanceType(arr)) &
          attr = dim & 
          attributeType(attr) = Integer) )s
        \end{verbatim}
        
                        \vspace*{-6pt}
        
        Любому атрибуту ячейки любого массива соответствует атрибут типа 
экземпляра класса, соответствующего этому массиву, и типы атрибутов 
совпадают:
        \begin{verbatim}
!(arr, cattr).(arr: arrayNames & 
   cattr: arrayCellAttributes(arr) =>
    #(attr).(attr: 
      typeAttributes(instanceType(arr)) & 
         attr = cattr & 
         attributeType(attr) = 
           attributeType(cattr)))
        \end{verbatim}
        
                        \vspace*{-9pt}
        
        Атрибут ячейки массива, который может принимать неопределенные 
значения, соответствует определенному ({\sf obligatory}) атрибуту типа:
        \begin{verbatim}
!(arr, cattr).(arr: arrayNames & 
  cattr /: dom(nullable) &
    cattr: arrayCellAttributes(arr) => 
    cattr: obligatory(instanceType(arr)) )
        \end{verbatim}
        
\vspace*{-9pt}

           Здесь знак <<\verb /: >> обозначает отношение непринадлежности элемента 
множеству.
        
        Измерения соответствуют уникальным атрибутам типов:
        \begin{verbatim}
!(arr, dim).(arr: arrayNames & 
    dim: arrayDimensions(arr) => 
      dim: unique(instanceType(arr)) )
        \end{verbatim}
        
                        \vspace*{-6pt}
        
        Верхние (нижние) границы измерений равны верхним (нижним) 
границам соответствующих атрибутов типов:
        \begin{verbatim}
!(dim).(dim: dom(dimLowerBound) =>
    dim: dom(intAttributeLowerBound) & 
    dimLowerBound(dim) = 
      intAttributeLowerBound(dim))
        \end{verbatim}
        
                        \vspace*{-6pt}
        
        Непустые ячейки массивов соответствуют объектам классов:
        \begin{verbatim}
cells = objectsOfClass
\end{verbatim}

%                \vspace*{-6pt}

        Для любой ячейки значения ее измерений и определенных атрибутов 
совпадают со значениями соответствующих атрибутов объекта, 
соответствующего ячейке:
        \begin{verbatim}
!(cell, dim).(cell: NAT & dim: NAT & 
  (cell |-> dim): dom(dimensionValue) =>
  cell: dom(integerAttributeValue(dim)) &
  dimensionValue(cell, dim) = 
    integerAttributeValue(dim)(cell)) &
!(cell, cattr).(cell: NAT & cattr: NAT & 
   (cell |-> cattr): 
   dom(integerCellAttributeValue) =>
   cell: dom(integerAttributeValue(cattr)) &
   integerCellAttributeValue(cell, cattr) =
     integerAttributeValue(cattr)(cell) )
        \end{verbatim}
        
                        \vspace*{-6pt}
        
        Для указания того, что машина {\sf ArrayDM} уточняет машину 
{\sf ObjectDM}, в машину {\sf ArrayDM} была добавлена директива
        \begin{verbatim}
REFINES ObjectDM
\end{verbatim}

%                \vspace*{-6pt}

        Спецификации {\sf ObjectDM} и {\sf ArrayDM} вместе с инвариантом 
уточнения были загружены в инструментальное средство 
        Atelier~B~\cite{22-stu}. Автоматически были сгенерированы теоремы, 
выражающие уточнение спецификаций. В~частности, для операции {\sf update} 
были сгенерированы 10~тео\-рем. Три из них были доказаны автоматически, 
для доказательства остальных необходимо применять интерактивные средства 
доказательства.

\vspace*{-9pt}
  
\section{Родственные исследования и~направления дальнейшей 
работы}

\vspace*{-2pt}

        Родственными данной работе следует считать исследования, связанные с 
отображением моделей, основанных на многомерных массивах, в реляционную 
модель данных. Обычно они нацелены на реализацию многомерных массивов 
при помощи реляционных СУБД. Такие работы начались одновременно с 
исследованиями моделей, основанных на многомерных массивах~\cite{5-stu}, и 
продолжаются в настоящее время~\cite{23-stu}.
        
        Основные особенности данной работы состоят в следующем. 
В~качестве исходной модели при отображении используется специфическая 
модель, основанная на многомерных массивах СУБД SciDB, язык которой 
представляет собой комбинацию декларативного SQL-по\-доб\-но\-го языка и 
функционального языка, включающего специфические\linebreak операции над 
многомерными массивами. В~качестве целевой модели используется объектная 
модель с Datalog-по\-доб\-ным языком запросов (программ)~--- язык СИНТЕЗ. 
Для отображения\linebreak обеспечивается формальное доказательство сохранения 
информации и семантики операций ЯМД.
        
        Отметим, что результаты работы могут быть с легкостью обобщены и 
использованы при интеграции в системах, использующих каноническую 
модель, отличную от языка СИНТЕЗ, например другую объектную (ODMG) 
или объект\-но-ре\-ля\-ци\-он\-ную модель (SQL:2003). Результаты также могут 
быть использованы для интеграции ресурсов, представленных в модели, 
основанной на многомерных массивах, но отличной от ADM.
        
        Некоторые вопросы отображения требуют дальнейших исследований. 
Например, следует ли иметь в канонической модели при интеграции 
        масс\-сив-ори\-ен\-ти\-ро\-ван\-ных моделей данных операции, 
связанные с размером порции (chunk size) данных в БД~\cite{9-stu}?
        
        Дальнейшую работу можно разбить на два этапа:
        \begin{enumerate}[(1)]
\item расширение инструментальных средств поддержки предметных 
посредников для виртуальной интеграции SciDB-ресурсов: 
\begin{itemize}
\item[(а)] расширение средств регистрации ресурсов в посреднике~\cite{10-stu} 
трансформацией ЯОД\ ADM в каноническую модель; 
\item[(б)] создание 
SciDB-адап\-те\-ра~--- специального ПО, связывающего исполнительную 
среду посредников с SciDB-ресурсами (составной частью адаптера является 
разработанная трансформация ЯМД);
\end{itemize}
\item применение технологии предметных посредников для решения 
научных задач в некоторой предметной области над множеством\linebreak 
неоднородных ресурсов, включающим SciDB-ре\-сурсы.
\end{enumerate}

\bigskip
        Автор выражает благодарность Л.\,А.~Калиниченко, П.\,Е.~Велихову и 
А.\,Е.~Вовченко за полезные замечания, высказанные в ходе обсуждения 
данной работы на семинарах ИПИ РАН.

\vspace*{-6pt}

{\small\frenchspacing
{%\baselineskip=10.8pt
\addcontentsline{toc}{section}{Литература}
\begin{thebibliography}{99}

\vspace*{-2pt}

\bibitem{1-stu} %1
Challenges and opportunities with big data~// A~community white paper developed 
by leading researchers across the United States, 2012. {\sf http://cra.org/ccc/docs/ init/bigdatawhitepaper.pdf}. 

\bibitem{1-2-stu} %2
\Au{Abrial J.-R.} The B-Book: Assigning programs to 
meanings.~--- Cambridge: Cambridge University Press, 1996. 

\bibitem{2-stu} %3
\Au{Vassiliadis P., Sellis T.\,K.} A~survey of logical models for OLAP databases~// SIGMOD 
Record, 1999. Vol.~28. No.\,4. P.~64--69. 

\bibitem{3-stu}
\Au{Pedersen T.\,B., Jensen C.\,S.} Multidimensional database technology~// IEEE Computer, 
2001. Vol.~34. No.\,12. P.~40--46. 

\bibitem{4-stu} %5
\Au{Libkin L., Machlin R., Wong~L.} A~query language for multidimensional arrays: Design, 
implementation, and optimization techniques.~--- SIGMOD, 1996. P.~228--239. 
\bibitem{5-stu} %6
\Au{Baumann P.} A~database array algebra for spatio-temporal data and beyond~// Next 
generation information technologies and systems. Lectures notes in computer science ser.
Springer Verlag KG, 1999. Vol.~1649. P.~76--93.
\bibitem{6-stu} %7
Overview of SciDB: Large scale array storage, processing and analysis. The SciDB development 
team.~--- SIGMOD, 2010. 
\bibitem{7-stu}
Large synoptic survey telescope. {\sf http://www.lsst.org}. 
\bibitem{8-stu}
\Au{Becla J., Lim K.-T.} Report from the First Workshop on Extremely Large Databases~// Data 
Sci.~J., 2008. Vol.~7.
\bibitem{9-stu}
SciDB User's Guide. Version~12.3, 2012. {\sf http:// www.scidb.org}.
\bibitem{10-stu}
\Au{Kalinichenko L.\,A., Briukhov D.\,O., Martynov~D.\,O., Skvortsov~N.\,A., Stupnikov~S.\,A.} 
Mediation framework for enterprise information system infrastructures~// Volume Databases and 
Information Systems Integration: 9th Conference (International) on Enterprise Information 
Systems (ICEIS 2007) Proceedings ~--- Funchal, 2007. P.~246--251.
\bibitem{11-stu}
\Au{Захаров В.\,Н., Калиниченко Л.\,А., Соколов~И.\,А., Ступников~С.\,А.} Конструирование 
канонических информационных моделей для интегрированных информационных 
сис\-тем~// Информатика и её применения, 2007. Т.~1. Вып.~2. C.~15--38. 
\bibitem{12-stu}
\Au{Kalinichenko L.\,A., Stupnikov S.\,A.} Heterogeneous information model unification as a 
prerequisite to resource schema mapping~// Information Systems: People, Organizations, 
Institutions, and Technologies: 5th Conference of the Italian Chapter of Association for 
Information Systems itAIS Proceedings.~--- Berlin--Heidelberg: Springer Physica Verlag, 2010. 
P.~373--380. 
\bibitem{13-stu}
\Au{Kalinichenko L.\,A., Stupnikov S.\,A., Martynov~D.\,O.} SYNTHESIS: A~language for 
canonical information modeling and mediator definition for problem solving in heterogeneous 
information resource environments.~--- Moscow: IPI RAN, 2007. 171~p. 
\bibitem{14-stu}
\Au{Брюхов Д.\,О., Вовченко А.\,Е., Захаров~В.\,Н., Желенкова~О.\,П., Калиниченко~Л.\,А., 
Мартынов~Д.\,О., Скворцов~Н.\,А., Ступников~С.\,А.} Архитектура промежуточного слоя 
предметных посредников для решения \mbox{задач} над множеством интегрируемых 
неоднородных распределенных информационных ресурсов в гиб\-рид\-ной 
грид-ин\-фра\-струк\-ту\-ре виртуальных обсерваторий~// Информатика и её применения, 
2008. Т.~2. Вып.~1. С.~2--34. 

\bibitem{15-stu} %16
\Au{Kersten M.\,L., Zhang~Y., Ivanova~M., Nes~N.} SciQL, a query language for science 
applications~// EDBT/ICDT~--- Workshop on Array Databases 2011 Proceedings.~--- Uppsala, 
Sweden, 2011. P.~1--12.

\bibitem{16-stu} %17
\Au{Abrial J.-R.} The B-Book: Assigning programs to meanings.~--- Cambridge: Cambridge 
University Press, 1996.
\bibitem{17-stu} %18
Astronomy in ArrayDB. 
{\sf http://trac.scidb.org/\linebreak raw-attachment/wiki/UseCases/Astronomy\%20in\%20\linebreak
ArrayDB.pdf }
\bibitem{18-stu} %19
ATL Project. {\sf http://www.eclipse.org/m2m/atl}.
\bibitem{19-stu} %20
\Au{Budinsky F., Steinberg D., Ellersick~R., Grose~T.}
Eclipse modeling framework. Ch.~5: Ecore modeling concepts.~--- Addison Wesley 
Professional, 2004.
\bibitem{20-stu} %21
Meta Object Facility (MOF) 2.0 Core Specification, 2003. 
{\sf http://www.omg.org/cgi-bin/apps/doc?ptc/\linebreak 03-10-04.pdf}. 
\bibitem{21-stu} %22
\Au{Kalinichenko L.\,A.} Method for data models integration in the common paradigm~//  1st 
East-European Symposium on Advances in Databases and Information Systems \mbox{ADBIS'97} 
Proceedings.~--- St.-Petersburg: Nevsky Dialect, 1997. Vol.~1: Regular papers. P.~275--284.
\bibitem{22-stu}
Atelier~B: The industrial tool to efficiently deploy the B Method. 
{\sf http://www.atelierb.eu/index-en.php}.

\label{end\stat}

\bibitem{23-stu} %24
\Au{Van Ballegooij A.} RAM: Array database management through relational mapping~// SIKS 
Dissertation ser. No.\,2009-25. {\sf http://oai.cwi.nl/oai/asset/14074/ 14074D.pdf}.
         
\end{thebibliography}
} }

\end{multicols}