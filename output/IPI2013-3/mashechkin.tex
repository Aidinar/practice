\def\stat{mashechkin}

\def\tit{МЕТОДЫ АКТИВНОЙ АУТЕНТИФИКАЦИИ НА ОСНОВЕ АНАЛИЗА ДИНАМИКИ РАБОТЫ ПОЛЬЗОВАТЕЛЕЙ 
С~КЛАВИАТУРОЙ}

\def\titkol{Методы активной аутентификации на основе анализа динамики работы пользователей 
с клавиатурой}

\def\autkol{В.\,Ю.~Каганов, А.\,К.~Королёв, М.\,Н.~Крылов и др.}

\def\aut{В.\,Ю.~Каганов$^1$,  А.\,К.~Королёв$^2$, М.\,Н.~Крылов$^3$,
    И.\,В.~Машечкин$^4$,  М.\,И.~Петровский$^5$}

\titel{\tit}{\aut}{\autkol}{\titkol}

%{\renewcommand{\thefootnote}{\fnsymbol{footnote}}\footnotetext[1] {Работа 
%выполнена при поддержке РФФИ (проект 11-07-00402-а). Статья рекомендована к 
%публикации в журнале Программным комитетом конференции <<Электронные 
%библиотеки: перспективные методы и технологии, электронные коллекции>> 
%(RCDL-2012).}}

\renewcommand{\thefootnote}{\arabic{footnote}}

\footnotetext[1]{Московский государственный 
университет им.\ М.\,В.~Ломоносова, факультет вычислительной математики и 
кибернетики, vladhid@mlab.cs.msu.su} 
\footnotetext[2]{Московский 
государственный университет им.\ М.\,В.~Ломоносова, факультет вычислительной 
математики и кибернетики, akorolev@mlab.cs.msu.su} 
\footnotetext[3]{Московский государственный университет им.\ М.\,В.~Ломоносова, 
факультет вычислительной математики и кибернетики, 
krylovm@mlab.cs.msu.su} 
\footnotetext[4]{Московский государственный 
университет им.\ М.\,В.~Ломоносова, факультет вычислительной математики и 
кибернетики, mash@cs.msu.su} 
\footnotetext[5]{Московский 
государственный университет им.\ М.\,В.~Ломоносова, факультет вычислительной 
математики и кибернетики, michael@cs.msu.su}

\vspace*{-6pt}

\Abst{Проведен обзор некоторых эффективных методов аутентификации на основе 
поведенческих моделей пользователей, построенных с использованием данных, 
полученных при анализе работы пользователя с клавиатурой. Также предложен новый 
подход к представлению собираемых данных, проведены эксперименты с 
использованием этого представления и различных алгоритмов машинного обучения.}

\vspace*{-2pt}


\KW{аутентификация; машинное обучение; деревья
решений; клавиатура; потенциальные функции; поведенческий анализ}

            \vspace*{-5pt}


\vskip 14pt plus 9pt minus 6pt

      \thispagestyle{headings}

      \begin{multicols}{2}

            \label{st\stat}
            

            
\section{Введение}

В большинстве современных информационных систем одной из важнейших
задач, помимо сохранения и обработки данных, является задача
разграничения доступа к ресурсам. Это необходимо как для
предотвращения несанкционированного доступа к сис\-те\-мам извне, так и
для разграничения прав сотрудников, работающих с информационной
сис\-те\-мой внутри организации. Поэтому задача аутентификации, т.\,е.\
проверки подлинности пользователя, желающего получить доступ к
системе, является одной из ключевых.

В настоящее время эта задача может быть решена множеством различных
способов. Пожалуй, самый популярный способ из тех, что используются
в современных информационных системах,~--- это аутентификация по
паролю~--- специальной последовательности символов, не известной
никому, кроме пользователя, которому разрешен доступ к системе.
Помимо очевидных преимуществ, таких как простота реализации и
использования, а также распространенность, у нее есть и существенные
недостатки: сама кодовая фраза может быть забыта, передана другим
лицам, а при недостаточной длине или сложности --- подобрана простым
перебором или перебором по словарю, что ставит под сомнение
возможность их использования в системах, требующих высшего уровня
безопасности.

От последнего недостатка свободны системы электронно-цифровых
подписей (ЭЦП), также применяемых для аутентификации. Однако
проб\-ле\-му безопасного хранения закрытых ключей таким образом решить
невозможно.

В связи с вышесказанным значительная часть систем, обеспечивающих
эффективную безопасность, использует биометрию для определения
личности пользователя. Биометрические комплексы могут быть разделены
на две категории:
\begin{enumerate}[(1)]
    \item системы, которые используют различные в силу естественных причин особенности 
    человека, такие как отпечатки пальцев, сетчатка глаза, голос, тепловая карта тела 
    и~т.~п. Они эффективны, но довольно дороги, так как требуют установки специального оборудования;
    \item cистемы, которые анализируют поведение пользователя и основаны на 
    опыте или особых навыках. Они не требуют какого-либо специального оборудования и 
    просты для внедрения. Один из таких подходов -- анализ динамики нажатий клавиш.
\end{enumerate}

В этой статье будут рассмотрены подходы к аутентификации
пользователя по различным моделям, построенным на информации о
нажатиях клавиш.

\section{Постановка задачи}

\subsection{Способы аутентификации}
В рамках проблемы рассматриваются сле\-ду\-ющие методы анализа динамики нажатий клавиш пользователем:
\begin{itemize}
    \item \textbf{статическая аутентификация при входе.} Анализ основывается на известном шаблоне, слове или другом заранее предопределенном тексте. Набираемые пользователем при входе данные собираются (например, при вводе пароля) и сравниваются с предшествующими удачными попытками входа. Данный подход рассматривается как расширение стандартного метода аутентификации при входе с использованием логина/пароля (т.~е. при входе в систему проверяется не только \textit{что} набрал пользователь, но и \textit{как} он это сделал). Стоит отметить следующие особенности статической аутентификации:
    \begin{itemize}\label{goal}
        \item {\bf небольшое количество входных данных.} Как правило, статическая аутентификация работает в паре с аутентификацией по паролю, а использование чрезвычайно длинных паролей, которые пользователь набирал бы вручную (более 100 символов), практически исключено;
        \item {\bf однообразие данных.} Один и тот же пароль, как правило, используется 
        для входа в сис\-те\-му множество раз, и из набора этого пароля можно извлечь лишь небольшое количество признаков. Таким образом, метод должен быть оптимизирован для распознавания пользователя по небольшому множеству параметров;
         \item {\bf высокая скорость работы.} В~случае статической аутентификации нет возможности проводить обработку данных для аутентификации параллельно с работой пользователя. До тех пор пока аутентификация не завершится успешно, пользователь не будет допущен к работе с системой. Поэтому необходимо сделать задержку между вводом пароля и входом в систему как можно меньшей.
    \end{itemize}

    \item \textbf{периодическая динамическая аутентификация.} В~динамических методах 
    происходит аутентификация пользователя по его работе с клавиатурой \textit{во время} 
    сессии работы с системой. В~данном случае процесс проверки пользователя\linebreak \mbox{может} 
    запускаться по какому-либо событию, например по времени или при обнаружении 
    потенциально подозрительной активности. Собранные в рамках сессии данные сравниваются с поведением пользователя в предшествующих сессиях для выявления аномалий. Данный метод имеет ряд преимуществ перед статическим анализом. Во-первых, набираемый текст может быть произвольным -- анализируется только то, \textit{как} пользователь его набирает. Во-вторых, такие данные значительно проще собрать: в общем случае они собираются в фоновом режиме при обычной работе пользователя. Таким образом обучить систему значительно проще и, кроме того, на большом массиве данных даже у неопытного пользователя проще выделить характерные признаки;
    \item \textbf{непрерывная динамическая аутентификация.} Является дополнением 
    периодической аутентификации в том, что проверка подлинности запускается в 
    фоновом режиме и выполняется постоянно (с точностью до минимальной порции данных, 
    на которой возможна корректная работа алгоритма классификации).
\end{itemize}

\subsection{Формальная постановка задачи}
Для всех перечисленных способов формальная постановка задачи звучит одинаково.

Пусть задано некоторое множество {\it пользователей} $ \mathfrak{U}
\hm= \{U_1, U_2, \ldots , U_n\}$. Также введем понятие {\it действия}
пользователя $A$, которым может считаться, например, нажатие одной
клавиши или набор пароля. Задача обучения в этом случае заключается
в том, чтобы  каждому пользователю $U_i\hm \in \mathfrak{U} $
сопоставить некоторую функцию (модель) $F_i$, которая может служить
мерой аномальности действия $A^{\mathrm{next}}_i$ для пользователя
$U_i$. В таком случае задача аутентификации~--- это вычисление
$F_i(A^{\mathrm{next}}_i)$ и обработка полученного значения, по
которому принимается решение об успешности аутентификации
пользователя $U_i$.

\section{Обзор существующих методов статической аутентификации}

Интересным представляется множество подходов, описанных в статье~\cite{lao}. 
Из них стоит выделить 4~эксперимента, проведенных
авторами статьи, которые были направлены на оценку качества тех или
иных моделей представления данных.

\subsection{Модель, основанная на~измерении времени удержания}\label{hold}

Одним из наиболее существенных признаков, извлекаемых из данных о
динамике работы пользователя с клавиатурой, является время удержания
пользователем различных кнопок в нажатом состоянии. Априори
предполагается, что у разных пользователей эти времена будут заметно
различаться, и по величине отклонения этого времени можно будет
установить аномальность действия $A_i^{\mathrm{next}}$.

В этом методе в качестве модели берется вектор~$X$ из $n$ элементов,
каждый из которых соответствует одной кнопке на клавиатуре и
является парой $(M_k, D_k)$: элемент $M_k$~--- среднее время
удержания клавиши $k$, а $D_k$~--- величина стандартного отклонения
для клавиши $k$.

Таким образом, действие пользователя $A^{\mathrm{next}}_i$ --- время
удержания некоторой клавиши~$K$ -- признается аномальным, если оно
отличается от среднего $M_K$ на величину, б$\acute{\mbox{о}}$льшую~$D_K$. Для модели
задается процент допустимых аномальных действий, и при превышении
этого порога аутентификация признается неуспешной.

\subsubsection{Постановка эксперимента}
Для проверки пригодности вышеописанной модели был поставлен
эксперимент. В~нем участвовало 15~человек, каждый из которых 10 раз
набирал английскую панграмму (фразу, содержащую все буквы алфавита)
<<{\sf The quick brown fox jumps over the lazy dog}>>. На этих
данных были построены модели, и для достижения наилучших результатов
была произведена вариация порогового значения допустимых аномальных
действий.

\subsubsection{Оценка результата}\label{shortres}
Для оценки результатов в этом и других экспериментах использовалось
вычисление величин:
\begin{itemize}
    \item False Rejection Rate (FRR)~--- процент нажатий пользователя, на  котором система обучена, воспринятые системой как нажатия другого пользователя (ошибка 1-го рода);
    \item  False Acceptance Rate (FAR)~--- процент нажатий другого пользователя, которые система определила как нажатия пользователя, на котором обучена (ошибка 2-го рода).
\end{itemize}



На эти признаки влияют два параметра:
\begin{enumerate}[(1)]
\item требуемая доля неаномальных нажатий для признания попытки авторизации успешной;
\item % и
допустимое для признания нажатия неаномальным количество стандартных отклонений продолжительности нажатия 
в модели.
\end{enumerate}
 Зависимость величин FRR и FAR от них отражают табл.~1 и~2.
Легко увидеть, что наилучшие результаты этим методом
достигаются при требовании попадания 75\%--80\% нажатий в границы двух
стан-\linebreak\vspace*{-12pt}
\begin{center}  %tabl1-2
% \vspace*{6pt}
{{\tablename~1}\ \ \small{False Acceptance Rate}}

\vspace*{6pt}

%\pagebreak


%\begin{table*}
{\small
%\begin{center}
\tabcolsep=4.1pt
\begin{tabular}{|c|c|c|c|c|}
\hline
        Доля неаномальных   &\multicolumn{4}{c|}{ Продолжительность нажатия}\\
         \cline{2-5}
 нажатий& \ \ \ 1,0\ \ \  & \ \ \ 1,5 \ \ \  & \ \ \ 2,0 \ \ \   & 2,5     \\
                \hline
                0,75 & 0\% & 0,61\% & 8,26\% & 25,0\%\hphantom{9}  \\
    %            \hline
                    0,80 & 0\% & 0\%\hphantom{9,9}    & 3,45\% & 16,79\% \\
     %           \hline
                0,85 & 0\% & 0\%\hphantom{9,9}    & 1,01\% & \hphantom{9}7,39\%  \\
      %          \hline
                0,90 & 0\% & 0\%\hphantom{9,9}    & 0\%\hphantom{,99}    & \hphantom{9}2,01\%  \\
                                \hline
                \end{tabular}
 %           \end{center}
%        \end{table*}

}

\vspace*{6pt}

{{\tablename~2}\ \ \small{False Rejection Rate}}

\vspace*{6pt}
        

%        \begin{table*}\small
 
{\small                \tabcolsep=1.5pt
                \begin{tabular}{|c|c|c|c|c|}
                               \hline
        Доля неаномальных   &\multicolumn{4}{c|}{ Продолжительность нажатия}\\
         \cline{2-5}
 нажатий& \ \ \ 1,0\ \ \  & \ \ \ 1,5 \ \ \  & \ \ \ 2,0 \ \ \   & 2,5     \\
                \hline
                    0,75 & 96,35\% & 31,41\% & \hphantom{9}1,25\%  & 0\%\hphantom{,99}  \\
 %                   \hline
                    0,80 & 99,43\% & 52,47\% & \hphantom{9}8,95\%  & 0\%\hphantom{,99} \\
  %                  \hline
                    0,85 & 100\%\hphantom{,999}   & 84,85\% & 24,16\% & 4,03\%  \\
   %                 \hline
                    0,90 & 100\%\hphantom{,999}   & 94,97\% & 64,01\% & 19,59\%\hphantom{9} \\
                                    \hline
                \end{tabular}
                }
            \end{center}
%\end{table*}

        \addtocounter{table}{2}
        
        \vspace*{6pt}


\noindent
дартных отклонений от среднего значения, что позволяет получить
результат 3,45\% FAR и 8,95\% FRR. Для такого сравнительно
несложного подхода их следует признать достаточно высокими.

\vspace*{-4pt}

\subsection {Наблюдение за порядком нажатия и~отпускания кнопок}

\vspace*{-2pt}

\subsubsection{Модель и метод}

Назовем {\bf <<обменом>> (<<swap>>)} такую па\-ру нажатий и отпусканий, 
которые происходят в непрямом порядке:

\vspace*{-18pt}

   \hspace*{-10pt}{ \begin{picture}(224, 100)
        \put(0,10){\vector(1,0){220}} \put(100,20){<<обмен>>}
        \put(30,10){\circle*{2}} \put(20,0){$\downarrow a$}
        \put(90,10){\circle*{2}} \put(80,0){$\downarrow b$}
        \put(150,10){\circle*{2}} \put(140,0){$\uparrow a$}
        \put(210,10){\circle*{2}} \put(200,0){$\uparrow b$}
        \put(0,60){\vector(1,0){220}} \put(60, 70){обычный порядок нажатий}
        \put(30,60){\circle*{2}} \put(20,50){$\downarrow a$}
        \put(90,60){\circle*{2}} \put(80,50){$\uparrow a$}
        \put(150,60){\circle*{2}} \put(140,50){$\downarrow b$}
        \put(210,60){\circle*{2}} \put(200,50){$\uparrow b$}
    \end{picture}}
    
    \vspace*{6pt}
    
\noindent
Так, при обычном порядке нажатий сначала нажимается кнопка~$a$,
затем она отпускается, затем нажимается кнопка~$b$, затем $b$
отпускается. Было замечено, что некоторые люди при наборе слов
непроизвольно меняют этот порядок, нажимая кнопку~$a$, затем, не
отпуская ее, кнопку~$b$, затем отпускают обе.

Идея метода, описываемого в этой части, заключается в учете подобных
<<обменов>> для определения аномальности действий пользователя.

Пусть задана последовательность нажатий и отпусканий~$S$,
представляющая собой действия пользователя для аутентификации. Для
нее можно вычислить количество таких <<обменов>>~$x_S$ и ввести
расстояние между двумя последовательностями~$S_1$ и~$S_2$ как
$|x_{S_1}\hm - x_{S_2}|$.

Для каждого пользователя вычислим расстояния между каждой парой его
наборов, посчитаем среднее и стандартное отклонение. Эти два числа
будут служить моделью для пользователя.

\subsubsection{Эксперимент}

Для эксперимента использовались те же данные, что и в подразд.~3.1,
однако не учитывались клавиши {\sf Shift} и~{\sf Delete}, для
того чтобы не вносить излишний шум в результаты. Для обучения была
использована треть собранных данных, для тестирования --- две трети.

\subsubsection{Результаты}

Для того чтобы получить оценку аномаль\-ности, дистанция между
тестируемым и пользовательским набором сравнивалась со средней
дистанцией между наборами одного и того же пользователя, и при выходе
значения дистанции за пределы одного стандартного отклонения попытка
авторизации признавалась неудачной.

Было выяснено, что значения FAR и FRR для результатов применения
этого метода сильно зависят от пар пользователей, в экспериментах
проявлялись доли ошибок от 0\% до 70\%, что не позволяет признать
этот метод подходящим для использования в одиночку. Полагается, что
длина текста недостаточна для такого подхода, и предлагается
усовершенствование метода путем учета того, на каких парах клавиш
происходят <<обмены>>.

\subsection{Относительная скорость печати}

Существует предположение, что на разных текстах абсолютная скорость
печати пользователя варь\-и\-ру\-ет\-ся в широких пределах (к примеру,
осмыс\-лен\-ный текст человек будет набирать быстрее, чем случайные
символы), однако для каждой пары кнопок скорость нажатий остается
примерно одинаковой. Поэтому высказывается предложение замерять
скорости набора пар кнопок и использовать их в качестве модели для
пользователя.

Пусть $S$ и $S'$~--- векторы пар кнопок, упорядоченных по скорости
набора. Пусть $S[i]$ и $S'[i]$~--- положения пары кнопок~$i$ в
векторах $S$ и $S'$ соответственно. Тогда расстояние между этими
двумя векторами вводится следующим образом: $\sum\limits_i |S[i] \hm-
S'[i]|$. Для нормировки предлагается делить расстояние на количество
элементов в векторах, тогда расстояния между более полными
(содержащими большее количество пар) векторами не будут резко
отличаться от расстояний между векторами, содержащими меньшее число
пар.

Следующие результаты были получены вариацией порогового значения
расстояния между тес\-ти\-ру\-емым и известным значениями вектора,
необходимого для признания аутентификации удачной, на данных
эксперимента, описанного в подразд.~3.1:
\begin{itemize}
    \item расстояния между двумя векторами одного и того же пользователя составили в 
    среднем 0,3192, расстояние между векторами разных пользователей~--- в среднем~0,529;
    \item стандартные отклонения расстояний между двумя векторами отличались незначительно.
\end{itemize}

Однако точно судить об успешности аутентификации пользователя можно
только при различии в векторах, меньшем 0,3, а о неуспешности~--- при
различии, большем 0,6.

\subsection{Использование правой и левой клавиш {\sf Shift}}\label{shift}

Гипотетически предполагается, что при наборе текста разные люди
используют правую и левую клавиши {\sf Shift} по-разному.
Вероятно, это можно использовать для аутентификации.

Для проверки этой гипотезы предлагается модель пользователя,
состоящая из пар вида $(x, L), (y, L), (z, R)$, где первый элемент
каждой пары~--- нажатая клавиша, а второй -- элемент из множества
$\{L,R\}$, соответствующий правой или левой кнопке {\sf Shift}, с
которым была нажата клавиша, соответствующая первому элементу.

Для эксперимента использовалась фраза, набранная каждым
пользователем по 5~раз и содержащая все заглавные буквы английского
алфавита: <<{\sf Another Quick Brown Fox Jumps Over The Lazy Dog
Yet Round Cats Eat Plain Goldfish Heartily In Maine Not Kansas Under
Some Vain Zealous Xena Warrior}>>.

По собранным данным 15 пользователей были разделены на 4~класса: 8 из них
 пользовались только левой клавишей {\sf Shift}; четверо~---
только правой; двое использовали левую клавишу чаще правой; еще
один~--- правую чаще левой.

Очевидно, только класса пользователя недостаточно, чтобы признать
аутентификацию успешной. Однако попадание в чужой класс дает весомое
основание отвергнуть попытку аутентификации. (Здесь не берется в
расчет тот факт, что клавиатура пользователя может выйти из строя.)




\subsection{Об одном из методов для~коротких буквенных или~цифровых паролей}

\subsubsection{Предлагаемый метод и~модель данных}

Одной из особенностей cтатической аутентификации, о которой было
упомянуто в подразд.~2.1, являлся небольшой объем входных данных. 
В~случае использования учета динамики нажатий клавиш совместно с
паролем это несложно обосновать: чем короче пароль, тем легче он
набирается пользователем; с увеличением длины пароля растет и
вероятность опечаток, ведущих к необходимости повторного набора.
Также было упомянуто небольшое число признаков: как правило, в
пароле содержится небольшое подмножество символов, бук\-вен\-но-циф\-ро\-вых
(в случае пароля для входа в сис\-те\-му) либо только цифровых (таким
образом устроены PIN-ко\-ды в банкоматах). Из этого следует, что
необходимо разрабатывать способы аутентификации с учетом ограничений
по длине и разнообразию символов.

Интересным в этом свете представляется подход, описанный в статье~\cite{saggio}. 
В~качестве модели авторами были взяты замеры
продолжительности нажатий клавиш, однако вычислялись они тремя
разными способами:
\begin{enumerate}[(1)]
    \item {\bf абсолютное время нажатия}. 
    В~качестве элементов вектора берутся времена удержаний клавиш и времена, 
    когда не нажата ни одна клавиша по отдельности;
    \item {\bf кумулятивное время удержания}. Аналогично предыдущему, однако 
    замеряемые времена аккумулируются, что позволяет сгладить вы\-бросы;
    \item {\bf использование отношения задержек}. В~векторе в качестве значения элемента, 
    соответствующего нажатию, берется отношение времени удержания к продолжительности 
    последующего за ним промежутка, когда не нажата ни одна клавиша.
\end{enumerate}
В качестве алгоритма, с помощью которого осуществлялось обучение,
был взят мультиклассовый линейный SVM (support vector machine)~\cite{svm}, так как он
демонстрирует высокие результаты на данных несложной структуры.

\subsubsection{Постановка эксперимента
}
Для участия в эксперименте были приглашены 16~человек, 8 из которых
были {\it информированы} о проводимом эксперименте, а другие 8~---
нет. Во избежание нежелательного искажения результатов
непреднамеренной тренировкой 300 попыток были разбиты на 10~дней, по
30~попыток набора ежед\-невно.

Одна попытка представляла собой набор слова <<{\sf special}>> в
случае буквенного пароля и число <<{\sf 12057}>> в случае
цифрового, что соответствовало средней длине пароля пользователя при
входе в систему и длине PIN-ко\-да. При опечатке в наборе попытка не
засчитывалась, это обосновано тем, что, как правило, при наборе
пароли и PIN-коды не видны пользователю и опечатка приведет к ошибке
при аутентификации.

\subsubsection{Результаты}

Для оценки результатов применялись те же способы, что и в
п.\,3.1.2. Значения параметров FAR и FRR приведены в табл.~3
и~4.


       
В строках таблиц отражен метод замера времени, в столбцах~--- 
результаты по данным, полученным
от информированных и неинформированных пользователей.

Несложно заметить, что процент ошибок сильно (в разы) зависит от
информированности пользователей и метод замера отношений несколько
более эффективен, нежели два прочих.

\vspace*{6pt}

\begin{center}  %tabl3-4
% \vspace*{6pt}
{{\tablename~3}\ \ \small{Буквенный пароль}}

\vspace*{6pt}


{\small
%\begin{center}
\begin{tabular}{|c|c|c|c|c|}  
\hline
\multicolumn{1}{|c|}{\raisebox{-6pt}[0pt][0pt]
{\tabcolsep=0pt\begin{tabular}{c} Метод\\ замера\end{tabular}}} &\multicolumn{2}{c|}{\tabcolsep=0pt\begin{tabular}{c}
Неинформи-\\рованные\\ пользователи\end{tabular}}&
\multicolumn{2}{c|}{\tabcolsep=0pt\begin{tabular}{c}Информи-\\ рованные\\
пользователи\end{tabular}}\\
\cline{2-5}
 & FAR & FRR & FAR & FRR \\
\hline
Абсолютный   & 6,82\%   & 12,30\% & 1,59\%  & 3,82\% \\
%                \hline
Кумулятивный & 5,92\%   & 11,43\% & 1,32\%  & 3,15\% \\
%               \hline
Отношений      & 6,73\%   & 11,69\% & 0,91\%  & 2,31\%\\
\hline
\end{tabular}

}

\vspace*{12pt}

{{\tablename~4}\ \ \small{Цифровой пароль}}

\vspace*{6pt}
        
{\small         
\begin{tabular}{|c|c|c|c|c|}
\hline
\multicolumn{1}{|c|}{\raisebox{-6pt}[0pt][0pt]
{\tabcolsep=0pt\begin{tabular}{c}Метод\\ замера\end{tabular}}} &\multicolumn{2}{c|}{\tabcolsep=0pt\begin{tabular}{c}
Неинформи-\\рованные\\ пользователи\end{tabular}}&
\multicolumn{2}{c|}{\tabcolsep=0pt\begin{tabular}{c}Информи-\\ рованные\\
пользователи\end{tabular}}\\
\cline{2-5}
& FAR & FRR & FAR & FRR \\
\hline
Абсолютный  & 5,67\%   & 10,36\% & 1,75\%  & 3,21\% \\
%                \hline
Кумулятивный  & 4,93\%   & \hphantom{9}9,69\% & 1,31\%  & 2,58\% \\
%               \hline
Отношений      & 5,10\%   & \hphantom{9}9,92\% & 0,99\%  & 1,92\%\\
\hline
\end{tabular}
   }
\end{center}
            
\vspace*{6pt}

        \addtocounter{table}{2}

 \section{Обзор существующих методов динамической аутентификации}

\subsection{Слияние классификаторов}

В качестве события $A$  будем рассматривать некоторую порцию
данных, например набор одного абзаца или строки. Назовем ее сессией
(не путать с сессией работы с системой). Весь процесс аутентификации
будет рассмотрен именно для сессий, а не для отдельных нажатий
клавиш.

\subsubsection{Формат данных}

В данном методе в качестве регистрируемых данных рассматриваются
задержки между событиями, производимыми клавиатурой. Событие
пред\-став\-ля\-ет собой нажатие или отпускание клавиши. Очевидно, что для
одной и той же пары нажатий можно использовать различные интервалы
времени:
\begin{itemize}
    \item PP (Press--Press): время между двумя последовательными нажатиями клавиш;
    \item PR (Press--Release): время, в течение которого клавиша была нажата;
    \item RP (Release--Press): время между отпусканием предыдущей и нажатием следующей клавиши;
    \item RR (Release--Release): время между двумя последовательными отпусканиями клавиш.
\end{itemize}
Все остальные характеристики, такие как сила нажатия на клавишу 
и~пр., в данном исследовании не рассматриваются, так как могут быть
получены только при помощи дополнительного оборудования. Для анализа
будем использовать совокупность временн$\acute{\mbox{ы}}$х значений PP, PR, RP, RR
для вводимой с клавиатуры последовательности.

\vspace*{-4pt}

\subsubsection{Определение по расстоянию до среднего}

В случае аутентификации часто используется метод~\cite{legett}. Для
формирования профиля пользователя рассчитывается среднее значение~$\mu$ 
и стандартное отклонение~$\sigma$ для всех типов событий. Одно
событие считается корректным, если его значение отличается от
среднего не более чем на половину отклонения. Иными словами, $|t\hm-
\mu| \hm< \alpha  \sigma$. Сессия считается корректной, если доля
корректных событий в ней не менее некоторого порога~$\beta$.

Можно доработать этот метод, адаптируя параметры под каждого
конкретного пользователя~\cite{hocquet}. Например, изначально
установить порог $\beta \hm= 1$ и далее понижать его на заданное
небольшое число, пока считаются корректными все события из
тренировочного набора.

Также вместо того, чтобы непосредственно сравнивать время со
средним, можно использовать взвешенную оценку. Для этого каждому
событию сопоставим оценку (лежащую в интервале $[0,1]$)\linebreak $\mathrm{score} \hm=
\exp ({|t-\mu|/\sigma})$. В~качестве оценки для сессии возьмем
среднее по оценкам, входящим в нее. Это среднее далее и будем
сравнивать с порогом~$\beta$.

\vspace*{-4pt}

\subsubsection{Определение по ритму набора}

Как и в музыке, где ритм определяется как относительная длительность
нот (половина ноты, чет\-верть ноты и~т.\,д.), предлагается рассмотреть
ритм, с которым пользователь набирает текст~\cite{hocquet}. Основная
идея здесь заключается в том, чтобы разделить численные временн$\acute{\mbox{ы}}$е
значения на несколько дискретных классов. Для этого можно
использовать пороговые значения:
\begin{itemize}
    \item $t > 200$: класс 1;\\[-14pt]
    \item $100 <t < 200$: класс 2;\\[-14pt]
    \item $70<t < 100$: класс 3;\\[-14pt]
    \item $30< t < 70$: класс 4;\\[-14pt]
    \item $t>30$: класс 5.
\end{itemize}
Недостаток такого подхода в том, что при использовании статических
порогов не учитывается средняя скорость набора текста пользователем.
Для решения этой проблемы можно классифицировать время внутри одной
сессии в сравнении с остальными интервалами в ней.
\begin{itemize}
    \item ${1}/(10)$ самых медленных: класс~1;
    \item ${1}/{3}$ самых медленных: класс~2;
    \item ${2/}{3}$ самых медленных: класс~3;
    \item ${3}/{4}$ самых медленных: класс~4;
    \item ${1}/{4}$ самых быстрых: класс~5.
\end{itemize}
В качестве профиля пользователя каждому нажатию сопоставляем вектор
классов, к которым отнесены соответствующие временн$\acute{\mbox{ы}}$е интервалы.
Далее над этими векторами вводим дистанцию как сумму разниц между
номерами классов в векторах. Далее, сравнивая эту сумму с порогом,
получаем критерий корректности пользователя.

\subsubsection{Определение по ранжированию времен}

Данный метод используется только для статической аутентификации~\cite{bergadano}. 
Для каждого события считается его ранг (порядковый
номер в отсортированной последовательности тех же значений). 
В~качестве профиля пользователя вычисляется среднее по рангам для
каждого из нажатий (по тестовой выборке). Для того чтобы оценить
сессию, используется коэффициент Спирмана, который считается по
формуле:
$$r_{\mathrm{Sp}} = 1 - \fr{6 \sum\limits_{i=1}^n\left(r_i^1 - r_i^2\right)}{n  (n^2 -1)}\,,
$$
где $r_i^1$ -- ранг $i$-го нажатия в сессии $1$, а $n$~--- количество нажатий в сессии.

\subsubsection{Слияние методов}
Пусть для каждого пользователя имеется три классификатора,
работающих на одних и тех же данных, но оценивающих их различные
характеристики. Для комбинирования их в одном подходе воспользуемся
правилами слияния, описанными в~\cite{kittler}.

Итак, имеется три классификатора, которые решают проблему о
принадлежности к одному из двух классов (корректный
пользователь\,/\,на\-ру\-ши\-тель), возвращающих оценку от~0 до~1. Проблема в
том, что оценки каждого из классификаторов не похожи и по-раз\-но\-му
распределены для одних и тех же наборов данных. В~связи с этим
неэффективно было бы применять любую схему голосования (<<хотя бы
один>>, <<большинство>>, <<все>>). Для этого существует несколько
методов нормализации:
\begin{itemize}
    \item нормализация по максимуму: 
    $$\mathrm{score}'=\fr{\mathrm{score}}{\mathrm{scoreMax}}\,;
    $$
    \item нормализация по максимальной разнице: 
    $$
    \mathrm{score}' = \fr{\mathrm{score - scoreMin}}{\mathrm{scoreMax - scoreMin}}\,;
    $$
    \item Z-мера: 
    $$
    \mathrm{score}'=\fr{|\mathrm{score} - \overline{\mathrm{score}}|}{\sigma_{\mathrm{score}}}\,.
    $$
\end{itemize}

Стоит отметить, что первые два метода нормализации могут привести к
получению значений больше 1 или меньше~0, однако в данном случае это
будет обозначать векторы, крайне близкие или отдаленные от профиля
пользователя.

Все эти оценки требуют предварительного знания о самой выборке, а
также дополнительного расчета (особенно в случае Z-ме\-ры), поэтому
использовать их в реальном времени весьма затруднительно. Можно
использовать методы слияния, описанные в~\cite{kittler}. Для начала
сведем задачу к бинарной классификации с ограничением 
$$
P(\mathrm{user}) = 1 - P(\mathrm{impostor})\,.
$$
Так как нет информации о вероятности, положим
$$
P(\mathrm{user}|i) = \mathrm{Score}^i\,,$$
 где $\mathrm{Score}^i$~--- оценка $i$-го
классификатора. Далее можно использовать следующие операторы
слияния:
\begin{itemize}
    \item максимум и минимум: 
    $$
    \mathrm{Score}= \max\limits_i (\mathrm{Score}^i)\,;
    $$
    \item медиана: 
    $$\mathrm{Score}= \mathrm{MEDIAN}(\mathrm{Score}^i)\,;
    $$
    \item правило произведения: 
    $$
    \mathrm{Score}= \prod\limits_i \mathrm{Score}^i\,;
    $$
    \item правило суммы: 
    $$
    \mathrm{Score}= \sum\limits_i \mathrm{Score}^i\,.
    $$
\end{itemize}

\subsubsection{Результаты}

Для сравнения методов использовались три меры оценки:
\begin{enumerate}[(1)]
    \item FAR~--- процент некорректных пользователей, 
    которые были приняты классификатором (ошибка 2-го рода);
    \item FRR~--- процент корректных пользователей, 
    которые были отвергнуты классификатором (ошибка 1-го рода);
    \item EER (Equal Error Rate)~--- точка, в которой FAR\;=\;FRR.
\end{enumerate}

\begin{center}  %tabl5-7
% \vspace*{6pt}
{{\tablename~5}\ \ \small{Средние ошибки}}

\vspace*{6pt}


{\small
\tabcolsep=5pt
\begin{tabular}{|c|c|c|c|}
\hline
Метод  & FAR      & FRR      & ERR\\
\hline
Расстояние до среднего & 4,39\% & 4,81\% &4,60\%\\
\hline
\tabcolsep=0pt\begin{tabular}{c}Расстояние до среднего\\ (взвешенное)\end{tabular} & 
3,62\% & 3,61\% &3,62\%\\
\hline
Ранжирование по Спирману & 3,56\% & 3,62\% &3,59\%\\
\hline
Ритм набора (по порогам) & 3,47\% & 3,39\% &3,43\%\\
\hline
\tabcolsep=0pt\begin{tabular}{c}Ритм набора\\ (пропорциональный) \end{tabular}& 3,55\% & 4,02\% &3,79\%\\
\hline
\end{tabular}}
 
 \vspace*{9pt}
 
 {{\tablename~6}\ \ \small{Применение нормализации}}

\vspace*{6pt}

{\small
\begin{tabular}{|c|c|c|c|}
\hline
Нормализация  & FAR      & FRR      & ERR\\
\hline
По максимуму & 1,75\% & 2,46\% &2,11\%\\
По максимальной разнице & 2,00\% & 2,00\% &2,00\%\\
Z-мера & 1,81\% & 1,69\% &1,75\%\\
\hline
\end{tabular}
}

\vspace*{6pt}
 
 {{\tablename~7}\ \ \small{Результаты слияния}}

\vspace*{6pt}

{\small
\tabcolsep=4pt
\begin{tabular}{|c|c|c|c|}
\hline
Метод  & FAR      & FRR      & ERR\\
\hline
Голосование (<<все>>) & 1,17\% & 7,92\% &4,55\%\\
Голосование (<<большинство>>) & 2,39\% & 2,15\% &2,27\%\\
Голосование (<<хотя бы один>>) & 7,60\% & 0,54\% &4,07\%\\
Правило произведения & 2,00\% & 2,00\% &2,00\%\\
Правило максимума & 3,62\% & 3,61\% &3,62\%\\
Правило минимума & 3,62\% & 3,62\% &3,62\%\\
Правило медианы & 3,34\% & 3,39\% &3,37\%\\
Правило суммы & 1,81\% & 1,69\% &1,75\%\\
\hline
\end{tabular}
 }
\end{center}

\vspace*{6pt}

Значения этих мер оценки на разных методах приведены в
табл.~5 и~6. Как видно из
табл.~7, наилучший результат для данного метода
достигается при применении правила суммы для результатов трех
исходных классификаторов.



\addtocounter{table}{3}

\subsection{Кластеризация методом Partition Around Medoids}

Сначала рассмотрим алгоритм классификации пользователей, основанный
на кластеризации и представленный в~\cite{bert}.

\subsubsection{Сбор данных и модель представления}

В данной статье был использован набор данных {Si6}~\cite{si6}, 
который состоял из 66~сессий набора 62~различных
пользователей.

Каждая сессия набора состояла из 15~предложений. Для каждой сессии
фиксировалось на\-би\-ра\-емое предложение, время нажатия (или отпускания)
клавиши с точностью до миллисекунд, сама клавиша и тип действия
(нажатие или отпускание).

В эксперименте учитывались только завершенные сессии. Для трех
пользователей, которые набрали несколько сессий, была выбрана только
одна. Также не учитывались ошибочные предложения. После исключения
осталось 54~сессии, каждая из которых состояла из 15 предложений.

Для каждого предложения каждой сессии каж\-до\-го пользователя был
вычислен вектор времени диграфов (время между двумя
последовательными нажатиями на клавиши). Диграфы, содержащие
непечатные символы, были исключены. Рас\-смат\-ри\-ва\-лись оставшиеся
88~946 времен диграфов, соответствующих 411~уникальным
последовательностям из двух клавиш.

Были проведены три различных эксперимента с разной 
группировкой предложений пользователя в подсессии:
%\renewcommand{\labelenumi}{\arabic{enumi})}
\begin{enumerate}[(1)]
    \item 3 подсессии, каждая состояла из 5~предложений;
    \item 5 подсессий, каждая состояла из 3~предложений;
    \item 15 подсессий, каждая состояла из 1~предложения.
\end{enumerate}
Каждая подсессия характеризовалась вектором средних значений всех
различных диграфов, отсортированных по убыванию числа появлений у
всех пользователей.

Количество кластеров для классификации (параметр $k$) было выбрано по алгоритму 
\textit{силуэта}, описанному в~\cite{sil}.

\subsubsection{Фильтрация}

Фильтрация играет значимую роль в процессе интеллектуального анализа данных. 
Были использованы два уровня фильтрации:
\begin{enumerate}[(1)]
    \item при грубой фильтрации были исключены:
    \begin{itemize}
        \item[(а)] диграфы со временем менее 10 и более 750~мс;
        \item[(б)] диграфы, время которых отличалось от среднего времени всех диграфов 
        больше чем на стандартное отклонение времени всех диграфов, т.\,е.\ 
        $140\hm\pm 113~$мс\;$\approx$\;(25~мс, 250~мс).
    \end{itemize}
     Таким образом было исключено около 17\% диграфов;
    \item на этапе более тонкой фильтрации исключались:
    \begin{itemize}
        \item[(а)] диграфы, встречающиеся только один раз;
        \item[(б)] диграфы, у которых стандартное отклонение больше 
        удвоенного среднего стандартного отклонения всех диграфов данной подсессии;
        \item[(в)] из одинаковых диграфов в подсессии исключались те, которые имели 
        время, отличающееся от среднего в данной выборке больше чем на удвоенное 
        стандартное отклонение.
    \end{itemize}
\end{enumerate}

\subsubsection{Результаты}

При оценке качества определение в один клас\-тер двух подсессий,
принадлежащих одному пользователю, являлось верной классификацией\linebreak
(TP~--- true positive). Ложно-положительным (FP~--- false positive)
срабатыванием считалось определение двух подсессий различных
пользователей в один кластер. Лож\-но-от\-ри\-ца\-тель\-ным (FN~--- false
negative)~--- определение двух подсессий одного пользователя в разные
кластеры.

Значение полноты (Precision) было принято равным $\mathrm{TP/(TP +
FP)}$; точности (Recall)~--- $\mathrm{TP/(TP + FN)}$; $F$-ме\-ра: 
$$
F= 2  \fr{\text{Presicion} \cdot
\text{Recall}}{\text{Presicion} + \text{Recall}}\,.
$$

Лучшие значения $F$-меры составили: для разделения сессий на 3~подсессии~--- 0,9, 
на 5~подсессий~--- 0,78, на 15~подсессий~--- 0,26.

\subsection{Относительная скорость печати}

Теперь рассмотрим метод, описанный в~\cite{gunet}. Центральным
понятием здесь является $n$-граф~--- время между первым и последним
нажатием серии из $n$~клавиш.

В нем описывается использование как относительных метрик различия
между сессиями печати, которые учитывают только то, какие $n$-гра\-фы
набираются быстрее других, так и абсолютных, сравнивающих время
набора.

\subsubsection{Относительные метрики ($R$-метрики)}

Для массива $V$ из $k$ чисел можно вычислить степень
неупорядоченности, которая является суммой расстояний между
элементом~$V$ и соответ\-ст\-ву\-ющим элементом упорядоченного массива
$V'$. Так, для массива $A \hm= [2,3,1,4,5]$ степень неупорядоченности
равна $1 \hm+ 1 \hm+ 2 \hm+ 0 \hm+ 0 \hm= 4$.

Получим максимальную степень неупорядоченности массива из $k$ чисел:
    $$
    D_k =
    \begin{cases}
        \fr{k^2}{2}\,,  &\ k \mbox{ --- четное}\,; \\
        \fr{k^2 - 1}{2}\,, &\ k \mbox{ --- нечетное}\,.
    \end{cases}
    $$
Это позволит нормировать неупорядоченность. Так, для массива~$A$ из
примера нормированная неупорядоченность будет равна: 
$$
\fr{1 + 1 + 2+ 0 + 0}{(5^2 - 1) / 2} \hm= \fr{8}{12} = 0{,}6666\,.
$$

Образец печати пользователя $S$ представляет собой массив средних
времен набора $n$-гра\-фов, встречающихся в тексте, отсортированный по
возрастанию. Таким образом, вводится расстояние между двумя
образцами печати $S_1$ и $S_2$. Если у $S_1$ и $S_2$ $k$ общих
$n$-графов, то расстояние $R_n(S_1, S_2)$ равно сумме расстояний
между общими $n$-графами, нормированному на $D_k$. Те $n$-гра\-фы,
которые не принадлежат пересечению $S_1$ и $S_2$, просто
игнорируются.

Заметим, что для небольших наборов данных у двух образцов может не
оказаться общих $n$-гра\-фов, что сделает невозможным вычисление~$R_n$.

Можно предположить, что вычисление относительной метрики между двумя
образцами для диграфов, триграфов или иных $n$-гра\-фов способно
предоставить различные аспекты информации о различии ритмов печати.

Если у образцов $S_1$ и $S_2$ $N$ общих $n$-графов и $M$ общих $m$-гра\-фов ($N \hm> M$), 
вводится кумулятивная относительная метрика:
$$
R_{n, m} = R_n(S_1, S_2) + R_m(S_1, S_2)  \fr{M}{N}\,.
$$
Аналогично можно расширить метрику для применения к большему количеству 
различных $n$-гра\-фов:
$$
R_{n, m} = R_n(S_1, S_2) + R_m(S_1, S_2)  
\fr{M}{N} + R_p(S_1, S_2)  \fr{P}{N}\,.
$$

\subsubsection{Абсолютные метрики ($A$-метрики)}

К сожалению, у $R$-мет\-рик есть существенный недостаток. Если среднее
время каждого $n$-гра\-фа в образце $S_2$ в два раза больше, чем в
образце $S_1$, то $R_n(S_1, S_2) \hm= 0$. Таким образом, относительная
метрика не может отличить двух пользователей, имеющих очень похожие
ритмы печати, пусть даже один из них печатает намного быстрее
другого.

В отличие от $R$-метрик, $A$-мет\-ри\-ки учитывают абсолютное время
набора $n$-графов. Пусть $G_{S_1, d_1}$ и $G_{S_2, d_2}$~--- это один
и тот же $n$-граф, присутствующий в $S_1$ со временем $d_1$ и в
$S_2$ со временем $d_2$. \textit{Похожими} называются $n$-гра\-фы, для
которых выполняется соотношение
$$
1 < \fr{\max(d_1, d_2)}{\min(d_1,
d_2)} \le t\,,
$$
где $t$~--- некоторая константа, большая единицы.

Введем метрику
$$
A^t_n(S_1, S_2) = 1 - \fr{\mbox{количество\ \textit{похожих}\ $n$-графов}}
{\mbox{общее\ количество\ $n$-графов}}\,.
$$

Таким образом, расстояние между образцами, у которых все $n$-гра\-фы
похожи, будет равно~0. Между образцами, у которых нет общих
$n$-гра\-фов,~---~1. Кумулятивные метрики вводятся аналогично
$R$-мет\-рике:
\begin{align*}
A^t_{n, m} &= A^t_n(S_1, S_2) + A^t_m(S_1, S_2)  \fr{M}{N}\,;
\\
A^t_{n, m} &= A^t_n(S_1, S_2) + A^t_m(S_1, S_2)  \fr{M}{N} + A^t_p(S_1, S_2) 
\fr{P}{N}\,.
\end{align*}

Стоит заметить, что во всех ниже описываемых экспериментах принималось $t \hm= 1{,}25$.

\subsubsection{Сбор данных}

Сорок человек предоставили по 15 сессий печати. Они выполняли роль
легитимных пользователей системы. Еще 165~человек предоставили по
одной сессии. Эти образцы использовались для имитации атаки на
систему.

Перерыв между сессиями был не менее одного дня. Каждая сессия
представляла собой свободный текст длиной около 700--900~символов.

У всех участников эксперимента итальянский является родным языком.

\begin{table*}[b]\small %tabl8
\begin{center}
    \Caption{Одиночные метрики}
        \label{res_sing}
\vspace*{2ex}

%    \tabcolsep=0,05cm
    \begin{tabular}{|c|c|c|c|c|}
                    \hline
                    Метрики& FP count& FN count & FP rate, \% & FN rate, \%\\
                    \hline
 $R_2$ & 563& 50& 0,13& 8,33\\
 $R_{2,3}$ &  324& 32& 0,07& 5,33\\
 $R_{2,4}$ & 259& 41& 0,06& 6,83\\
 $R_{2,3,4}$ &  199& 41& 0,04& 6,83\\
 $A_2$ &  590& 92& 0,13& 15,3\\
 $A_{2,3}$ &  335& 80& 0,07& 13,3\\
 $A_{2,4}$ &  366& 84& 0,08 & 14,0 \\
 $A_{2,3,4}$ & 331& 79& 0,07& 13,2\\
        \hline
          \end{tabular}
    \end{center}
%\end{table*}
%\begin{table*}\small
\begin{center}
 \Caption{Сумма метрик}
    \label{res_sum}
    \vspace*{2ex}
    
%    \tabcolsep=0,05cm
  \begin{tabular}{|c|c|c|c|c|}
                    \hline
                    Метрики& FP count& FN count & FP rate, \% & FN rate, \%\\
                    \hline
$R_2 + A_2$ & 360& 36& 0,08\hphantom{9}& 6,0\hphantom{99}\\
$R_2 + A_{2,3}$ & 272& 34& 0,06\hphantom{9}& 5,667\\
 $R_2 + A_{2,4}$ &  260& 37& 0,057& 6,167\\
 $R_2 + A_{2,3,4}$ & 237& 41& 0,052& 6,833\\
$R_{2,3,4} + A_2$ & 124& 19& 0,028& 3,167\\
$R_{2,3,4} + A_{2,3}$ & \hphantom{9}78 & 23& 0,017& 3,833\\ 
$R_{2,3,4} + A_{2,4}$ &  \hphantom{9}95& 22 & 0,021& 3,667\\ 
$R_{2,3,4} + A_{2,3,4}$ & 131& 23& 0,029& 3,833\\
        \hline
    \end{tabular}
    \end{center}
%\end{table*}

%\begin{table*}\small %tabl10
\begin{center}
    \Caption{Последовательные метрики}
    \label{res_seq}
    \vspace*{2ex}
    
%    \tabcolsep=0,05cm
    \begin{tabular}{|c|c|c|c|c|}
                    \hline
                    Метрики& FP count& FN count & FP rate, \% & FN rate, \%\\
                    \hline
$\{R_2 + A_2,\ R_2+A_{2,3}, \ R_2+A_{2,4}.\ R_2+A_{2,3,4}\}$ & 83 & 55 & 0,018& 9,167\\
$\{R_{2,3} + A_2,\ R_{2,3}+A_{2,3},\ R_{2,3}+A_{2,4},\ R_{2,3}+A_{2,3,4}\}$ &
74& 38& 0,016& 6,333\\
 $\{R_{2,3,4} + A_2,\ R_{2,3,4} + A_{2,3},\ R_{2,3,4} + A_{2,4},\
R_{2,3,4} + A_{2,3,4}\}$ & 22& 29& 0,005& 4,833\\
        \hline
    \end{tabular}
    \end{center}
\end{table*}

\subsubsection{Аутентификация}

В оригинальной статье рассматриваются эксперименты по классификации,
идентификации и аутентификации. В~рамках данного обзора будет описан
только эксперимент по аутентификации.

%\pagebreak

Пусть рассматриваются пользователи $A$, $B$, $C, \ldots$, которые
представлены образцами печати $A_1, \ldots, A_n$, $B_1, \ldots, B_k$
и~т.\,д. Средним расстоянием неизвестного образца $X$ от пользователя
$A$ назо-\linebreak вем
\begin{multline*}
\mathrm{md}(A, X) ={}\\
{}= \fr{1}{n} \left(d(A_1, X) + d(A_2, X) + \cdots + d(A_n, X)\right)\,,
\end{multline*}
где $d(A_i, X)$~--- расстояние между двумя образцами.

Среднее расстояние между образцами пользователя~$A$ обозначим как $m(A)$.

Неизвестный образец $X$ считается принадлежащим 
шаблону пользователя~$A$ в случае выполнения следующих условий:
\begin{itemize}
    \item $\mathrm{md}(A,X) < \mathrm{md}(B,X)$ для любого другого легитимного пользователя~$B$;
    \item $\mathrm{md}(A,X) < m(A)$ {или} $\mathrm{md}(A,X) \hm- m(A) \hm< 
    \mathrm{md}(B,X) \hm- \mathrm{md}(A,X)$ 
    для любого другого легитимного пользователя~$B$.
\end{itemize}

Каждый образец $S$ легитимного пользователя $U$ был использован как
новый и неизвестный образец. При корректной работе классификатора он
должен быть отнесен к пользователю~$U$, представленному оставшимися
14~образцами. Также $S$ использовался для попытки аутентификации под
видом каждого из оставшихся 39~пользователей. Когда образец~$S$
пользователя~$U$ используется для аутентификации под видом
пользователя~$U'$, пользователь~$U$ временно изымается из модели.
Таким образом, нарушитель всегда был неизвестен.

Каждый из 165 образцов нарушителей был использован для попытки
аутентификации под видом каждого легитимного пользователя.
Получается 600 попыток аутентификации правильным пользователем и
450\,000 атак $40 \hm+ 165 \hm= 205$~нарушителями ($600 \cdot 39 \cdot 15 \hm+
165 \cdot 40 \cdot 15 \hm= 450\,000$).

\subsubsection {Результаты}

В табл.~\ref{res_sing} представлены результаты первого эксперимента.
В нем были использованы одиночные метрики, перечисленные в первом
столбце. В~табл.~8 FP count~--- количество аутентифицированных атак (из
450\,000); FN count~--- количество отвергнутых легитимных
аутентификаций (из 600); FP rate и FN rate~--- отношение FP count и
FN rate к 450\,000 и 600 соответственно.

Для второго эксперимента, результаты которого отражены в
табл.~\ref{res_sum}, метриками служили суммы известных метрик.

В третьем эксперименте (табл.~\ref{res_seq}) образец считался
аутентифицированным, если он признавался аутентифицированным каждой
метрикой последовательности.

\subsection{Метод наказания-поощрения (\textit{penalty-reward})}

Интересный метод был предложен в~\cite{nisk}. Он основан на
динамическом изменении уровня недоверия к пользователю, что
позволяет оперативно реагировать на подмену пользователя.

\subsubsection{Функция наказания и поощрения}

Во время набора пользователь характеризуется уровнем доверия~$C$. 
В~начале сессии он принимается равным~0. При каждом нажатии $C$
изменяется в зависимости от информации в шаблоне пользователя. Если
ритм нажатия хорошо подходит к шаб\-ло\-ну, пользователь поощряется
уменьшением~$C$. В~противном случае~--- наказывается увеличением.

Пока $C$ остается ниже некоторого порога, есть уверенность в том,
что это тот пользователь, за которого он себя выдает. Если же
значение~$C$ велико, то, скорее всего, системе нужно предпринять
действия по уточнению личности пользователя.

Значение $C$ не должно становиться отрицательным. Если этого не
учитывать, то во время работы легитимного пользователя $C$ станет
очень маленьким, что даст нарушителю много времени до превышения~$C$
заданного порога. Нужно решить, как должно меняться значение уровня
доверия в случае, если очередная клавиша (комбинация клавиш) не
входят в шаблон пользователя. Авторами предлагается увеличивать~$C$
на небольшую заданную константу.

Таким образом, можно ввести следующую функцию:
$$ C =\begin{cases}
    0\,, &\ \mbox{начало\ сессии}\,; \\
    \max(C - R, 0)\,, &\ d \le T\,; \\
    C + d - T\,, &\ d > T\,; \\
    C + \alpha\,, &\ \mbox{клавиша\ не\ из\ шаблона}\,.
\end{cases}
$$
Здесь $R$ -- величина поощрения пользователя за нажатие,
соответствующее шаблону; $d$~--- расстояние от очередного нажатия до
шаблона пользователя; $T$~--- доверительный порог расстояния;
$\alpha$~--- наказание за клавишу, не принадлежащую шаблону.

\subsubsection{Сбор данных и модель представления}

В эксперименте участвовало 25~пользователей, предоставляя информацию
о нажатиях в течение 6--15~дней своей обычной работы за компьютером.

Время между нажатием и отпусканием клавиши назовем
\textit{удержанием}. Время между отпусканием одной клавиши и
нажатием следующей назовем \textit{задержкой}.

Шаблон пользователя представляет собой математическое ожидание~($\mu$) 
и стандартное отклонение~($\sigma$) удержания и задержки
нажатых клавиш и комбинаций клавиш. Решение о включении клавиши
(комбинации клавиш) в шаблон принималось на основе числа вхождений~$N$ 
в наборе и отношения~$\mu$ и~$\sigma$: $N$ должно быть выше
некоторого порога, ${\mu}/{\sigma}$~--- ниже.

Расстояние между новой клавишей и шаблоном введено как
$$
d = d((\mu, \sigma), t) = \left|\fr{t - \mu}{\sigma}\right|\,,
$$
где $t$~--- время удержания или задержки.

Расстояние между комбинацией клавиш $k_1k_2$ и шаблоном:
$$
d = \fr{1}{3}  \left( \left|\fr{t_{k_1} - \mu_{k_1}}{\sigma_{k_1}}\right| + 
\left|\fr{t_{k_1 k_2} - \mu_{k_1 k_2}}{\sigma_{k_1 k_2}}\right| + 
\left|\fr{t_{k_2} - \mu_{k_2}}{\sigma_{k_2}}\right| \right)\!.
$$

Необходимо определить максимальное значение $C$, после которого
можно считать пользователя нарушителем~--- $T_{\mathrm{action}}$. Это
значение будет своим для каждого пользователя. Оно будет равно
максимальному значению~$C$, полученному при применении шаблона
пользователя к обучающим данным. Это позволит свести к минимуму
лож\-но-от\-ри\-ца\-тель\-ные срабатывания.

\subsubsection{Результаты}

Для каждой пары различных пользователей $i$ и~$j$ шаблон~$i$
применялся к данным~$j$. Измерялось среднее количество нажатий,
после которого значение~$C$ превышало порог $T^i_{\mathrm{action}}$.

Требовалось от 79 до 348~нажатий для определения нарушителя. 
В~среднем нарушитель определялся после 265~нажатий.

\section{Предлагаемый подход}

\subsection{Представление данных}

Среди рассмотренных выше способов лишь подход, использующий
$n$-гра\-фы, учитывает в единице данных события, происходившие на
протяжении некоторого времени. Тем не менее очевидно, что параметры,
относящиеся только к одному нажатию, несут в себе меньше информации,
нежели параметры, описывающие их серию. Поэтому предлагается новый
подход, позволяющий эффективно сохранять недавнюю активность
пользователя при работе с клавиатурой.

Предлагаемое представление данных основывается на отображении
$$
\varphi: (A, t_d, t_h) \rightarrow H, A \in \Omega\,,
$$
где $\Omega$ -- некоторый конечный алфавит действий пользователя;
$t_d$~--- время, в которое была нажата клавиша; $t_h$~--- время, в
течение которого клавиша удерживалась нажатой; $H$~--- вектор
признаков. Это отображение должно оказывать большее влияние на
анализ события $A^{\mathrm{next}}$ в зависимости от  сле\-ду\-ющих
факторов:
\begin{itemize}
  \item недавняя активность пользователя;
  \item частота совершения действия;
  \item протяженность действия по времени.
\end{itemize}

Для построения такого отображения была использована теория
потенциальных функций~\cite{aizerman}. Пусть каждое возможное
событие $A_i \hm\in \Omega$ имеет свой потенциал в момент~$t$. Он
убывает в за\-ви\-си\-мости от времени, прошедшего с момента совершения
действия. Этот процесс характеризуется функцией $\mathrm{Pf}: \mathrm{Time} \times
\mathrm{Time} \hm\rightarrow \mathbb R$. Если последовательность содержит два
или более событий~$A_i$, то их потенциалы суммируются.

Таким образом, можно определить отображение последовательности
действий пользователя в $L$-мер\-ный вещественный вектор, где $L \hm=
|\Omega|$,  в виде:
$$
  \varphi(H(U), t) = \left(
  \sum\limits_{\substack{(A, t_m) \in H(U) \\ t > t_m}} P\!f(t, t_m) \right)_{A \in \Omega}\,.
$$
Согласно этой формуле, активность пользователя в каждый конкретный
момент времени~$t$ может быть определена как множество из $L \hm=
|\Omega|$ потенциалов $\varphi_A(H(U), t)$. Такой подход учитывает
как частоту предыдущих действий, так и время, в которое текущее
действие было совершено.

Был выбран класс ра\-ди\-аль\-но-ба\-зис\-ных функций, поскольку эти функции
обладают необходимым в данном случае свойством: они зависят от
интервалов между действиями, но не зависят от абсолютного времени их
совершения. Кроме того, эти функции легко параметризовать для того,
чтобы добиться эффективности в задачах  аутентификации и
идентификации.

В качестве потенциальной ра\-ди\-аль\-но-ба\-зис\-ной функции была выбрана
экспоненциальная функция $\mathrm{Pf}(x, y) \hm= e^{-\sigma||x-y||}$, где
$\sigma$~--- коэффициент затухания, отвечающий за то, как быстро
потенциал будет убывать. Кроме того, для конечной последовательности
действий эта функция может быть рассчитана рекурсивно (полагая
$\varphi_A(0) \hm= 0$):
$$
\varphi_A(t_n)  = 
\begin{cases}
  \varphi_A(t_{n \! - \! 1})   e^{-\sigma||t_n-t_{n -  1}||}\,, &\ A \ne A_n; \\[3pt]
     e^{- \alpha}\,, &\ A = A_n\,.
\end{cases}
$$
Для достижения максимальной эффективности коэффициенты $\sigma$
 и~$\alpha$ могут быть подобраны, учитывая специфику конкретной задачи.
Коэффициент~$\alpha$ отвечает за влияние времени нажатия на значение
потенциала.

Для того чтобы избежать зашумленности данных низкими значениями,
можно ввести константный порог~$\varepsilon$ следующим образом:
$$
\label{functor_threshold}
\hat{\varphi}_A(t_n) =
\begin{cases}
  \varphi_A(t_n)\,, &\varphi_A(t_n) \ge \varepsilon\,; \\[3pt]
  0\,, &\varphi_A(t_n) < \varepsilon\,.
\end{cases}
$$

Текущая активность пользователя описывается последовательностью
$n$-мер\-ных векторов (где $n \hm= |\Omega|$), содержащих потенциалы
$\hat\varphi_A$ для каждого действия~$A$.

В качестве примера рассмотрим набор слова {\sf Hello} и
получаемые при этом векторы. Возьмем упрощенный случай: $\Omega$
ограничим буквами {\sf H, E, L, O}. В~таком случае получаемые
векторы будут четырехмерными и могут иметь вид, отраженный в
табл.~11.

На рис.~1 видно, что элементы вектора
представляют собой значения потенциальной функции соответствующего
действия в моменты нажатий.

Таким образом, один вектор содержит достаточное количество
информации, чтобы быть правильно распознанным с высокой долей
ве\-ро\-ят\-ности с помощью алгоритмов машинного обучения, и при этом
генерируется на каждое нажатие, что позволяет увеличить объем данных
для обучения и распознавания.


 \vspace*{14pt} %tabl11
 
\noindent
{{\tablename~11}\ \ \small{Получаемые векторы при наборе слова {\sf Hello}}}

%\vspace*{1pt}


\begin{center} 
%\begin{table*}
{\small
\tabcolsep=7.5pt
\begin{tabular}{|c|c|c|c|c|}
\hline
\multicolumn{1}{|c|}{\raisebox{-6pt}[0pt][0pt]{Событие}} & \multicolumn{4}{c|}{Состояние вектора} \\
\cline{2-5}
& <<{\sf H}>> & <<{\sf E}>> & {<<{\sf L}>>} & {<<{\sf O}>>} \\
\hline
Начальное состояние & 0\hphantom{,99} & 0\hphantom{,99} & 0\hphantom{,99} & 0 \\
%            \hline
Нажата <<{\sf H}>> & 1\hphantom{,99} & 0\hphantom{,99} & 0\hphantom{,99} & 0 \\
%           \hline
Нажата <<{\sf E}>> & 0,82 & 0\hphantom{,99} & 0\hphantom{,99} & 0 \\
%          \hline
Нажата {<<{\sf L}>>} & 0,53 & 0,64 & 1\hphantom{,99} & 0 \\
%         \hline
Нажата {<<{\sf L}>>} & 0,34 & 0,41 & 1\hphantom{,99} & 0 \\
%        \hline
Нажата <<{\sf O}>> & 0,23 & 0,30 & 0,80 & 1 \\
\hline
\end{tabular}}
\end{center}

\setcounter{figure}{1}
\begin{figure*}[b] %fig2
\vspace*{9pt}
 \begin{center}
 \mbox{%
 \epsfxsize=163.641mm
 \epsfbox{mas-2.eps}
 }
 \end{center}
 \vspace*{-6pt}
    \Caption{ROC-кривые (TPR~--- true positive rate; FPR~--- false positive
    rate) для набора данных Si6~(\textit{а}) и для данных, собранных авторами~(\textit{б}):
    \textit{1}~--- случайный лес; \textit{2}~--- дерево решений (алгоритм С5.0)}
    \label{roc_si6}
\end{figure*}

\addtocounter{table}{1}

\noindent
\begin{center}  %fig1
\vspace*{3pt}
  \mbox{%
 \epsfxsize=77.374mm
 \epsfbox{mas-1.eps}
 }
 \vspace*{6pt}
{{\figurename~1}\ \ \small{Набор слова <<{\sf Hello}>>}}
 \end{center}

\addtocounter{figure}{1}

\subsection{Сбор данных}

Для проверки качества предлагаемой модели представления был
использован уже описанный выше набор данных Si6~\cite{si6},
состоящий из 55~пользователей.

Кроме этого, в рамках исследовательской работы был проведен
независимый сбор данных. Сорока испытуемым было предложено установить
про\-грам\-му-агент, которая в фоновом режиме собирала информацию о
нажатиях во время их обычной работы (преимущественно с текстовым
редактором и веб-брау\-зе\-ром). Весь эксперимент был  разделен на 2
дня, в каждый из которых условия или оборудование для  испытуемого
оставались неизменными. Таким образом, для пользователя
регистрировались две сессии длительностью 3~ч в первый день и 6~ч 
во второй. В~среднем на одного испытуемого приходилось порядка
24~тыс.\ нажатий.

\subsection{Статическая аутентификация с~предлагаемой моделью поведения}

Для проверки нового представления данных был проведен эксперимент по
статической аутентификации. Все исходные данные обрабатывались
потенциальным функтором, и для анализа использовались только векторы
значений потенциальной функции, полученные в результате.

Для каждого пользователя все данные в наборе разделялись на <<свои>>
и <<чужие>> (по принадлежности вектора этому пользователю). 
В~качестве тренировочного набора бралось по 1500~векторов, полученных
случайной выборкой из <<своих>> и <<чужих>> данных (всего 
3000~векторов), в качестве тес\-то\-вой выборки из каждого набора бралось по
1000 векторов (всего 2000).

На тренировочном наборе было обучено 2~классификатора:
\begin{enumerate}[(1)]
\item \textbf{дерево решений.} В качестве реализации был выбран алгоритм 
See5/C5.0 \cite{c50};
\item \textbf{случайный лес} (ансамбль деревьев решений). Была 
взята реализация алгоритма из~\cite{rf}. В~данном эксперименте использовался 
ансамбль из 500~деревьев решений.
\end{enumerate}

Далее каждому классификатору на вход подавались векторы из тестового
набора, для каждого из которых он выдавал вероятность принадлежности
данного события классу <<свой>>.

\setcounter{figure}{2}
\begin{figure*} %fig3
\vspace*{9pt}
 \begin{center}
 \mbox{%
 \epsfxsize=162.085mm
 \epsfbox{mas-4.eps}
 }
 \end{center}
 \vspace*{-6pt}
    \Caption{Распределение EER для данных Si6~(\textit{а}) и
    для данных, собранных авторами~(\textit{б}) }
    \label{eer_si6}
\end{figure*}

На основании этого алгоритма было проведено 2~эксперимента:
\begin{enumerate}[(1)]
\item первый эксперимент был проведен на наборе 
данных Si6~\cite{si6}. ROC-кри\-вые (Receiver Operating Characteristics)
для этого набора представлены на рис.~\ref{roc_si6},\,\textit{а}. 
Как видно из распределений на рис.~3,\,\textit{а}, наилучший EER достигался при 
использовании ансамбля деревьев решений и составлял в среднем 6\%.  В~этом 
подходе $F$-ме\-ра оказалась равной 0,94;
\item второй эксперимент был проведен на данных, собранных авторами статьи 
(рис.~2,\,\textit{б}). Здесь показатели несколько хуже и, как видно из распределений 
на рис.~3,\,\textit{б}, EER в среднем составляет 13\%.
\end{enumerate}

\subsection{Непрерывная динамическая аутентификация с~предлагаемой моделью представления}

Для проверки качества представления данных был проведен эксперимент
по непрерывной динамической аутентификации, использующий функцию
на\-ка\-за\-ния-поощре\-ния.

В качестве алгоритма интеллектуального анализа данных были
использованы деревья решений в реализации C5.0~\cite{c50}.

Функция наказания-поощрения, записанная выше, применительно к
данному представлению (отсутствие данных о нажатии какой-либо
клавиши не является особым случаем, который надо рас\-смат\-ри\-вать
отдельно) принимает следующий вид:
$$ C =
\begin{cases}
    0\,, &\ \mbox{начало\ сессии}\,; \\
    \max(C - R, 0)\,, &\ d \le T\,; \\
    C + d - T\,, &\ d > T\,,
\end{cases}
$$
где $d$~--- вероятность того, что очередной вектор соответствует шаблону 
пользователя, выданная классификатором.

\subsubsection{Постановка эксперимента}

В рамках эксперимента моделировалась ситуация, при которой каждый
пользователь делал попытку аутентификации под всеми другими
пользователями.

В каждом случае классификатор обучался на 2000~векторов
пользователя, под видом которого происходила аутентификация, и на
2000 случайных векторов всех других пользователей (кроме того,
который производил попытку аутентификации). Таким образом, атакующий
пользователь никогда не принимал участия в обучении классификатора.

Валидационный набор представлял собой 1000~дополнительных векторов
атакуемого пользователя. Порог уровня доверия, при превышении
которого пользователь считался нарушителем, был взят в 10~раз выше,
чем максимальный уровень доверия на валидационном наборе.

На рис.~\ref{conf_friend} показаны уровни доверия
для вали\-дационного набора легитимного пользователя и тес\-то\-во\-го
набора атакующего пользователя соответственно. Обратите внимание на
различие в еди\-ни\-цах измерения порога. В~данном примере атака была
определена на 212-м нажатии. Заметим, что уровень доверия
легитимного пользователя не превосходит 1,4 на протяжении 
1000~нажатий. Доверие тестового набора с определенного момента только
увеличивается.

Таким образом, для каждого из 55~пользователей было получено 
54~номера нажатия, на которых уровень доверия превышал указанный порог.
Для оценки качества алгоритма был взят средний номер нажатия в
каждой выборке.

\begin{figure*} %fig4
\vspace*{9pt}
 \begin{center}
 \mbox{%
 \epsfxsize=161.908mm
 \epsfbox{mas-7.eps}
 }
 \end{center}
 \vspace*{-6pt}
    \Caption{График уровня доверия для легитимного пользователя~(\textit{а}) и 
    для атакующего набора~(\textit{б})}
    \label{conf_friend}
    \vspace*{6pt}
\end{figure*}

Аналогичным образом был проведен эксперимент и на данных, собранных
авторами. Результаты показаны на рис.~5. В~половине случаев
наруши-\linebreak

\vspace*{-1pt}

\begin{center}  %fig5
  \mbox{%
 \epsfxsize=75.76mm
 \epsfbox{mas-6.eps}
 }
 \end{center}
 \vspace*{3pt}
{{\figurename~5}\ \ \small{Количество нажатий, необходимое для обнаружения нарушителя}}
% \end{center}

\vspace*{12pt}

\noindent
тель был определен уже после 50-го и 100-го нажатия (для Si6 и
данных, собранных авторами, соответственно).

\vspace*{-2pt}

\section{Заключение}

В статье проведен обзор методов статической и динамической
аутентификации с учетом динамики нажатий клавиш. Среди методов
статической аутентификации рассмотрены подходы, учитывающие время
удержания клавиш, порядок нажатия и отпускания кнопок; методы,
принимающие решение об успешности аутентификации на основе
относительной скорости печати и использовании левой и правой клавиш
{\sf Shift}. Кроме того, рассмотрен подход, дающий высокие
результаты на коротких паролях, и оценено влияние информированности
пользователя на результаты.

В рамках задачи динамической аутентификации рассматривался метод,
основанный на кластеризации, метод, который использует комбинацию
метрик расстояния между очередным нажатием и шаблоном пользователя,
показавший хорошие результаты. Также рассматривался подходящий для
задачи непрерывного контроля пользователя алгоритм, применяющий
функцию на\-ка\-за\-ния-по\-ощре\-ния.

Как альтернатива существующим методам была предложена модель
представления данных, основанная на потенциальных функциях вместе с
алгоритмами, на которых ее применение дает высокие результаты
(алгоритмы деревьев решений C5.0 и случайный лес). Для задачи
динамической аутентификации был использован метод поощрения и
наказания. Для проверки эффективности сочетаний модели и
перечисленных алгоритмов были проведены эксперименты на данных из
набора Si6 и данных, собранных авторами в рамках этой
исследовательской работы.

Проведенные эксперименты показали применимость предложенного подхода
для динамической аутентификации. Таким образом, авторами статьи было
признано целесообразным создание экспериментальной системы
аутентификации, основанной на механизме, предложенном в ней.

{\small\frenchspacing
{%\baselineskip=10.8pt
\addcontentsline{toc}{section}{Литература}
\begin{thebibliography}{99}



\bibitem{lao}
\Au{Lau~E., Liu~X., Xiao~C., Yu~X.} Enhanced user authentication
through keystroke biometrics.~--- Massachusetts Institute of
Technology, 2004.

\bibitem{saggio}
\Au{Saggio~G., Costantini~G., Todisco~M.} Cumulative and ratio
time evaluations in keystroke dynamics to improve the password
security mechanism~// J.~Computer Information
Technol., 2011.  Vol.~1. No.\,2. P.~4--11.

\bibitem{svm}
\Au{Sung~K.~S., Cho~S.} GA SVM  wrapper ensemble for keystroke
dynamics authentication~//  Conference (International) on
Biometrics Proceedings.~--- Hong Kong: ICB, 2004. P.~654--660.

\bibitem{legett}
\Au{Leggett~J., Williams~G.} Verifying identity via keystroke
characteristics~// Int. J.~Man-Machine Studies,
1988. Vol.~28. No.\,1. P.~67--76.

\bibitem{hocquet}
\Au{Hocquet~S., Ramel~J.-Yv., Cardot~H.} Fusion of methods for
keystroke dynamic authentication~// Automatic Identification
Advanced Technologies: 4th IEEE Workshop Proceedings.~--- Buffalo, 2005.
P.~224--229.

\bibitem{bergadano} %6
\Au{Bergadano~F., Gunetti~D., Picardi~C.} User authentication
through keystroke dynamics~// ACM Trans. Information 
Syst. Security (TISSEC), 2002. Vol.~5. No.\,4. P.~367--397.

\bibitem{kittler}
\Au{Kittler~J., Hatef~M., Duin R.~P.~W., Matas.~J.} On combining
classifiers~// Pattern Analysis and Machine Intelligence, IEEE
Trans., 1998. Vol.~20. No.\,3. P.~226--239.

\bibitem{bert}
\Au{Bertacchini~M., Benitez~C., Fierens~P.\,I.} User clustering
based on keystroke dynamics~// XVI Congreso Argentino de Ciencias de
la Computaci$\acute{\mbox{o}}$n. -- Mor$\acute{\mbox{o}}$n, 2010. P.~832--841.

\bibitem{si6}
\Au{Bello~L., Benitez~C., Bertacchini~M., Pizzoni~J.\,C.,
Cipriano~M.} Collection and publication of a fixed text keystroke
dynamics dataset~// XVI Congreso Argentino de Ciencias de la
Computaci$\acute{\mbox{o}}$n. -- Mor$\acute{\mbox{o}}$n, 2010. P.~822--831.

\bibitem{sil}
\Au{Rousseeuw~P.\,J.} Silhouettes: A~graphical aid to the
interpretation and validation of cluster analysis~// J.~Comput. Appl. Math., 
1987. Vol.~20. P.~53--65.

\bibitem{gunet}
\Au{Gunetti~D., Picardi~C.} Keystroke analysis of free text~//
ACM Trans. Information Syst. Security (TISSEC), 2005.
Vol.~8. No.\,3. P.~312--347.

\bibitem{nisk}
\Au{Monrose~F., Rubin~A.\,D.} Keystroke dynamics as a biometric
for authentication~// Future Generation Computer Syst., 2000.
Vol.~16. No.\,4. P.~351--359.

\bibitem{aizerman}
\Au{Айзерман~М.\,А., Браверман~Е.\,М., Розоноэр~Л.\,И.} Метод потенциальных
функций в теории обучения машин.~--- M.: Наука, 1970.

\bibitem{c50}
\Au{Quinlan~J.\,R.} C4.5: Programs for machine learning.~--- Morgan Kaufmann, 1993.

\label{end\stat}

\bibitem{rf}
\Au{Breiman~L.} Random forests~// Machine Learning, 2001.
Vol.~45. No.\,1. P.~5--32.
\end{thebibliography}
} }

\end{multicols}