
\def\stat{kovalev}

\def\tit{СЕМАНТИКА АСПЕКТНО-ОРИЕНТИРОВАННОГО МОДЕЛИРОВАНИЯ ДАННЫХ И~ПРОЦЕССОВ}

\def\titkol{Семантика аспектно-ориентированного моделирования данных и~процессов}

\def\autkol{С.\,П.~Ковалёв}

\def\aut{С.\,П.~Ковалёв$^1$}

\titel{\tit}{\aut}{\autkol}{\titkol}

%{\renewcommand{\thefootnote}{\fnsymbol{footnote}}\footnotetext[1] {Работа 
%выполнена при финансовой поддержке Программы стратегического развития ПетрГУ   
%в рамках реализации комплекса мероприятий  по развитию научно-исследовательской 
%деятельности.}}

\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{Институт проблем управления им.\ В.\,А.~Трапезникова 
Российской академии наук, kovalyov@nm.ru}


\Abst{Предложен подход к унификации технологий аспектно-ориентированного 
программирования (АОП) на семантическом уровне путем формализации основных 
понятий АОП средствами теории категорий. Технология АОП описывается категорией 
аспект\-но-ориен\-ти\-ро\-ван\-ных моделей программ (АО-мо\-де\-лей) и их 
системных взаимосвязей, снабженной функтором выделения аспектной структуры 
(разметки моделей классами задач). Связывание 
аспект\-но-ориен\-ти\-ро\-ван\-ных программ формализуется универсальной 
конструкцией в этой категории. Построены и проанализированы формальные 
технологии АОП, применение которых позволяет снижать затраты на моделирование 
данных и сценариев исполнения процессов. Строго сформулировано и обосновано 
условие существования связывания для сценарных моделей программных сис\-тем.}

\KW{аспектно-ориентированное программирование; теория категорий; аспектное 
связывание}


 \vskip 14pt plus 9pt minus 6pt

      \thispagestyle{headings}

      \begin{multicols}{2}

            \label{st\stat}


\section{Введение}

   Традиционные технологии программирования, в том числе структурные и 
объект\-но-ориен\-ти\-ро\-ван\-ные, предписывают собирать сложные сис\-те\-мы\linebreak 
из модулей, предназначенных для выполнения различ\-ных функциональных 
задач и взаимо\-дей\-ст\-ву\-ющих между собой через фиксированные ин-\linebreak терфейсы. 
Однако в практике создания сис\-тем постоянно возникают классы задач, не 
поддающиеся локализации в рамках модулей. Они рассеиваются (scatter) по 
разным модулям, пересекают (crosscut) их границы, перемешиваются (tangle) с 
реализацией других задач. Поэтому их автоматизация средствами 
<<модульных>> технологий сопряжена со значительными затратами труда: 
качество результата зависит не только от качества средства программной 
реализации задачи, но и от полноты его проникновения во все части системы. 
Примеры можно найти как среди функциональных задач (ведение паспорта 
объекта автоматизации, верификация данных), так и среди про\-грам\-мно-тех\-ни\-че\-ских 
(ведение журналов функционирования системы, защита 
информации и~т.\,д.).
   
   Эффективное создание систем, содержащих такие рассеянные задачи, 
является целью АОП~--- новой парадигмы, предложенной Г.~Кишалесом и его коллегами в 
конце 1990-х~гг.~[1]. Реализация рассеянной задачи в АОП оформляется как 
аспект~--- особая программная единица, код которой автоматически 
вставляется в код других единиц в точках, явно задаваемых внешним образом. 
Однако на практике АОП применяется значительно реже, чем модульные 
подходы, поскольку отсутствует единое непротиворечивое понимание его 
методологической основы~[2]. На семантическом уровне неясно, как 
рационально выделять и комплексировать аспекты в программных системах и 
их моделях. Существующие технологии АОП предлагают лишь частные 
решения, специфичные для частных парадигм программирования. 

Сходные 
проблемы препятствовали развитию объ\-ект\-но-ори\-ен\-ти\-ро\-ван\-но\-го 
подхода, пока не был создан универсальный язык моделирования UML (Unified
Modeling Language), 
позволивший освободить процесс объектной декомпозиции от ограничений 
частных языков программирования~[3].
   
   В связи с этим целью настоящей работы стало построение универсальной 
семантики АОП, не зависящей от выбора парадигмы программирования. Для 
этого был привлечен аппарат теории категорий, поскольку он позволяет 
единообразно и компактно описывать разнородные технологии инженерии 
программного обеспечения с позиций системного анализа~[4]. С~его помощью 
удалось компактно выразить двухуровневый характер технологий АОП~--- 
составление программы из модульной основы и аспектной структуры. Сборка 
программ из аспектов формализована универсальной категорной конструкцией. 
В~качестве приложения этого подхода предложена единая концепция 
технологии АОП, позволяющей снижать затраты на моделирование данных и 
сценариев исполнения процессов~--- ключевых составляющих широкого класса 
программных сис\-тем.

\section{Аспектно-ориентированное программирование}

   Классы задач, пересекающие границы единиц модульной архитектуры, 
хорошо известны программистам, использующим широко распространенные 
алгоритмические языки. Практически в любой программе исполнение 
основных функций\linebreak перемешивается с обращениями к 
   про\-грам\-мно-тех\-ни\-че\-ским задачам, таким как журналирование,\linebreak 
кэширование, защита информации и~т.\,п. Они глубоко погружены в контекст 
своего исполнения, поэтому их реализацию трудно оформлять единицами 
модульной архитектуры, контекст которых передается через фиксированный 
интерфейс (<<обобщенными процедурами>>, в терминологии Г.~Кишалеса). 
Приходится дублировать программный код, реализующий рассеянные задачи, в 
различных мес\-тах обращения к ним, чрезвычайно повышая трудоемкость 
модификации программы. Даже если искусственно оформить рассеянные 
задачи процедурами, то перемежающиеся обращения к ним, нагруженные 
передачей контекста, делают текст программы трудным для понимания и 
сопровождения.
   
   В рамках АОП предлагается оформлять реализации рассеянных задач в виде 
аспектов~--- особых программных единиц, места обращения к которым 
задаются в отдельной спецификации, внешней по отношению к вызывающей их 
(<<базовой>>) программе. Сборка сис\-те\-мы из аспектов заключается во 
вставке их программного кода в базовый код в этих местах, в результате чего 
они получают полный доступ к контексту, обходя ограничения модульного 
интерфейса доступа. Эта процедура выходит за рамки традиционной 
компоновки модулей (linking), не позволяющей модифицировать поток 
исполнения программы, поэтому она называется связыванием (weaving). 
Связывание может выполняться как на этапе компиляции, путем генерации 
программного кода со вставками согласно спецификации мест обращения к 
аспектам, так и в процессе исполнения, путем вызова предварительно 
скомпилированных аспектов при достижении соответствующих мест. Поэтому 
связывание может способствовать снижению за\-трат не только в условиях 
рассеяния задач, но и в других случаях, когда требуется изменить поведение 
программного модуля внешним <<нештатным>> образом. Например, так можно 
реализовать модули, предназначенные для многократного использования в 
конфигурациях, различающихся на\-ли\-чи\-ем/от\-сут\-ст\-ви\-ем нескольких изменчивых 
задач, оформляемых как аспекты~[5]. 

Еще одной областью такого применения 
связывания является интеграция унаследованных модулей (legacy), не 
доступных в исходных кодах и потому не допускающих модификацию путем 
редактирования~[6].
   
   Приведем наглядный пример с использованием языка AspectJ~[7]~--- 
   ас\-пект\-но-ори\-ен\-ти\-ро\-ван\-но\-го расширения языка Java. 
Предположим, что при выполнении некоторой программы требуется 
распечатывать все вызовы методов, наименования которых начинаются со 
слова {\sf init} (инициализировать). Ручная реализация такой задачи включает поиск 
этого слова в тексте программы, умозрительное отделение вызовов методов (от 
наименований переменных, комментариев и~др.)\ и вписывание обращения к 
функции печати после них. Компилятор AspectJ выполняет всю эту работу 
автоматически, получив на вход аспект следующего вида:
\begin{verbatim}
public aspect methodCallLogging {
    // Регулярное выражение, 
    // задающее точки вставки
    // кода аспекта в исходную программу
    pointcut methodCalled(): 
      execution(public * init*(..));
    // Действие, вставляемое после 
    // каждой точки
    after(): methodCalled() {
      System.out.println("Method call: " +
           thisJoinPoint.getSignature());
    }
}
\end{verbatim}

   Этот пример позволяет увидеть и основную концептуальную проблему 
классического АОП~--- зависи\-мость результата связывания от синтак\-сической 
структуры программы, а не от семан\-ти\-ческой структуры ее предметной 
области. Так, \mbox{пример} не обеспечит журналирование вызова метода 
инициализации в случае, если он назван {\sf begin()} вмес\-то {\sf init()}. 
В~литературе эта проблема называется <<композиционной хрупкостью>> 
(composition fragility)~[8]: многоаспектная сис\-те\-ма может радикально 
измениться и даже развалиться на части при незна\-чительном изменении 
синтаксиса базы, \mbox{хотя} семантика остается неизменной. Этим вызвано 
удру\-ча\-ющее однообразие типичных областей применения АОП: они не 
выходят за рамки про\-грам\-мно-тех\-ни\-че\-ских задач~[2]. Не хватает 
эффективных ти\-по\-вых решений по реализации семантически богатых 
функциональных рассеянных задач, таких как ведение паспорта объекта 
автоматизации,\linebreak опо\-ве\-ще\-ние участников процессов о ходе их вы-\linebreak полнения, 
оперативная оценка эффективности процессов, проверка правильности 
действий пользователей и компонентов системы, перевод информации на 
различные языки и в различные форматы.

\pagebreak
   
   Полноценная поддержка функциональных аспектов требует распространения 
ас\-пект\-но-ори\-ен\-ти\-ро\-ван\-но\-го подхода на весь жизненный цикл 
программного обеспечения~--- от формирования требований до сопровождения 
готового изделия~[9]. В~начале жизненного цикла аспекты естественным 
образом появляются в виде классов задач (concerns), присутствующих 
одновременно во многих требованиях. Такие аспекты называются ранними 
(early aspects)~[8]. По своей природе они вполне соответствуют значению слова 
<<аспект>> в обыденном языке: <<(\textit{лат}.\ aspectus~--- вид, взгляд) точка зрения, 
взгляд на что-ни\-будь>>~[10]. В~литературе описан ряд частных подходов к 
анализу и моделированию ранних аспектов, однако они не имеют единой 
семантической базы, которая позволила бы обеспечить их совместимость друг с 
другом, прямой переход к реализации средствами АОП, формальную проверку 
корректности~[8]. Ни один из подходов не способен претендовать на роль 
канона ас\-пект\-но-ори\-ен\-ти\-ро\-ван\-но\-го моделирования.
   
   Как свидетельствует история инженерии программного обеспечения, в этих 
условиях необ\-ходима абстрактная семантическая модель, не завися\-щая от 
выбора языков и технологий программирования. Наиболее прямым 
операциональным выражением целевой установки АОП является пометка 
фрагментов программ классами задач, на решение которых они направлены. 
Действительно, мотивация создателей АОП состояла в нехватке про\-грам\-мных 
конструкций для явного разделения ответственности (separation of concerns) в 
исходном коде~[1]. Разметка классами задач образует аспектную структуру 
программы, сохранение которой по ходу процесса разработки позволяет 
избежать главной проблемы, вызванной рассеянием задач,~--- <<растворения>> 
аспектов в контексте и утраты их идентичности. Технологии АОП отличаются 
способами разметки, но сходятся в стремлении обеспечить сквозную 
трассируемость, т.\,е.\ возможность однозначно установить, для чего в 
программу включен тот или иной фрагмент. Недостаточная поддержка 
трассирования, предо\-став\-ля\-емая большинством распространенных 
инструментов моделирования и составления программ, является главным 
мотивом привлечения технологий типа АОП~[8]. Поэтому предлагаемая 
семантика АОП опирается на концепцию трассирования, в ходе которого 
процедуры сборки программных сис\-тем отражаются на уровне классов 
решаемых ими задач.
   
   В заключение раздела отметим, что в традиционной инженерии 
материальных систем раздельное решение рассеянных задач является давно 
устоявшейся практикой. Рассмотрим в качестве примера проектирование 
зданий~--- об\-ласть, из которой инженеры по программному обеспечению 
заимствовали много идей. Модульную архитектуру здания составляют 
подъезды, этажи, комнаты, а аспектную~--- интенсивно пересекающие их 
системы освещения, водоснабжения, отопления и~др.~[9]. Проект каждого из 
таких аспектов документируется в форме отдельного плана и отдается на 
реализацию отдельной бригаде специалистов. Связывание аспектов по ходу 
строительства, включая разрешение всевозможных технологических и 
процедурных конфликтов, входит в число рутинных задач про\-раба.

\section{Формальные технологии аспектно-ориентированного программирования}

   В качестве математического аппарата для строгой записи семантики АОП 
была привлечена теория категорий. Предполагается, что читатель знаком с ее 
базовыми понятиями; их определения можно найти, например, в 
книгах~\cite{12-kov, 11-kov} (в~\cite{11-kov} объекты и морфизмы 
категории~$C$ кратко называются $C$-объ\-ек\-та\-ми и $C$-мор\-физ\-ма\-ми 
соответственно). Тео\-ре\-ти\-ко-ка\-те\-гор\-ный подход к формализации 
программирования разрабатывается начиная с 1970-х~гг.~\cite{4-kov}. 
Каждому компоненту или системе со\-по\-став\-ля\-ет\-ся абстрактный объект, а 
каждому действию по интеграции компонента в сис\-те\-му~--- морфизм, т.\,е.\ 
абстрактный аналог функции, преобразующей\linebreak
 объ\-ект-об\-ласть (компонент) в 
объ\-ект-ко\-об\-ласть (сис\-те\-му). Подчеркнем, что для любого 
компонента~$C$ и любой системы~$S$, как правило, указывается не только 
возможность (или невозможность) интеграции~$C$ в~$S$, но и совокупность 
всех различных способов интеграции (вставка, разрешение ссылок, 
перекомпоновка и~т.\,д.), образу\-ющая множество морфизмов 
$\mathrm{Mor}(C, S)$. Композиция морфизмов отвечает конструированию 
многошаговых действий (процессов), причем их результат не зависит от 
порядка прослеживания шагов (свойство ассоциативности). Имеются 
тождественные морфизмы, означающие <<ничегонеделание>>. Процеду\-ры 
сборки систем из компонентов описываются\linebreak диаграммами~--- 
ориентированными графами, вершины которых помечены объектами, а 
   ребра~--- морфизмами. Таким образом, получается \textit{формальная 
технология программирования}~--- категория,\linebreak конструкции в которой 
описывают приемы комплексирования сис\-тем.
   
   Среди конструкций, важных для дальнейшего изложения, отметим 
терминальный объект~--- элементарную модель, лишенную ка\-кой-ли\-бо 
внут\-рен\-ней структуры. Любая модель может быть формально интегрирована в 
нее, причем единственным способом~--- путем полного <<сокрытия>> своей 
структуры. В~свою очередь, морфизм вида $e:\ \mathbf{1}\hm\rightarrow S$, где 
$\mathbf{1}$~--- терминальный объект, задает элемент 
   модели~$S$~\cite{12-kov}. Например, в категории \textbf{Set}, состоящей из 
всех множеств и всех отображений, терминальным объектом служит 
одноэлементное множество. Любое множество отображается в него 
единственным образом, а любое отображение его в некоторое множество 
выделяет один из элементов последнего.
   
   В условиях применения АОП комплексирование сис\-тем происходит 
согласованно на двух уровнях: моделей программ и их аспектных струк\-тур. 
Отражение действий по интеграции на \mbox{уровне} классов задач, образующих 
аспектную структуру, естественным образом формализуется функтором, 
извлекающим аспектную структуру из программы~\cite{13-kov}.
  
  \medskip
  
  \noindent
  \textbf{Определение 1.} Пусть заданы:
   \begin{itemize}
\item категория AO, объектами которой служат формальные 
АО-мо\-де\-ли, а 
морфизмами~--- действия по интеграции (программных систем);
\item функтор str из AO в категорию, обозна\-ча\-емую STR, объектами 
которой служат аспектные структуры АО-мо\-де\-лей, а морфизмами~--- 
действия по интеграции аспектов.
\end{itemize}

\textit{Формальной технологией АОП} называется пара $\langle \mathrm{AO}, \mathrm{str}\rangle$. Формальная 
технология АОП называется \textit{элементарной}, если категория~AO имеет 
терминальный объект и функтор~str сохраняет его (т.\,е.\ переводит в 
терминальный STR-объект).\hfill$\square$
   
   Конечно, не всякая пара, состоящая из категории и действующего из нее 
функтора, пригодна в качестве формализации ка\-кой-ли\-бо сущест\-ву\-ющей 
(или возможной в будущем) технологии АОП~--- для этого необходимо 
наложить ряд громоздких дополнительных условий. Наиболее простое из них 
состоит в том, что любая аспектная структура~$Q$ должна быть реализуема~--- 
должна существовать АО-мо\-дель~$A$ такая, что $\mathrm{str}(A) \hm= Q$. Однако 
результаты настоящей работы не зависят от таких условий, поэтому, чтобы 
облегчить чтение, они здесь не приводятся. Интересующихся читателей 
отсылаем к работам~\cite{14-kov, 15-kov}.
   
   
   
   При описании частных методов программирования объектами формальных 
технологий служат модели программ того или иного вида: алгебраические 
спецификации, графы, термы лямб\-да-ис\-чис\-ле\-ния и~т.\,д. Простой пример 
появляется в формальном подходе к инженерии данных. Наиболее общая 
модель массива данных представляет собой множество, состоящее из 
хранящихся в нем информационных элементов. Действие по интеграции 
массивов~--- это в точности любое отображение множеств, поскольку каждому 
элементу мас\-си\-ва-ком\-по\-нен\-та со\-по\-став\-ля\-ет\-ся единственный элемент 
мас\-си\-ва-сис\-те\-мы. Конкретные информационные технологии оперируют со 
специальными видами множеств; например, таблица в реляционной базе данных 
представляет собой подмножество прямого произведения основных множеств 
типов атрибутов (domains, см., например,~\cite{16-kov}). 

Интеграция двух 
таб\-лиц выполняется путем формирования внешнего ключа~--- отображения\linebreak 
множества всех записей одной таб\-ли\-цы во множество записей второй. Таким 
образом, морфизмы таких множеств и составленные из них диаграммы 
описывают конструкции реляционной\linebreak алгебры. При моделировании 
   объ\-ект\-но-ори\-ен\-ти\-ро\-ван\-ных баз данных множества сопоставляются 
классам, а отображения~--- декларации атрибутов и 
   наследованию~\cite{17-kov}. Применение АОП в инженерии данных можно 
смоделировать без ограничения общности: в соответствии с соображениями, 
изложенными во введении, элементы массивов помечаются именами классов 
задач, оперирующих с ними~\cite{18-kov}. Например, в системах 
технологического управления ведется общий реестр оборудования, 
включающий технологические узлы, измерительные приборы и 
исполнительные механизмы, вы\-чис\-ли\-тель\-ные устройства и~др. В~целях 
разделения единиц оборудования по их назначению в реестр добав\-ляется 
специальный ат\-ри\-бут-мет\-ка, име\-ющий перечислимый тип (классификатор 
оборудования). 

По существу (с точностью до изоморфизма), разметка является 
отношением эквивалентности, классы которого отвечают отдельным аспектам, 
так что аспектная структура представляет собой фак\-тор-мно\-жест\-во. 
Действиям по интеграции отвечают в точности все отображения, со\-вмес\-ти\-мые 
с аспектной структурой, т.\,е.\ сохраняющие разметку. Получается формальная 
технология АОП $\mathrm{ADM}\hm = \langle\mathbf{Equ}, \mathrm{fs}\rangle$, где 
   \textbf{Equ}~--- категория всех множеств с отношением эквивалентности и 
всех их гомоморфизмов, fs:\ $\mathbf{Equ}\hm\rightarrow \mathbf{Set}: \langle 
S, \sim\rangle \mapsto S/\sim$~--- функтор вычисления 
   фак\-тор-мно\-жест\-ва~\cite{13-kov}. Эта формальная технология 
элементарна, поскольку одноэлементное множество с тривиальным 
отношением эквивалентности является терминальным \textbf{Equ}-объ\-ектом.
   
    Немного сложнее технологии моделирования данных выглядит формальная 
технология АОП, отвечающая моделированию процессов функционирования систем. 
Строительным материалом для моделей процессов служат сценарии~--- 
последовательности действий и взаимодействий, происходящих при определенных 
условиях, изложенные без предложений с <<если>> и ветвления~\cite{19-kov}. 
(Здесь слово <<последовательность>> следует понимать в широком смысле, так как 
сценарий может содержать взаимно независимые параллельные события, ни одно из 
которых не следует за другим.) Поэтому АО-мо\-делью здесь служит помеченный 
сценарий~--- множество событий, частично упорядоченное причинно-следственной 
связью и размеченное классами порождающих их задач~\cite{14-kov, 20-kov}. При 
интеграции сценариев сохраняется и порядок, и разметка. Примером служит 
подключение единого журнала событий: журнал формально задается множеством 
вещественных чисел~$\mathbb{R}$ с естественным линейным порядком, описывающим 
стрелу физического времени, и одноэлементной разметкой (задача 
<<журналирование>>), а регистрация в нем событий, образующих сценарий~$X$,~--- 
гомоморфизмом вида $t:\ X\hm\rightarrow\mathbb{R}$. Таким образом получается 
элементарная формальная технология АОП $\mathrm{ASM}\hm = \langle \mathbf{PosEqu}, \mathrm{fs} 
\circ \mathrm{equ}\rangle$, где \textbf{PosEqu}~--- категория всех частично 
упорядоченных множеств с отношением эквивалентности и всех их гомоморфизмов, 
$\mathrm{equ}:\ \mathbf{PosEqu}\hm\rightarrow \mathbf{Equ}:\ \langle S, \leq, 
\sim\rangle \mapsto \langle S, \sim\rangle$~--- функтор, <<забывающий>> 
частичный порядок~\cite{13-kov}. Подобный подход к моделированию сценариев был 
предложен еще в 1980-х~гг.~\cite{21-kov}, однако природа меток и способы их 
синтеза оставались неясными, поскольку они не рассматривались в контексте АОП. 
Фактически моделирование поведения сис\-тем помеченными сценариями выступает в 
роли операционной семантики АОП, поскольку, как будет показано ниже, оно 
непосредственно отражает концепцию связывания аспектов (weaving). Его частный 
случай, охватывающий упрощенный вариант АОП, известен как трассовая семантика 
аспектов~\cite{22-kov}. Частные технологии инженерии процессов оперируют с 
разнообразными классами сценариев (подклассами в Ob \textbf{PosEqu}), позволяя 
записывать их в различных специализированных нотациях: графических, 
алгебраических, гипертекстовых, сетей Петри и~др.
   
   Заметим, что формальная технология моделирования данных ADM 
является <<корефлексивной подтехнологией>> в ASM: функтор полного вложения 
$\mathrm{equ}^*:\ \mathbf{Equ} \hookrightarrow \mathbf{PosEqu}:\ \langle S, 
\sim\rangle\mapsto \langle S, =, \sim\rangle$ является левым сопряженным и 
одновременно правым обратным к equ, так что $(\mathrm{fs} \circ \mathrm{equ}) \circ 
\mathrm{equ}^* \hm=  \mathrm{fs}$. Благодаря этому можно обеспечить полную трассируемость данных к процессам, 
снабжая элементы данных метками классов задач, в процессе выполнения которых 
они порождаются или модифицируются. Пример такого совместного моделирования 
данных и процессов будет приведен в конце\linebreak разд.~4.
   
   Основываясь на подходах, описанных в литературе по теории АОП, можно 
построить ряд более частных и более сложных формальных технологий. 
Однако в настоящей работе ограничимся двумя вышеописанными, поскольку 
основной объем работ по созданию широкого класса программных систем 
относится к моделированию данных и процессов.

\section{Аспекты и связывание}

   Рассеяние задач приводит к повышению затрат на проектирование и 
эксплуатацию программных систем во многом из-за того, что сборка системы может 
разрушить аспектную структуру ее компонентов. Избежать этого можно путем 
применения действий по интеграции, позволяющих идентифицировать аспектную 
структуру компонента в структуре системы путем трассирования. Наилучшим же с 
точки зрения АОП является действие, не вызывающее существенных изменений в 
аспектной структуре. Зафиксируем произвольную формальную технологию АОП $\mathrm{AS} 
\hm= \langle \mathrm{AO}, \mathrm{str}\rangle$. На языке теории категорий трассирование действия 
(AO-мор\-физ\-ма) $f:\ X\hm\rightarrow S$ в направлении от результата к 
источнику естественно описать AO-мор\-физ\-мом $\g: S \hm\rightarrow X$, 
левым обратным к~$f$, т.\,е.\ удовлетворяющим условию $\g\circ f \hm = 1_X$. 
Отметим, что любое трассируемое\linebreak действие является регулярным мономорфизмом~--- 
категорным аналогом вложения. Если, в свою \mbox{очередь}, морфизм~$f$ пригоден для 
трассирования морфизма~$\g$, т.\,е.\ если $f\circ\g \hm= 1_S$, то изменение, 
вызываемое действием, можно считать несущественным: как обычно в теории 
категорий, несущественному изменению отвечает изоморфизм~--- морфизм, обратимый 
как слева, так и справа~[12, разд.~3.4]. Эти соображения служат мотивировкой 
для нижеследующего определения.
  
  \medskip
  
  \noindent
  \textbf{Определение 2.} Aспектно-ориентированный мор\-физм~$f$ называется \textit{аспектным}, 
если $\mathrm{str}(f)$ является сечением (т.\,е.\ имеет левый обратный), и 
\textit{изоаспектным}, если $\mathrm{str}(f)$ является изоморфизмом.\hfill$\square$
   
   \medskip
   
   Например, в технологиях АОП, построенных в разд.~3, аспектными являются 
отображения c непустой областью, факторизующиеся в инъекции. Они не 
<<склеивают>> метки и потому допускают однозначное трассирование на 
уровне аспектной структуры.
   
   Аспектом (aspect) называется элементарный строительный блок 
   ас\-пект\-но-ори\-ен\-ти\-ро\-ван\-ной программы, реализующий отдельный 
класс задач. Как указывалось в разд.~2, технология АОП нацелена на 
сохранение идентичности аспектов в составе программы, поэтому их аспектная 
структура не может быть разрушена при интеграции в любую сис\-те\-му. Это 
свойство и составляет формальное определение аспекта. Подчеркнем, что оно 
выходит за рамки классического АОП, где аспект обязательно должен 
вставляться в некоторую базовую программу посредством связывания: 
предлагаемая семантика позволяет избавиться от заложенного классиками 
неявного порочного круга. Например, будет доказано, что в элементарной 
формальной технологии АОП аспекты~--- это в точности все АО-мо\-де\-ли, 
аспектная структура которых элементарна.
  
  \medskip
  
  \noindent
  \textbf{Определение 3.} Аспектно-ориентированная модель~$A$ называется \textit{аспектом}, если 
любой AO-мор\-физм с областью~$A$ является аспектным.\hfill$\square$
  \medskip
  
  \noindent
  \textbf{Предложение 1.} Следующие утверждения эквивалентны для любой 
АО-мо\-де\-ли~$A$:
   \begin{itemize}
\item[(i)] $A$ является аспектом;
\item[(ii)] $A$ изоморфно аспекту; 
\item[(iii)] существует изоаспектный морфизм, на\-прав\-лен\-ный из некоторого 
аспекта в~$A$;
\item[(iv)] существует сечение, направленное из~$A$ в некоторый аспект.
\end{itemize}

\medskip

\noindent
  Д\,о\,к\,а\,з\,а\,т\,е\,л\,ь\,с\,т\,в\,о\,.\ \ 
   
(i)\;$\Rightarrow$\;(ii). Тождественный морфизм $1_A : A\rightarrow A$ 
является изоморфизмом.

   (ii)\;$\Rightarrow$\;(iii). Любой AO-изо\-мор\-физм изоаспектен.
   
   (iii) \;$\Rightarrow$\;(i). Если $B$~--- аспект и $u : B\rightarrow A$~--- 
   AO-мор\-физм, то согласно определению~3 $\mathrm{str}(f \circ u)$ является сечением для 
любого  
   AO-мор\-физ\-ма~$f$ с областью~$A$. В~частности, если $u$ изоаспектен, то 
STR-мор\-физм $\mathrm{str}(f) \hm= \mathrm{str}(f \circ u) \circ \mathrm{str}(u)^{-1}$ является сечением.
   
(i) \;$\Rightarrow$\;(iv). Тождественный морфизм $1_A$ является сечением.

   (iv) \;$\Rightarrow$\;(iii). Рассмотрим сечение $s : A\rightarrow B$, где $B$~--- 
аспект. Пусть $s^\prime  : B \rightarrow A$~--- AO-мор\-физм такой, что 
$s^\prime \circ s \hm= 1_A$. STR-мор\-физм $\mathrm{str}(s^\prime)$ имеет как правый 
обратный (это $\mathrm{str}(s)$), так и левый обратный (определение~3), следовательно, он 
является изоморфизмом, т.\,е.\ $s^\prime$ изоаспектен.\hfill$\square$
  
  \medskip
  
  \noindent
  \textbf{Предложение 2.} Если формальная технология AS элементарна, то 
следующие утверждения эквивалентны для любой АО-мо\-де\-ли~$A$:
   \begin{itemize}
   \item[(i)] $A$ является аспектом;
   \item[(ii)] $\mathrm{str}(A)$ является терминальным STR-объ\-ек\-том;
   \item[(iii)] существует аспектный морфизм, направленный из~$A$ в 
некоторый аспект.
   \end{itemize}
   
   \medskip
   
   \noindent
  Д\,о\,к\,а\,з\,а\,т\,е\,л\,ь\,с\,т\,в\,о\,.\ Напомним, что терминальный объект 
традиционно обозначается через~\textbf{1}. Заметим, что в любой категории: 
(а)~любой морфизм вида $i : \mathbf{1}\rightarrow X$ является сечением 
(морфизм $!_X : X\rightarrow \mathbf{1}$ является левым обратным к нему), 
поэтому (б)~любое сечение вида $!_X : X\rightarrow \mathbf{1}$ является 
изоморфизмом.
   
   (i) \;$\Rightarrow$\;(ii). Если $A$~--- аспект, то ввиду~(б) морфизм $\mathrm{str}(!_A)$ 
является изоморфизмом.
   
   (ii) \;$\Rightarrow$\;(i). Если $\mathrm{str}(A)$~--- терминальный объект, то в силу~(a) 
любой морфизм с областью~$A$ является аспектным.
   
   (i) \;$\Rightarrow$\;(iii). Тождественный морфизм $1_A$ является аспектным.
   
   (iii) \;$\Rightarrow$\;(ii). Если $B$~--- аспект (т.\,е., как уже доказано, 
$\mathrm{str}(B)$~--- терминальный объект) и $u : A \rightarrow B$~--- аспектный 
   AO-мор\-физм, то $\mathrm{str}(u)$ представляет собой сечение, направленное в 
терминальный объект. Поэтому ввиду~(б) $\mathrm{str}(A)$ также является терминальным 
объектом.\hfill$\square$

\smallskip
   
   Рассмотрим процедуру связывания системы из аспектов. Напомним, что в 
классическом АОП оно состоит в подключении программы~$W$, называемой 
советом (advice), к базовой программе (base) $B$ в заданных местах, 
называемых точками соединения (join points). Каждый раз, когда при 
исполнении базовой программы встречается точка соединения, вызывается 
совет. Поэтому последний обычно выглядит как блок программного кода, 
охраняемый (guarded) условием, идентифицирующим точку соединения; начало 
блока служит точкой вызова совета (entry point). Пример такого блока на языке 
AspectJ был приведен в разд.~2. Таким образом, инструмент связывания 
(weaver) принимает на вход две спецификации:
   \begin{enumerate}[(1)]
\item описание точек соединения в базовой программе, или срез (pointcut);
\item описание точек вызова совета в точках соединения.
\end{enumerate}

   При связывании сначала (виртуально) создается достаточное количество 
копий совета, по одной на каждую точку соединения, с маркировкой 
соответствующих им точек вызова. Далее эти точки <<склеиваются>> друг с 
другом так, чтобы не разрушить аспектную структуру базы и совета. Для 
формальной записи правил связывания привлекается дополнительная 
   АО-мо\-дель~$C$, называемая связкой (connector, см.~\cite{23-kov}), которая 
интегрируется с базой в точках соединения, а с советом~--- в точках вызова. 
В~технологиях типа AspectJ в роли связки выступает регулярное выражение, 
выделяющее в тексте базовой программы синтаксические единицы, 
образующие срез (конструкция pointcut). Соответствие точек соединения 
точкам вызова задается парой AO-мор\-физ\-мов $j : B \leftarrow C\rightarrow 
W : e$ (здесь наглядно проявляется отличие связывания от модульной 
компоновки, формализуемой одношаговым действием вида $l : M \rightarrow 
S$, где $M$~--- модуль, $S$~--- сис\-те\-ма). 

Как легко видеть на примере 
формальной технологии АОП для моделирования сценариев, первый шаг 
связывания может быть формализован как построение произведения $C\times 
W$, а второй~--- кодекартова квадрата (стандартная конструкция склеивания 
элементов множества). Эти операции должны быть естественными 
относительно вы\-чис\-ле\-ния аспектной структуры, чтобы получилось связывание 
разметок: указанные универсальные конструкции должны сохраняться 
функтором str. 

В~лите\-ра\-туре рассмотрены два частных случая вы\-чис\-ле\-ния 
связывания как кодекартова квадрата того или иного вида: когда метки 
трактуются как роли~\cite{24-kov} и когда аспекты задаются как инварианты 
поведения программ, описанных ал\-геб\-ра\-иче\-ски\-ми 
   спецификациями~\cite{25-kov}. Данное выше определение, напротив, имеет 
общий характер, и оно отражает ряд интуитивно ожидаемых свойств 
связывания (например, возможность трассируемого включения базы в 
результат).
  
  \medskip
  
  \noindent
  \textbf{Определение 4.}\ \textit{Аспектным связыванием} пары 
AO-мор\-физ\-мов $j : B\leftarrow C \rightarrow W : e$, где $B$ называется 
базой, $W$~--- советом, $C$~--- связкой, называется кодекартов квадрат пары $j 
: B\leftarrow C\rightarrow C\times W : \langle 1_C, e\rangle$ (схемы 
связывания), если он существует (в част\-ности, существует произведение $C\times 
W$) и функтор str сохраняет как произведение $C\times W$ (переводит его в 
произведение), так и этот кодекартов квадрат (переводит его в кодекартов 
квадрат). \textit{Результатом связывания} называется вершина кодекартова 
квадрата, обозначается через $j \bowtie e$ (рис.~1).\hfill$\square$

\vspace*{6pt}
   
   \begin{center}
 \mbox{%
 \epsfxsize=45.546mm
 \epsfbox{kov-1.eps}
 }

 \vspace*{12pt}
 
 {{\figurename~1}\ \ \small{Кодекартов квадрат связывания}}
   \end{center}


\columnbreak

%\vspace*{15pt}

\addtocounter{figure}{1}




\noindent
\textbf{Предложение 3.} Для любой пары $$j: B\leftarrow C \rightarrow W : e\,,$$ 
обладающей связыванием, справедливы сле\-ду\-ющие утверждения:
\begin{itemize}
   \item[(i)] результат связывания определяется единственным образом (с 
точностью до изоморфизма);
   \item[(ii)] существует обратимое слева (в частности, аспектное) вложение $b : 
B \hookrightarrow  (j \bowtie e)$;
   \item[(iii)] если результат связывания является аспектом, то и база является 
аспектом;
   \item[(iv)] если $j$~--- изоморфизм, то $j \bowtie e \cong B\times W$.
   \end{itemize}
   
   \medskip
   
  \noindent
  Д\,о\,к\,а\,з\,а\,т\,е\,л\,ь\,с\,т\,в\,о\,.
   \begin{itemize}
   \item[(i).] Вытекает из универсальности (ко)пределов.
   \item[(ii).] Имеем $\pi_C \circ \langle\mathbf{1}_C,e\rangle \hm=\mathbf{1}_C$, 
где $\pi_C : C\times  W \rightarrow C$~--- проекция, так что $\langle 
\mathbf{1}_C,e\rangle$~--- сечение. В~свою очередь, как легко проверить, ребро 
кодекартова квадрата, параллельное сечению, само является сечением (см.\ 
двойственное утверждение в [11, предложение~11.18]).
   \item[(iii).] Вытекает из утверждения~(ii) и предложения~1 (эквивалентность 
(i)\;$\Leftrightarrow$\;(iv)).
   \item[(iv).] Ребро кодекартова квадрата, параллельное изоморфизму, само 
является изоморфизмом.\hfill$\square$
   \end{itemize}
   
   Утверждение~(ii) предложения~3 позволяет описать многошаговое 
связывание взаимно независимых советов с общей базой: если имеются 
связываемые пары 
\begin{gather*}
j : B \leftarrow C \rightarrow W : e\,;\\
 j^\prime : B \leftarrow  C^\prime \rightarrow W^\prime : e^\prime\,,
 \end{gather*}
 то их можно естественным образом 
собрать в одно целое путем связывания пары $b \circ j^\prime : (j \bowtie e) 
\leftarrow C^\prime \hm\rightarrow W^\prime : e^\prime$. Покажем, что результат 
здесь не зависит от порядка привязки советов.
   
   \medskip
   
   \noindent
   \textbf{Предложение~4.} Если пары $j : B \leftarrow C \rightarrow W : e$, 
$j^\prime : B \leftarrow C^\prime \rightarrow W^\prime : e^\prime$, $b\circ  j^\prime 
: (j \bowtie e) \leftarrow C^\prime \rightarrow W^\prime : e^\prime$, $b^\prime 
\circ j : (j^\prime \bowtie e^\prime) \leftarrow C \rightarrow W : e$ обладают 
связыванием, то $(b \circ j^\prime) \bowtie e^\prime \cong  (b^\prime \circ  j) 
\bowtie e$.
  
  \medskip
  
  \noindent
  Д\,о\,к\,а\,з\,а\,т\,е\,л\,ь\,с\,т\,в\,о\,.\ Пусть $AO$-мор\-физ\-мы $u$, $v$, $w$ 
таковы, что соотношения $u\circ\langle \mathbf{1}_C,e\rangle = b \circ j$ и 
$v\circ \langle \mathbf{1}_C,e\rangle = w \circ (b^\prime \circ j)$ задают 
кодекартовы квадраты. Тогда существует морфизм $q : (j \bowtie e) \rightarrow 
(b^\prime \circ  j) \bowtie e$ такой, что $q \circ u = v$ и $q\circ  b = w 
\circ b^\prime$. В~силу общего утверждения, двойственного к известной лемме о 
декартовых квадратах~[12, предложение 11.10 (2)], второе из этих равенств 
определяет кодекартов квад\-рат пары $b : (j \bowtie e) \hookleftarrow B 
\hookrightarrow (j^\prime \bowtie e^\prime) : b^\prime$ с вершиной $(b^\prime 
\circ j) \bowtie  e$. Рассуждая аналогично, по-\linebreak\vspace*{-12pt}



\begin{center}
 \mbox{%
 \epsfxsize=78.086mm
 \epsfbox{kov-2.eps}
 }
 


 
  \vspace*{6pt}
 
 {{\figurename~2}\ \ \small{К доказательству предложения~4}}
  \end{center}


%\pagebreak

\vspace*{15pt}

\addtocounter{figure}{1}

\noindent
лучаем, что объект $(b \circ  
j^\prime) \bowtie  e^\prime$ является вершиной кодекартова квадрата той же 
пары (рис.~2).\hfill$\square$




   Эффект перемешивания классов задач при связывании ярко проявляется, 
если совет является достаточно мелкой единицей аспектной архитектуры, 
например аспектом. База связывания в некоторой степени поглощает такую 
единицу, затрудняя ее идентификацию в составе системы. Для формальной 
характеризации таких единиц введем сле\-ду\-ющее понятие. Будем называть 
объект некоторой категории \textit{частично терминальным}, если из любого 
объекта в него имеется не более одного морфизма. Объект, изоморфный 
частично терминальному, сам является частично терминальным. Ясно, что 
любой терминальный объект является частично терминальным. В~любой 
категории предпорядка все объекты частично терминальны.
   
  \medskip
  
  \noindent
  \textbf{Предложение 5.} Для любой пары 
  $$
  j : B \leftarrow C\rightarrow W : e\,, 
  $$
обладающей связыванием, справедливы следующие утверждения:
   \begin{itemize}
\item[(i)] если $W$~--- частично терминальный AO-объ\-ект, то $j\bowtie  e 
\cong B$;
\item[(ii)] если $str(W)$~--- частично терминальный STR-объ\-ект, то $\mathrm{str}(j 
\bowtie  e) \cong \mathrm{str}(B)$.
  \end{itemize}
  
  \medskip
  
  \noindent
  Д\,о\,к\,а\,з\,а\,т\,е\,л\,ь\,с\,т\,в\,о\,. Сначала заметим, что если $X$~--- 
частично терминальный объект в произвольной категории и в ней существует 
морфизм $f : Y \rightarrow X$, то объект~$Y$ представляет собой произведение 
$Y\times X$ с проекциями $1_Y$ и $f$ (с точностью до изоморфизма).
   \begin{itemize}
   \item[(i).] Если $W$~--- частично терминальный AO-объ\-ект, то, как было 
только что установлено, $\pi_C$~--- изоморфизм, поэтому $\langle 1_C, 
e\rangle$~--- изоморфизм.
   \item[(ii).] Поскольку $\mathrm{str}(C \times  W) \hm= \mathrm{str}(C) \times \mathrm{str}(W)$, аналогично 
предыдущему получаем, что $\langle 1_C,e\rangle$~--- изоаспектный 
   AO-мор\-физм. \hfill$\square$
   \end{itemize}
   
   \medskip
   
   Рассмотрим аспекты и связывание в формальных технологиях АОП, 
описанных в разд.~2. Со\-гласно предложению~2, здесь аспект~--- это в точности 
любое непустое множество, все элементы которого помечены одной и той же 
меткой. Отношение эквивалентности, задающее разметку, разбивает 
   АО-мо\-дель на совокупность непересекающихся аспектов. Частично 
терминальными объектами являются только пустое и одноэлементное 
множество. 

В~технологии моделирования данных ADM связывание существует 
всегда, поскольку категория \textbf{Equ} (ко)полна, а функтор 
факторизации~fs сохраняет произведения (проверяется непосредственно) и 
копределы (поскольку он имеет правый сопряженный $\mathrm{fs}_* : 
\mathbf{Set}\hookrightarrow \mathbf{Equ} : S \mapsto \langle S, =\rangle$). 

Результат связывания получается из раздельного объединения~$B\amalg 
(C\times  W)$ путем амальгамирования~--- факторизации по отношению 
эквивалентности, порожденному множеством пар $\{(j(x), (x, e(x))) \vert  x \hm\in 
C\}$~[11, разд.~3.14]. Связывание имеет прозрачный смысл для реляционных 
таблиц: здесь спецификация связывания описывает добавление к базе атрибута 
типа <<список ссылок на совет>> (отношение вида <<многие ко многим>>), с 
использованием связки в качестве источника ссылочных ключей. 
%
Добавление 
атрибута является неразрушающим в том смысле, что структура базовой 
таблицы не меняется, поэтому оно не требует значительных затрат. Такой 
прием характерен для ас\-пект\-но-ори\-ен\-ти\-ро\-ван\-ной разработки 
информационных моделей сложных объектов управления, элементам которых 
свойственно вступать в многообразные и изменчивые отношения~\cite{18-kov}. 
Здесь метки связки обозначают функции (роли) отношений между сущностями, 
описываемыми в таблицах базы и совета. Отношения, помеченные ролями, 
возникают между видами объектов и средств управ\-ле\-ния (онтологические 
отношения), их типами и марками (нормативные) и экземплярами 
(фактические). Например, на онтологическом уровне описываются 
возможности установки различных видов приборов, реализующих те или иные 
функции управления, на различных видах зданий и сооружений, на 
нормативном~--- правила выбора марок приборов для оснащения зданий 
различных серий, на фактическом~--- результаты работ по монтажу конкретных 
приборов в конкретных зданиях.
   
   В~формальной технологии моделирования сценариев ASM связывание 
существует не всегда, хотя \textbf{PosEqu} и (ко)полна: функтор equ имеет 
левый сопряженный (дискретное упорядочение $\mathrm{equ}^*$) и поэтому сохраняет 
все пределы, но не имеет правого сопряженного. Амальгамирование в общем 
случае превращает естественный частичный порядок раздельного объединения 
$B\amalg (C \times W)$ в предпорядок, поэтому выполняется дополнительная 
факторизация по отношению, обозначаемому через ${\overset{\leq}{>}}^\infty$, 
которое отождествляет изоморфные элементы этого предпорядка 
(рассматриваемого как категория). Чтобы схема связывания порождала 
кодекартов квадрат на уровне аспектной структуры, связка должна быть 
совместима с конкуррентностью (concurrency) в том смысле, что она не должна 
фиксировать порядок вызова различных аспектов совета, привязываемых к 
одной точке соединения~\cite{20-kov}. Это условие выполняется в технологиях 
АОП, позволяющих совету иметь только одну точку вызова, например в 
AspectJ. Формально оно задается следующим образом.
  
  \bigskip
  
  \noindent
  \textbf{Предложение 6.} Связывание пары \textbf{PosEqu}-мор\-физ\-мов $j 
: B \leftarrow C \rightarrow W : e$ существует тогда и только тогда, когда для 
любых $x, y \in C$ условия $j(x) \hm= j(y)$ и $x \hm\leq y$ влекут $v \sim  e(x)$ 
для любого $v\hm\in W$ такого, что $e(x) \hm\leq v \hm\leq e(y)$.
  
  \medskip
  
  \noindent
  Д\,о\,к\,а\,з\,а\,т\,е\,л\,ь\,с\,т\,в\,о\,. Чтобы множество меток копреде\-ла схемы 
связывания было амальгамой ее str-об\-ра\-за, необходимо и достаточно, чтобы 
факторизация по отношению ${\overset{\leq}{>}}^\infty$ не привела к 
отождествлению различных меток. Это равносильно тому, что для любых $x, y 
\hm\in C$ таких, что $j(x) \hm= j(y)$ и $x\hm\leq y$, отображение $\mathrm{str}(\langle 
1_C, e\rangle) : \mathrm{str}(C) \hm\rightarrow \mathrm{str}(C) \times \mathrm{str}(W)$ устанавливает биекцию 
между множествами $\mathrm{str}(\{z\vert  x \leq z \leq y\})$ и $\mathrm{str}(\{(z, v) \vert x 
\hm\leq z \hm\leq y \wedge e(x) \hm\leq v \hm\leq e(y)\})$, т.\,е.\ тому, что $\vert 
\mathrm{str}(\{v \vert  e(x) \hm\leq v \hm\leq e(y)\})\vert  = 1$.\hfill$\square$
   
   \medskip
   
   Рассмотрим связывание сценариев при проектировании 
   ин\-фор\-ма\-ци\-он\-но-управ\-ля\-ющих сис\-тем с применением 
событийной модели. Здесь совет представляет собой обработчик событий базы, 
образующих срез. Инструмент связывания можно рассматривать как монитор 
исполнения сценария базы, который при обнаружении точек соединения 
вызывает исполнение сценариев связываемых с ними советов. Сценарий 
функционирования монитора описывается связкой~--- центральным объектом в 
спецификации связывания. 

Таким образом, событийное программирование 
(event-based programming) является одним из способов реализации 
   ас\-пект\-но-ори\-ен\-ти\-ро\-ван\-но\-го подхода~\cite{20-kov}. Оно придает 
системе способность реагировать на изменения в окружении, регистрируемые в 
виде событий, путем динамической подстройки хода исполнения 
процессов~\cite{26-kov}.
   
   Крупноблочный базовый сценарий~$B$ основного процесса 
функционирования системы состоит в повторяющемся исполнении следующей 
цепи классов задач по обработке событий, возникающих на объекте 
управления:
   \begin{multline*}
    \mbox{регистрация}\rightarrow   \mbox{сохранение} 
    \rightarrow  {}\\
{}    \rightarrow\mbox{анализ} \rightarrow   \mbox{воздействие}\,.
   \end{multline*}

   Инфраструктурные аспекты, обеспечивающие его корректную работу, 
например паспорт объекта и средства защиты информации, комплексируются с 
ним путем связывания, нарушая возможность разделения сценария на модули. 
Чтобы исполнять разные стадии основного цикла обработки событий на разных 
аппаратных узлах, необходимо реплицировать инфраструктуру между ними. 
Такая репликация вызывает основные трудности при проектировании и 
эксплуатации распределенных систем по сравнению с локальными (автоматизированными
сис\-те\-ма\-ми управ\-ле\-ния технологическими процессами), 
поэтому привлечение технологий АОП способствует снижению затрат. 

Рассмотрим следующий пример. При сохранении события в базу данных 
системы может потребоваться внести изменение в паспорт объекта, если оно 
сигнализирует о фактических изменениях его структуры, например о замене 
прибора. Другие фрагменты паспорта могут измениться по результатам 
анализа, если выявлено его несоответствие объекту: например, 
зарегистрировано потребление энергии единицей оборудования, не связанной в 
паспорте ни с каким питающим центром. Поведение аспекта изменения 
паспорта~$W$ можно упрощенно описать сценарием из двух событий, 
относящихся к одному классу задач:
$$
    \mbox{изменение}_{\mathrm{запрос}}\rightarrow   \mbox{изменение}_{\mathrm{внес}}\,.
    $$

Его связка с базовым сценарием имеет вид дискретного двухэлементного 
сценария $\mathbf{1}\,\amalg\,\mathbf{1}$~---, где \textbf{1}~--- терминальный 
\textbf{PosEqu}-объ\-ект: морфизм~$j$ представляет собой его биекцию на 
подмножество $\{\mbox{сохранение, анализ}\} \hm\subseteq B$, а $e$~--- постоянное 
отоб\-ра\-же\-ние на элемент $\mbox{изменение}_{\mathrm{запрос}}\hm\in W$. Как легко проверить, 
связывание существует и по\-рож\-да\-ет следующий сценарий:
{\small\begin{equation*}
\begin{array}{ccccccc}
   \mbox{регистрация} &\rightarrow \!&\!\!\!\!\mbox{сохранение}\! 
   &\!\!\!\!\!\rightarrow \!&\!\!\!\!\!\mbox{анализ}\! &\!\!\!\!\!\!\rightarrow\! 
   &\!\mbox{\ воздействие},\hspace*{-0.7pt}\\
   \!&\!&\!\downarrow\!&\!&\!\downarrow\!&\!&\\
                         \!&\!&\!\!\!\mbox{сохранение}_{\mathrm{внес}} \!&\!
                         &\!\mbox{анализ}_{\mathrm{внес}} \!&\!&
    \end{array}
    \end{equation*}
    }
где индексом $внес$ снабжены события соответствующих классов задач, 
фиксирующие внесение изменений в паспорт объекта. В~соответствии с 
утверждением~(ii) предложения~5 метка аспекта изменения паспорта в этом 
сценарии отсутствует~--- она <<сливается>> с метками точек соединения. В~то 
же время каждый акт изменения паспорта приобретает пометку 
инициировавшей его задачи, которую можно сохранить вместе с изменяемыми 
данными (при условии, что хранилище данных паспорта спроектировано на 
базе технологии ADM). Таким образом, задача ведения паспорта 
рассеивается по про\-цес\-сам-ис\-точ\-ни\-кам данных с обеспечением 
трассирования каждого элемента к задачам, вызвавшим его изменение. Это 
позволяет обеспечить практически полную актуальность и достоверность 
паспорта.

\section{Заключение}

   В настоящей работе представлена теоретико-ка\-те\-гор\-ная семантическая 
модель АОП, поз\-во\-ля\-ющая формализовать процедуру связывания аспектов и 
доказать ее главные свойства. Она отличается от подходов к формализации 
АОП, предложенных в литературе, поскольку они представлены в терминах 
частных формализмов и могут применяться только в рамках частных парадигм 
программирования. Модели АОП строились с привлечением почти всех 
формализмов теоретического программирования, таких как алгебра 
процессов~\cite{27-kov}, лямб\-да-ис\-чис\-ле\-ние~\cite{28-kov}, 
преобразования графов~\cite{29-kov}, проверка на моделях~\cite{30-kov}, 
языки описания архитектуры~\cite{23-kov} и~др. В~противоположность им 
была предложена и теоретически обоснована единая концепция технологии 
АОП с приложением к моделированию данных и сценариев исполнения 
процессов~--- ключевых составляющих широкого класса программных 
   сис\-тем. Эта концепция предлагает явно размечать модели массивов данных 
и процессов на фрагменты, образующие средства решения отдельных классов 
задач, и в дальнейшем оформлять их самостоятельными единицами 
   комплексирования~--- аспектами. Вхождения аспектов удается формально 
идентифицировать (трассировать) по ходу сборки системы, что снижает 
затраты на ее создание и эксплуатацию.
   
   Такой подход был апробирован при проектировании программной 
платформы учета и управления энергообеспечением 
   <<Энергиус>>~\cite{31-kov}, на базе которой были созданы компоненты 
крупномасштабных систем диспетчерского управления~\cite{18-kov}, 
интеллектуального учета электроэнергии~\cite{32-kov}, управления 
энергоэффективностью~\cite{33-kov} и~др. В~ней были реализованы 
изложенные в настоящей работе проектные решения в области 
   ас\-пект\-но-ори\-ен\-ти\-ро\-ван\-но\-го моделирования данных~\cite{18-kov} 
и процессов~\cite{20-kov}, что позволило снизить ее стоимость по сравнению с 
аналогичными программными продуктами. Конечно, предложенный подход 
нуждается в развитии и расширении сферы применения~--- здесь возникают 
задачи, представляющие перспективные направления дальнейших 
исследований.

{\small\frenchspacing
{%\baselineskip=10.8pt
\addcontentsline{toc}{section}{Литература}
\begin{thebibliography}{99}


\bibitem{1-kov}
\Au{Kiczales G., Lamping J., Mendhekar A., \textit{et al}.} Aspect-oriented programming~// Lecture Notes in Computer Sci., 
1997. Vol.~1241. P.~220--242.
\bibitem{2-kov}
\Au{Steimann F.} The paradoxical success of aspect-oriented programming~// OOPSLA'06 
Proceedings.~--- Portland, 2006. P.~481--497.
\bibitem{3-kov}
\Au{Буч Г.} Объектно-ори\-ен\-ти\-ро\-ван\-ный анализ и проектирование с примерами 
приложений на C++.~--- 2-е изд.~--- М.: Бином; СПб.: Невский диалект, 1999.
\bibitem{4-kov}
\Au{Fiadeiro J.\,L.} Categories for software engineering.~--- Berlin--Heidelberg--N.Y.: Springer, 
2005.
\bibitem{5-kov}
\Au{Morin B., Barais~O., J$\acute{\mbox{e}}$z$\acute{\mbox{e}}$quel~J.\,M.} Weaving aspect 
configurations for managing system variability~// 2nd Workshop (International) on Variability 
Modelling of Software-Intensive Systems VaMoS'08 Proceedings.~--- Essen, 2008. P.~53--62.
\bibitem{6-kov}
\Au{Adams B., De Schutter~K., Zaidman~A., Demeyer~S., Tromp~H., De Meuter~W.} Using aspect 
orientation in legacy environments for reverse engineering using dynamic analysis~--- an industrial 
experience report // J.~Syst. Software, 2009. Vol.~82. No.\,4. P.~668--684.
\bibitem{7-kov}
\Au{Colyer A., Clement A., Harley~G., Webster~M.} Eclipse AspectJ.~--- Reading: 
Addison-Wesley, 2004.
\bibitem{8-kov}
\Au{Rashid A., Chitchyan R.} Aspect-oriented requirements engineering: A~roadmap~// 13th 
Workshop (International) on Early Aspects EA'2008 Proceedings.~--- Leipzig, 2008. P.~35--41.
\bibitem{9-kov}
\Au{Brichau J., Chitchyan~R., Rashid~A., D'Hondt~T.} Aspect-oriented software development: An 
introduction~// Wiley Encyclopedia of Computer Science and Engineering. Vol.~1.~--- N.Y.: Wiley 
and Sons, 2008. P.~188--198.
\bibitem{10-kov}
\Au{Ожегов С.\,И., Шведова Н.\,Ю.} Толковый словарь русского языка.~--- М.: Азъ, 1992.
\bibitem{12-kov}
\Au{Голдблатт Р.} Топосы. Категорный анализ логики.~--- М.: Мир, 1983.

\bibitem{11-kov}
\Au{Ad$\acute{\mbox{a}}$mek J., Herrlich H., Strecker~G.} Abstract and concrete categories.~--- 
N.Y.: Wiley and Sons, 1990.
\bibitem{13-kov}
\Au{Ковалёв С.\,П.} Применение аспектно-ори\-ен\-ти\-ро\-ван\-но\-го подхода для 
автоматизации крупномасштабных объектов и процессов управления~// Управление 
развитием крупномасштабных систем (MLSD'2012): Мат-лы VI Междунар. конф. ~--- 
М.: ИПУ РАН, 2012. Т.~2. С.~315--318.
\bibitem{14-kov}
\Au{Ковалёв С.\,П.} Формальный подход к ас\-пект\-но-ори\-ен\-ти\-ро\-ван\-но\-му 
моделированию сценариев~// Сиб. журн. индустр. математики, 2010. Т.~13. №\,3. С.~30--42.
\bibitem{15-kov}
\Au{Kovalyov S.\,P.} Modeling aspects by category theory~// 9th Workshop on Foundations of 
Aspect-Oriented Languages Proceedings.~--- Rennes, France, 2010. P.~63--68.
\bibitem{16-kov}
\Au{Бениаминов Е.\,М.} Алгебраические методы в теории баз данных и представлении 
знаний.~--- М.: Научный мир, 2003.
\bibitem{17-kov}
\Au{Hru{\normalsize\ptb{\!\!\v{s}}}ka T., Kolen{\normalsize\ptb{\!\!\v{c}}\ptb{\!\!\'{\i}}}k P}. Comparison of categorical foundations of 
object-oriented database model~// Lecture Notes Computer Sci., 1997. Vol.~1341. P.~302--319.
\bibitem{18-kov}
\Au{Андрюшкевич С.\,К.} Построение информационной модели крупномасштабных объектов 
технологического управления c применением ас\-пект\-но-ори\-ен\-ти\-ро\-ван\-но\-го 
подхода~// Вестник НГУ. Сер. Информационные технологии, 2010. Т.~8. №\,3. С.~34--45.
\bibitem{19-kov}
\Au{Коберн А.} Современные методы описания функциональных требований.~--- М.: Лори, 
2002.
\bibitem{20-kov}
\Au{Андрюшкевич С.\,К., Ковалёв С.\,П.} Динамическое связывание аспектов в 
крупномасштабных системах технологического управления~// Вычисл. технологии, 2011. 
Т.~16. №\,6. С.~3--12.
\bibitem{21-kov}
\Au{Pratt V.\,R.} Modeling concurrency with partial orders~// Int. J.~Parallel Programming, 1986. 
Vol.~15. No.\,1. P.~33--71.
\bibitem{22-kov}
\Au{Douence R., Fradet P., S$\ddot{\mbox{u}}$dholt~M.} Trace-based aspects~// Aspect-Oriented Software 
Development.~--- Reading: Addison Wesley, 2004. P.~201--218.
\bibitem{23-kov}
\Au{Pinto M., Fuentes L., Troya~J.\,M.}
DAOP-ADL: An architecture description language for dynamic component and aspect-based 
development~// Lecture Notes Computer Sci., 2003. Vol.~2830. P.~118--137.
\bibitem{24-kov}
\Au{Nakajima S., Tamai T.} 
Weaving in role-based aspect-oriented design models~// Early Aspects'2004: Workshop 
Proceedings.~--- Vancouver, Canada, 2004. 
{\sf http://trese.cs.utwente.nl/workshops/oopsla-early-aspects-2004/Papers/NakajimaEtAl.pdf}.
\bibitem{25-kov}
\Au{Smith D.\,R.} Composition by colimit and formal software development~// Lecture Notes 
Computer Sci., 2006. Vol.~4060. P.~317--332.
\bibitem{26-kov}
\Au{Hermosillo G., Seinturier L., Duchien~L.} 
Using complex event processing for dynamic business process adaptation~//  7th IEEE Conference 
(International) on Services Computing SCC'2010 Proceedings.~--- Miami, 2010. P.~466--473.
\bibitem{27-kov}
\Au{Andrews J.\,H.} 
Process-algebraic foundations of aspect-oriented programming~// Lecture Notes in Computer Sci., 
2001. Vol.~2192. P.~187--209.
\bibitem{28-kov}
\Au{Jagadeesan R., Pitcher~C., Riely~J.} 
Open bisimulation for aspects~//  AOSD'07 Proceedings.~--- Vancouver, Canada, 2007. 
P.~107--120.
\bibitem{29-kov}
\Au{Whittle J., Jayaraman P.}
MATA: A~tool for aspect-oriented modeling based on graph transformation~// Lecture Notes  
Computer Sci., 2008. Vol.~5002. P.~16--27.
\bibitem{30-kov}
\Au{Katz E., Katz S.} Verifying scenario-based aspect specifications~// Lecture Notes Computer 
Sci., 2005. Vol.~3582. P.~432--447.
\bibitem{31-kov}
\Au{Ковалёв С.\,П., Андрюшкевич С.\,К., Гуськов~А.\,Е.}
Интеграционная платформа учета и управления энергообеспечением <<Энергиус>>: 
Свидетельство о государственной регистрации программы для ЭВМ №\,2009613359 от 
26~июня 2009~г.
\bibitem{32-kov}
\Au{Андрюшкевич С.\,К., Ковалёв~С.\,П., Кубышкин~А.\,С., Трегубов~А.\,М.} Проблемы 
автоматизации управления процессами розничного рынка электроэнергии~// Проблемы 
управления и моделирования в сложных системах (ПУМСС-2012): Труды XIV 
Междунар. конф.~--- Самара: СамНЦ РАН, 2012. С.~376--386.

\label{end\stat}

\bibitem{33-kov}
\Au{Ковалёв С.\,П., Паронджанов С.\,С.} 
Концепция создания автоматизированной системы мониторинга и управления 
энергоэффективностью на объектах города Москвы~// 
Ин\-фор\-ма\-ци\-он\-но-из\-ме\-ри\-тель\-ные и управ\-ля\-ющие сис\-те\-мы, 2011. Т.~9. 
№\,6. С.~50--58.
\end{thebibliography}
} }

\end{multicols}