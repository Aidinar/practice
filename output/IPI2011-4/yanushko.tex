\def\stat{yanushko}

\def\tit{РЕШЕНИЕ ПРОБЛЕМ ВЗАИМОДЕЙСТВИЯ С~СУБД 
В~КРОССПЛАТФОРМЕННОЙ БИБЛИОТЕКЕ EFFIDB}

\def\titkol{Решение проблем взаимодействия с~СУБД 
в~кроссплатформенной библиотеке EFFIDB}

\def\autkol{А.\,В.~Янушко, А.\,В.~Бабанин, О.\,А.~Кузнецова, 
С.\,В.~Петрушенко}
\def\aut{А.\,В.~Янушко$^1$, А.\,В.~Бабанин$^2$, О.\,А.~Кузнецова$^3$, 
С.\,В.~Петрушенко$^4$}

\titel{\tit}{\aut}{\autkol}{\titkol}

%{\renewcommand{\thefootnote}{\fnsymbol{footnote}}\footnotetext[1]
%{Работа поддержана Российским фондом фундаментальных исследований
%(проекты 11-01-00515а и 11-07-00112а), а также Министерством
%образования и науки РФ в рамках ФЦП <<Научные и
%научно-педагогические кадры инновационной России на 2009--2013~годы>>.}}


\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{АСофт, yan@asoft.ru}
\footnotetext[2]{Всероссийский научно-исследовательский институт проблем вычислительной техники и информатизации, 
ababanin@pvti.ru}
\footnotetext[3]{АСофт, ok@asoft.ru}
\footnotetext[4]{АСофт, op@asoft.ru}

\vspace*{6pt}

\Abst{Статья затрагивает проблемы унифицированного взаимодействия с разнотипными СУБД 
в различных программных средах. Рассмотрены существующие разработки в данной области, 
проанализированы их достоинства  и недостатки. Перечислены требования к кроссплатформенному 
инструменту взаимодействия прикладного кода С++ с СУБД. Предложено решение, 
реализованное в виде динамической библиотеки. Библиотека предоставляет специализированные 
классы для каждого из понятий реляционных баз данных: собственно база данных, соединение, 
таблица, средства манипулирования данными и~т.\,д. Проанализированы границы применимости 
предложенных решений и практика использования библиотеки в реальных проектах. 
Приведены примеры кода.}

\vspace*{2pt}

\KW{СУБД; C++; библиотека взаимодействия; кроссплатформенность}

\vspace*{6pt}

 \vskip 14pt plus 9pt minus 6pt

      \thispagestyle{headings}

      \begin{multicols}{2}
      
            \label{st\stat}

\section{Введение}

Современные информационные системы автоматизации деятельности предприятий 
пред\-став\-ляют собой многокомпонентные программные комплексы. С~прикладной точки 
зрения в любой информаци\-онной системе можно выделить три логических компоненты: 
слой отображения данных, слой обработки данных и слой хранения данных. 
{\looseness=1

}

Данная 
работа посвящена фундаментальной со\-став\-ля\-ющей информационной системы, а именно 
сис\-те\-мам управления базами данных и средствам взаимодействия серверов приложений с 
различными СУБД.

Несмотря на то что базы данных и СУБД со\-ставля\-ют обширную тему исследований и 
разработок, в этой области остается много нерешенных проб\-лем.

В статье рассматривается проблема организации работы приложений, написанных на C++, 
с множеством разнотипных СУБД. Предлагаемое решение заключается в создании 
промежуточного звена доступа к различным СУБД, при этом разработчик не должен 
задумываться о наличии такого промежуточного слоя и желательно, чтобы 
взаимодействие со средством доступа происходило стандартным образом, с 
использованием распространенных технологий.

\section{Универсальная библиотека взаимодействия с~СУБД~--- EffiDB}

\vspace*{-6pt}

C++ библиотека EffiDB представляет собой набор интерфейсов, позволяющий 
взаимодействовать единым образом с системами управления базами данных. Целью 
создания библиотеки ставилось предоставление унифицированного доступа к различным 
СУБД и изоляция прикладного программиста от какого бы то ни было непосредственного 
низкоуровневого взаимодействия с базой данных. 

Библиотека EffiDB доступна для использования в среде Linux (компилятор gcc версий~4.2--4.5), 
Windows (компилятор MS VC++ 2010), MacOS (компилятор gcc~4.2.1 и выше). Авторам 
неизвестно никаких препятствий для сборки библиотеки иными компиляторами, 
поддерживающими стандарт C++ ISO/IEC~14882 1998~г., а также препятствий для 
использования библиотеки под управлением иных POSIX-со\-вмес\-ти\-мых ОС. Однако 
никаких работ в этом направлении авторами не проводилось.

Специализация работы с каждой конкретной СУБД заключена в отдельных библиотеках, 
которые далее называются драйверами. Библиотека\linebreak 
\mbox{EffiDB} управ\-ля\-ет соединениями с базой данных,\linebreak 
формирует и исполняет SQL-за\-про\-сы, интерпретирует полученные результаты. Она 
также пред\-остав-\linebreak\vspace*{-12pt}
\pagebreak

\noindent
ля\-ет механизмы кэширования результатов запросов и автоматического 
менеджмента памяти, что повышает надежность и производительность кода.

В настоящий момент доступны драйверы для работы со следующими СУБД: MySQL, 
MSSQL, Oracle и SQLite.

В случае когда отдельные модули системы выполняют кооперированные действия с 
одним и тем же объектом базы данных, требуется, чтобы все операции совершались в 
рамках одной транзакции. Специализированный драйвер Invariant инициирует отдельный 
процесс исключительно для коммуникации с базой данных, что позволяет объединить все 
обращения к базе данных в одном соединении. 
Драйвер Invariant не имеет специфики СУБД и 
может быть использован с любой из поддерживаемых СУБД.

В зависимости от поставленных задач и степени подготовки разработчика можно 
выделить 4 уровня использования EffiDB:
\begin{enumerate}
\item \textbf{Создание программных приложений со статической структурой базы 
данных.} Простейший вариант использования библиотеки в приложениях с заранее 
определенной схемой базы\linebreak данных, которая не изменяется во время работы 
приложения.
\item \textbf{Создание программных приложений с динамической структурой 
базы данных.} Предусматривается возможность изменения или расширения схемы 
базы данных в процессе эксплуатации приложения.
\item \textbf{Разработка адаптеров для типов данных.} Биб\-ли\-о\-тека EffiDB не использует 
никаких <<внут\-рен\-них>> типов данных для хранения парамет-\linebreak ров запросов и 
результатов выборок из базы данных. Вмес\-то этого используется подход 
<<адаптеров>>, которые позволяют применять в \mbox{EffiDB} любые пользовательские типы 
данных. Поставка \mbox{EffiDB} включает в себя адаптеры для популярных (в том числе 
встроенных в C++) типов данных, таких как int, string, double и~т.\,п. Механизм 
адаптации любого другого типа данных в точности такой же. Работа с 
пользовательским типом данных, для которого разработан адаптер, не отличается от 
работы с типами, адаптеры для которых включены в дистрибутив библиотеки.
\item \textbf{Разработка драйверов для поддержки дополнительных СУБД.} 
Библиотека EffiDB не ограничивает пользователя перечисленными ранее СУБД. 
Открытый API (application programming interface)
библиотеки предоставляет техническую возможность разработать 
собственный драйвер для произвольной СУБД. Как и в случае с пользовательскими 
типами, вновь разработанный дополнительный драйвер СУБД предостав\-ляет все те же 
возможности, что и драйверы, входящие в поставку.
\end{enumerate}

Хотя это и может показаться парадоксальным на первый взгляд, дублирование 
информации приводит к ее потере. При наличии нескольких реп\-лик данных возникают 
проблемы синхронизации, определения степени актуальности каждого отдельного 
экземпляра и, как следствие, появляется риск потери информации. Достаточно 
распространена ситуация, когда необходимо обрабатывать агрегированную информацию 
из нескольких баз данных (в общем случае с использованием разных СУБД). Копирование 
данных в единое хранилище с целью их консолидации и дальнейшей обработки 
пред\-став\-ля\-ет\-ся неэффективным в силу вышеупомянутых причин.

Библиотека EffiDB позволяет одновременно обращаться к нескольким базам данных под управ\-ле\-ни\-ем 
разных СУБД, и необходимость в копировании информации не возникает. 

Возможность одновременной работы с разными СУБД оказывается полезной и в другой 
хорошо известной практической задаче~--- задаче миграции данных из одной 
информационной системы в другую. Благодаря EffiDB процедура миграции может 
выполняться напрямую без промежуточных шагов.

Библиотека EffiDB предназначена для по\-стро\-ения сложных многокомпонентных информа\-ци\-онных 
сис\-тем. В~таких сис\-те\-мах биз\-нес-ло\-ги\-ка \mbox{обычно} распределяется между несколькими 
приложениями (модулями), которые совместно работают с общей базой данных. 
Хрестоматийным примером, иллюстрирующим такую ситуацию, можно считать перевод 
денег с одного счета на другой: один модуль снимает деньги со сче\-та-до\-но\-ра и 
вызывает второй модуль, который, в свою очередь, зачисляет средства на счет-ак\-цеп\-тор.

Таким образом, одно действие (перевод средств) может быть представлено несколькими 
отдельными, но тем не менее зависимыми друг от друга операциями приложений над 
объектами одной базы данных. Реализация такого действия в информационной системе 
требует, чтобы каждый участвующий в процессе модуль последовательно совершал 
необходимую операцию и передавал управление следующему модулю до тех пор, пока 
все операции не будут выполнены. Обеспечение транзакционной целостности базы 
данных означает, что все операции (снятие и зачисление средств в вышеприведенном 
примере) должны производиться в одной транзакции. Это было бы невозможно, если бы
каждый модуль действовал изолированно и уста\-нав\-ли\-вал собственное соединение с базой 
дан-\linebreak ных.

Для устранения этого противоречия в EffiDB используется специализированный драйвер 
Invariant. Если в индивидуальных процессах приложений требуется взаимодействие с 
базой данных, драйвер создает специальный процесс для коммуникации с базой данных и 
устанавливает единое соединение с ней. В~результате логически связанные действия 
разных приложений выполняются в рамках одной транзакции.

\section{Аналогичные разработки}

В настоящий момент разработчики могут выбирать среди достаточно большого 
количества инструментов доступа к данным, хранящимся в реляционных СУБД. Можно 
выделить низкоуровневые средства доступа, наиболее популярные из которых ODBC (Open
DataBase Connectivity) (для 
языков С/С++) и JDBC (для Java), а также высокоуровневые~--- так называемые средства 
объект\-но-ре\-ля\-ци\-он\-но\-го отображения, весьма представительный список которых 
представлен в Wikipedia~\cite{6-y}.

Некоторые популярные инструменты сведены в табл.~1, где указаны поддерживаемые 
операционные системы, СУБД, языки программирования. Также в таблице содержатся 
наиболее важные с точки зрения разработчика прикладного программного
обеспечения (ПО) объективные параметры 
этих инструментов. Такие важнейшие параметры, как лаконичность и простота 
использования языка запросов, сложно сравнивать объективно, поэтому они исключены 
из рассмотрения.


\end{multicols}

\begin{table}[b]\small
\vspace*{-24pt}
\begin{center}
\Caption{Инструменты доступа к данным, хранящимся в РСУБД}
\vspace*{2ex}

\tabcolsep=3pt
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Продукт &\tabcolsep=0pt\begin{tabular}{c}Операционная\\ система\end{tabular} &СУБД &Язык &
\tabcolsep=0pt\begin{tabular}{c}Уровень\\ изоляции\end{tabular} &
\tabcolsep=0pt\begin{tabular}{c}Контроль\\ синтаксиса\\ запросов\end{tabular} &Типы данных\\
\hline 
ODBC&\tabcolsep=0pt\begin{tabular}{c}Windows,\\ Unix\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Все\\ промышленные\\ РСУБД\end{tabular}&С&Низкий&
\tabcolsep=0pt\begin{tabular}{c}В момент\\ исполнения\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Простые ODBC \\ специфичные\end{tabular}\\
\hline
JDBC&\tabcolsep=0pt\begin{tabular}{c}Windows,\\ Unix\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Все\\ промышленные\\ РСУБД\end{tabular}&Java&Низкий&
\tabcolsep=0pt\begin{tabular}{c}В момент\\ исполнения\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Простые Java\\ специфичные\end{tabular}\\
\hline
LINQ&Windows&MS SQL$^{(*)}$&
\tabcolsep=0pt\begin{tabular}{c}C\#, VB.NET\\ и другие\\ MSIL-совместимые\\ .NET языки\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Высокий. \\ Требует\\ перегенерации\\ модели данных\\
прикладного ПО\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}На этапе\\ разработки\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Простые .NET \\ специфичные\end{tabular}\\
\hline
Hibernate&\tabcolsep=0pt\begin{tabular}{c}Windows,\\ Unix\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Все\\ промышленные\\ РСУБД\end{tabular}&Java&
\tabcolsep=0pt\begin{tabular}{c}Высокий.\\ Допускает\\ переключение\\ между 
СУБД\\ <<на лету>>\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}В момент\\ исполнения\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Простые Java\\ специфичные\end{tabular}\\
\hline
SOCI&Unix&\tabcolsep=0pt\begin{tabular}{c}Oracle,\\ PostgreSQL,\\ MySQL\end{tabular}&C++&
Низкий&\tabcolsep=0pt\begin{tabular}{c}В момент\\ исполнения\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Стандартные\\ С++ типы\end{tabular}\\
\hline
ODB&\tabcolsep=0pt\begin{tabular}{c}Windows,\\ Unix\end{tabular}&
MySQL&C++&\tabcolsep=0pt\begin{tabular}{c}Высокий$^{(**)}$.\\ Требует\\ перекомпиляции\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}На этапе \\ разработки\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Любые,\\ определяемые\\ пользователем\end{tabular}\\
\hline
EffiDB&\tabcolsep=0pt\begin{tabular}{c}Windows,\\ Unix\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}MSSQL,\\ Oracle,\\ MySQL,\\ 
SQLite$^{(***)}$\end{tabular}&
С++&\tabcolsep=0pt\begin{tabular}{c}Высокий.\\ Допускает \\ переключение\\ между СУБД\\ <<на лету>>\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}На этапе\\ разработки\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Любые,\\ определяемые \\
пользователем\end{tabular}\\
\hline
\multicolumn{7}{p{164mm}}{$\hphantom{^{**}}^{(*)}$Поддержка Oracle, MySQL, PostgreSQL, SQLite возможна при покупке 
дополнительных инструментов сторонних разработчиков.\newline
$\hphantom{^*}^{(**)}$Поддерживается очень ограниченный набор возможностей SQL. В~частности, недоступно 
объединение таблиц (JOIN).\newline
$^{(***)}$Поддержка других РСУБД возможна в режиме ODBC-со\-вмес\-ти\-мости.}
\end{tabular}
\end{center}
\end{table}

\begin{multicols}{2}

Под термином <<уровень изоляции>> авторы понимают степень изоляции прикладного 
кода от специфики целевой СУБД, в том числе в разрезе поддержки того или иного 
диалекта SQL (Structured Query Language). Низкий уровень изоляции подразумевает необходимость внесения 
изменений в код прикладного ПО при смене СУБД, высокий уровень изоляции 
гарантирует переносимость кода прикладного ПО между СУБД без каких-либо 
изменений. Однако даже с высоким уровнем изоляции адаптация под новую СУБД может 
требовать перегенерации, перекомпиляции или статической перелинковки кода, а может 
осуществляться динамически во время работы программы. Контроль синтаксиса запросов 
в разных системах может осуществляться либо на этапе разработки прикладного ПО (во 
время компиляции/генерации кода) средствами самого инструмента, либо в момент 
исполнения SQL-за\-про\-са средствами СУБД. Первый подход существенно удешевляет 
разработку ПО за счет снижения затрат на тестирование (или повышает качество ПО при 
равных затратах). Набор поддерживаемых типов данных практически не влияет на выбор 
инструментов доступа при разработке прикладного ПО с нуля, однако в реальной жизни 
при наличии унаследованного кода или при желании разработчика использовать 
ка\-кие-ни\-будь дополнительные биб\-лио\-те\-ки/мо\-ду\-ли и~т.\,п.\ вопрос об используемых 
типах данных может оказаться критически важным. 

Анализ присутствующих на рынке инструментов доступа к 
реляционным СУБД (РСУБД) показывает, что 
наиболее продвинутым продуктом является LINQ (Language Integrated Query) компании 
Microsoft~--- встроенное в .NET средство доступа к данным. Полная изоляция от SQL, 
проверка синтаксиса на этапе компиляции, лаконичность и удобочитаемость синтаксиса, 
наличие средств генерации языковых объектов на основании существующей базы данных 
делают LINQ лучшим на данный момент средством доступа к реляционным данным с 
точки зрения удобства использования. Однако LINQ доступен только как часть 
платформы .NET для проектов, работающих под управлением ОС Windows, и нацелен на 
работу с СУБД MS~SQL, что существенно ограничивает область применимости этого 
инструмента и требует достаточно больших материальных затрат~--- хотя сам LINQ и 
является бесплатным, для его использования требуется как минимум покупка лицензий 
Windows и MS~SQL, а также зачастую средств разработки (Microsoft Visual Studio и~т.\,п.).

Другие инструменты, хотя и лишены различных недостатков LINQ, но предоставляют в 
целом меньшее, иногда существенно меньшее удобство при разработке прикладного ПО. 
Кроме того, большинство существующих инструментов ориентированы на 
интерпретируемые языки (PHP, Python, Ruby и~т.\,п.) или на языки, компилируемые в 
промежуточный код (Java, .NET), в то время как разработчики, использующие наиболее 
популярные компилируемые языки С++ и С, вынуждены пользоваться либо очень 
неудобными низкоуровневыми библиотеками ODBC (существует несколько реализаций), 
либо такими функционально ограниченными инструментами, как SOCI, ODB и~т.\,п. При 
этом, по данным крупнейшей Интернет-площадки свободных разработок sourceforge.net, 
проекты на C/C++ занимают лидирующие позиции~--- на их долю приходится более 
четверти всех проектов.

Такое положение вещей и побудило авторов к разработке собственного инструмента~--- 
многоплатформенного, поддерживающего разные СУБД, изолирующего прикладного 
программиста от специфики СУБД и SQL диалектов, способного работать с 
унаследованными приложениями/библиотеками, разработанными на C++ и С, 
обладающего компактным и легкочитаемым синтаксисом. 

\vspace*{-9pt}

\section{Цели создания EffiDB}

\vspace*{-2pt}

\noindent
\begin{itemize}
\item[$\bullet$] \textbf{Переносимость кода между СУБД.} В~IT-ин\-ду\-ст\-рии 
часто приходится разрабатывать большое количество приложений для разных 
клиентов. Как следствие, необходимо поддерживать разнообразные конфигурации 
клиентского оборудования и иногда переносить унаследованное 
ПО на новые платформы~\cite{1-y, 2-y}. Вообще говоря, это 
ПО должно быть в состоянии работать на\linebreak
 разных СУБД в зависимости от 
требований клиента~--- представляется нецелесообразным всякий раз, когда новому 
клиенту требуется очередная СУБД, заниматься ее поддержкой и\linebreak \mbox{обучать} собственных 
разработчиков работе с этой СУБД. Библиотека EffiDB обес\-пе\-чивает независимость 
кода программного приложения от СУБД. Библиотека покрывает\linebreak
 большую часть 
функциональности, пред\-остав\-ля\-емой различными СУБД, и гарантирует, что 
про\-грам\-мное приложение будет работать одинаковым образом на всех 
поддерживаемых СУБД.
\item[$\bullet$] \textbf{Проверка запросов на момент компиляции.} Приложения, 
взаимодействующие с базой данных, генерируют SQL-за\-про\-сы, которые затем 
интерпретируются и исполняются на СУБД. Так как SQL и код на C++, вообще говоря, 
никак не связаны между собой, построение SQL-за-\linebreak\vspace*{-12pt}
\pagebreak

\noindent
про\-сов подвержено ошибкам, 
причем обычно синтаксические ошибки, допущенные при создании запроса, 
обнаруживаются довольно поздно~--- только на этапе тестирования приложения. 
Библиотека EffiDB строит запросы автоматически и производит проверку в процессе 
компиляции~--- это гарантирует отсутствие синтаксических ошибок в SQL-за\-просах.
\item[$\bullet$] \textbf{Динамическое подключение базы данных.} В~некоторых 
случаях приложение должно работать с несколькими СУБД~--- одновременно либо с 
той или иной СУБД, определяемой конкретной инсталляцией. Так, например, такое 
требование актуально при интеграции унаследованных информационных систем, 
разработка которых велась независимо разными подразделениями и 
производителями~\cite{2-y}. Динамическое подключение базы данных, реализованное 
в \mbox{EffiDB}, позволяет <<на лету>> переключаться между СУБД: если изначально 
предполагалось использовать приложение с MySQL, то нет необходимости 
перекомпилировать его, например, под Oracle~--- для того чтобы запустить 
приложение на конкретной СУБД, достаточно подгрузить соответствующую 
динамическую библиотеку. Можно также менять СУБД в процессе работы 
приложения и использовать несколько СУБД одновременно.
\item[$\bullet$] \textbf{Лаконичный синтаксис.} Чрезвычайно важным\linebreak
 элементом 
разработки является лаконичность, понятность и эргономичность кода, \mbox{который} 
приходится писать прикладным раз\-ра\-ботчи\-кам. Любая недоработка в этой области 
приводит к снижению поддерживаемости и увеличивает количество ошибок. 
Благодаря\linebreak удобному синтаксису EffiDB объем текста, который требуется написать на 
C++ для создания SQL-за\-про\-са, практически не превосходит размер самого 
SQL-за\-про\-са.
\item[$\bullet$] \textbf{Простота построения запроса из одной таблицы.} На 
практике большинство SQL-за\-про\-сов представляют собой запросы по первичному 
ключу в одной таблице. Этот простейший и часто встречающийся частный случай 
имеет смысл рассматривать отдельно. Если не выделять этот важный сценарий и 
обрабатывать его обычным образом, то такой подход порождает определенные 
неудобства. Во-пер\-вых, таким образом упускается возможность повысить 
производительность. Во-вто\-рых, часто разработчики поддаются соблазну объединить 
несколько запросов в один и сконструировать сложный запрос <<на все случаи 
жизни>>~--- такие запросы могут снижать производительность очень сильно и, что 
хуже, непредсказуемым образом. Биб\-лио\-те\-ка EffiDB предоставляет специальный 
синтаксис для запросов из одной таблицы~--- это очень простой способ составления 
запроса, позволяющий обходиться минимумом кода. Фактически код C++ в этом 
случае даже короче, чем конечный SQL-за\-прос. Программисту не надо составлять 
сложные универсальные запросы~--- часто проще писать именно тот запрос, который 
нужен в данном конкретном случае.
\item[$\bullet$] \textbf{Автоматическое управление транзакциями.} Управление 
транзакциями в СУБД представляет собой нетривиальную задачу и, следовательно, 
порождает серьезные проблемы в проекте разработки программного 
продукта~\cite{4-y, 3-y}. Если фиксировать изменения (Commit changes) слишком 
часто, данные в БД могут потерять целостность. Если же фиксировать изменения 
слишком редко, то снижается производительность системы и становятся возможными 
клинчи (deadlocks). При создании библиотеки EffiDB авторы исходили из того 
соображения, что прикладной программист не должен заниматься управлением 
транзакциями, т.\,е.\ такими операциями, как управление соединениями, явная 
фиксация и откат транзакции. Библиотека обеспечивает автоматическое управление 
транзакциями, и прикладной программист не обязан думать о транзакциях. Тем не 
менее, если возникает необходимость явным образом управлять транзакциями, 
разработчик имеет возможность это делать.
\item[$\bullet$] \textbf{Автоматическая блокировка.} Довольно часто несколько 
транзакций пользуются одними и теми же данными, что приводит к хорошо известным 
проблемам управления параллельным выполнением операций. Необходимо соблюдать 
разумный баланс между произво\-ди\-тель\-ностью и изолированностью транзакций. Один 
из двух крайних подходов, который повышает производительность и пренебрегает 
изолированностью, приводит к потере данных. Противоположная стратегия, 
концентрирующаяся на изолированности транзакций, вызывает\linebreak
 взаимные блокировки 
и снижает производительность~\cite{4-y}. Авторы полагают, что целостность данных 
является жизненно важным\linebreak
 свойством информационной системы, и по умолчанию 
предпочитают изолированность производительности. Для того же, чтобы обеспечить 
приемлемую производительность и уменьшить вероятность клинчей, в EffiDB 
реализована поддержка автоматической блокировки. Различаются две категории 
транзакций: <<безопасные>> и быстрые транзакции чтения и <<потенциально 
опасные>> транзакции записи. Транзакции записи блокируют все данные, с которыми 
работают (путем использования\linebreak
 SELECT FOR UPDATE), что гарантирует 
изолированность. В~тех случаях, когда такая блокировка является избыточной, ее 
можно отключить.
\item[$\bullet$] \textbf{Поддержка произвольных типов данных.} Как правило, 
унаследованное ПО использует свои собственные типы данных, 
которые в общем случае не совпадают с типами данных СУБД. Если проект 
разработки ПО предполагает интеграцию такого рода 
приложений с одной или несколькими СУБД, необходимо преобразование типов 
данных. Библиотека \mbox{EffiDB} 
обеспечивает поддержку произвольных типов данных и пред\-остав\-ля\-ет 
возможность разработки <<адап\-те\-ра>> для собственных типов данных. Ниже 
приведен список типов данных, <<адап\-те\-ры>> для которых входят в дистрибутив 
библиотеки:
\begin{itemize}
\item[--] {\sf std::string};
\item[--] {\sf double};
\item[--] {\sf int32\_t};
\item[--] {\sf int64\_t};
\item[--] {\sf Int}~--- синоним для типа {\sf boost:: optional$\langle$int32\_t$\rangle$};
\item[--] {\sf Int64}~--- синоним для типа {\sf boost:: optional$\langle$int64\_t$\rangle$};
\item[--] {\sf Str}~--- синоним для типа {\sf boost:: optional$\langle$string$\rangle$};
\item[--] {\sf Time}~--- синоним для типа {\sf boost:: posix\_time::ptime};
\item[--] {\sf Effi::Blob} для больших блоков бинарных данных;
\item[--] {\sf Effi::GeoData} для больших блоков бинарных данных, используемых в 
геоинформационных приложениях;
\item[--] {\sf Effi::Decimal}.
\end{itemize}
EffiDB использует типы данных библиотеки Boost Optional~[6].
\end{itemize}

\vspace*{-9pt}

\section{Концепции EffiDB}

\vspace*{-2pt}

Перейдем к изложению идей, положенных в основу библиотеки EffiDB. Для изоляции 
программиста от специфики взаимодействия с конкретной СУБД EffiDB использует 
специализированные классы C++ для каждого из понятий реляционных баз данных.

В тех случаях, когда это представляется полезным, текст сопровождается примерами 
использования библиотеки.

\vspace*{-6pt}

\subsection{База данных} %5.1

\vspace*{-1pt}

Понятию <<база данных>> соответствует класс\linebreak {\sf Effi::DataBase}. 
Этот класс представляет 
собой фабрику объектов Connection (соединение)~--- соединение является единственным 
способом общения с сервером базы данных. 
{\small
\begin{verbatim}
DataBase database=
                new DataBase(libName, dbParams);
\end{verbatim}}

\noindent
Здесь {\sf libName}~--- имя драйвера СУБД, а {\sf dbParams}~--- параметры базы данных. Набор 
параметров зависит от СУБД. Так, для работы с MySQL инициализация может иметь вид:
{\small
\begin{verbatim}
string libName="libardbms_mysql.so";
std::map<string, string> dbParams;
dbParams["DSN"]="<Имя источника данных>";
dbParams["AutoCommit"]="off";
dbParams["UserName"]="<Имя\ пользователя>";
dbParams["Password"]="<Пароль>";
dbParams["Port"]="<Порт>"};
dbParams["Host"]="<Адрес сервера базы данных>";
\end{verbatim}}

\vspace*{-6pt}

\subsection{Соединение} %5.2

Соединение с базой данных позволяет прикладному ПО
общаться с ПО сервера базы данных. Соединение является 
необходимым элементом процесса, позволяющим посылать команды СУБД и получать 
ответы.

Процедура установления соединения является время- и ресурсоемкой операцией, и было 
бы\linebreak
неэффективно инициировать новое соединение всякий раз, когда приложению нужно 
связаться\linebreak
с базой данных. Поэтому в EffiDB реализован\linebreak
алгоритм организации связного 
пула соединений. Когда приложению требуется связь с базой\linebreak
 данных, сначала происходит 
поиск свободного\linebreak соединения в пуле уже существующих соединений. Только в том 
случае, если свободных\linebreak соединений нет, создается новое соединение. Эта возможность 
реализована в функции {\sf DataBase::\linebreak GetConnection()}. Когда необходимость в соединении 
пропадает, приложение должно освободить его функцией {\sf DataBase::ReleaseConnection()}. 
Таким образом \mbox{EffiDB} формирует пул свободных переиспользуемых соединений.

Соединение представлено классом {\sf Effi::\linebreak Connection}. 
\begin{verbatim}
Connection* conn;
conn=database->GetConnection();
...
database->ReleaseConnection(conn);
\end{verbatim}

\subsection{Средства манипулирования данными} %5.3

Как уже было сказано, код приложения должен быть унифицированным и работать с 
любой из поддерживаемых СУБД. С другой стороны, каждое SQL-вы\-ра\-же\-ние 
исполняется на вполне конкретной СУБД и, следовательно, должно подчиняться строгим 
правилам синтаксиса данной СУБД.

Чтобы разрешить это противоречие, EffiDB строит SQL-запрос в несколько этапов. 
Па\-ра\-мет\-ры SQL-за\-про\-са аккумулируются одним из четырех классов (каждый класс 
соответствует одному из видов SQL-вы\-ра\-же\-ний): 
{\sf Effi::Selector}, {\sf Effi::Inserter}, 
{\sf Effi::Deleter}, {\sf Effi::Updater}. 
К~параметрам относится\linebreak
 все необходимое для формирования 
запроса: множество выбираемых данных, список таблиц, из\linebreak которых выбираются данные, 
условия выборки, условия группировки, ограничения, условия сортировки и~т.\,п. Далее 
будем называть эти четыре класса <<агентами>>.

Классы-агенты не зависят от специфики СУБД. Их назначение~--- сбор полной 
информации, достаточной для построения выражения, при этом они не формируют 
собственно SQL-вы\-ра\-же\-ния. Биб\-лиотека \mbox{EffiDB} 
позволяет строить разнообразные выражения, в 
том числе с использованием псевдонимов, инструкций join, сортировки и~т.\,п.

Каждый класс-агент имеет функцию {\sf Execute()}, которая, в свою очередь, вызывает 
соот\-вет\-ст\-ву\-ющую функцию драйвера СУБД. Эта функция формирует строку 
SQL-за\-про\-са в соответствии с синтаксисом SQL конкретной СУБД.

\section{Формирование SQL-запросов}

Приведем несколько примеров использования библиотеки (предположим, что работаем с 
MySQL).

Рассмотрим базу данных книжного магазина. Книга имеет название, автора и цену. 
Известно количество экземпляров каждой книги.

Цель~--- сформировать типичные SQL-запросы из приложения, написанного на C++.

База данных содержит, в частности, таблицу Bookstore~--- она представляет собой список 
книг: 

\end{multicols}

\hrule

\begin{verbatim}
ID Title                                    Author      Price   Qty

101 Algorithms + Data Structures = Programs Wirth       120.35   14
187 1001 Nights                             NULL        999.99    2
318 The Decameron                           Boccaccio  1285.99    1
325 C++                                     Stroustrup   59.85   10
400 The Art of Computer Programming         Knuth       299.99    0
\end{verbatim}

\vspace*{3pt}

\hrule

\begin{multicols}{2}


\subsection{Установление соединения} %6.1

В начале работы необходимо определить, драйвер какой СУБД будет использован, задать 
параметры базы данных, создать объект DataBase и установить соединение: 
\begin{verbatim}
DataBase* database= 
       new DataBase(libName, dbParams);
Connection* conn;
try {
  conn=database->GetConnection();
}
catch(Exception e) {
  cerr << "ERROR: " << e.What() << endl;
  database->ReleaseConnection(conn);
  throw;
}
\end{verbatim}


\subsection{Выборка из таблицы} %6.2

Рассмотрим теперь задачу построения запроса, выбирающего дорогие книги и 
возвращающего идентификатор книги, ее название и цену с учетом НДС.

Таблица базы данных представлена объектом класса {\sf Effi::SimpleTable}, колонки 
таблицы~--- объектами класса {\sf Effi::Column}:
\begin{verbatim}
// Определение таблицы базы данных
SimpleTable bookStore("Bookstore");

// Определение колонок таблицы, необходимых
// для запроса
Column ID(bookStore, "ID");
Column Title(bookStore, "Title");
Column Price(bookStore, "Price");
\end{verbatim}

Для доступа к результатам запроса используются вспомогательные переменные. 
Соответствие между полями таблиц базы данных и вспомогательными переменными 
устанавливается посредством технологии связывания (\textit{binding}), как будет показано 
ниже. 
\begin{verbatim}
// Определение вспомогательных переменных
// для доступа к результатам запроса
int id;
string title;
double totalPrice;

// Пороговое значение цены
double threshold = 300;
// Ставка НДС, \%
double vat = 0.2;
\end{verbatim}

Собственно формирование запроса состоит из указания колонок и связанных с ними 
вспомогательных переменных, а также установки критериев выбора: 
{\small \begin{verbatim}
Selector s;
// Определение набора колонок таблицы
// и связывание их
// со вспомогательными переменными
s << ID.Bind(id) << Title.Bind(title) << 
(Price*(1+vat)).As("TotalPrice"). 
Bind(totalPrice);
// Определение критериев выборки
s.Where(Price > threshold);
\end{verbatim}}

Выполнение запроса осуществляется посредством вызова метода {\sf Effi::Selector::Execute()}: 
\begin{verbatim}
// Выполнение SQL-запроса
DataSet data=s.Execute(conn);
\end{verbatim}
Результатом выполнения SQL-за\-про\-са типа SELECT является набор записей. Доступ к 
результатам запроса осуществляется посредством класса\linebreak {\sf Effi::DataSet}. Функция 
{\sf DataSet::Fetch()} считывает очередную запись в соответствующие вспомогательные 
переменные, связанные с колонками табли\-цы результатов функцией {\sf Bind()}. Так, в 
рассмат\-ри\-ваемом примере колонка {\sf ID} связана с переменной~id, колонка {\sf Title}~--- с 
переменной\linebreak title, а выражение ({\sf Price*(1+vat)})~--- с переменной totalPrice. После 
считывания внутренний указатель функции {\sf Fetch()} смещается на следующую запись. Если 
запись последняя, то функция {\sf Fetch()} возвращает false. Если поле таблицы результатов не 
связано ни с одной вспомогательной переменной, то данные этого поля недоступны из 
С++ кода.

Следующий код выводит результат исполнения запроса SELECT: 
\begin{verbatim}
while(data.Fetch()) {
   cerr << id << "; " << title << "; " 
   << totalPrice << endl;
}
\end{verbatim}

Сформированный SQL-запрос имеет вид:
\begin{verbatim}
SELECT ID, Title, Price*1.2 AS TotalPrice
FROM Bookstore
WHERE Price > 300;
\end{verbatim}
и возвращает следующие данные: 
\begin{verbatim}
ID   Title          TotalPrice

187; 1001 Nights;   1199.99
318; The Decameron; 1543.19
\end{verbatim}

\subsection{Классы-обертки реляционных таблиц} %6.3

Описанный выше метод универсален в том смысле, что позволяет работать с таблицами, 
структура которых неизвестна на момент компиляции.

Представляется, однако, что в большинстве реальных ситуаций структура базы данных 
известна заранее, и тогда такой подход оказывается избыточным и неудобным~--- он 
требует создавать пред\-став\-ле\-ния реляционных сущностей (таблиц и колонок базы 
данных) в С++ всякий раз, когда с ними работают. Так, если некая таблица участвует в 
одном SQL-за\-про\-се дважды, то требуется создавать два объекта класса {\sf SimpleTable}, 
описывать для каждого из них одинаковый набор колонок и~т.\,п. 

Библиотека EffiDB предоставляет возможность создать универсальный класс-оберт\-ку для работы с 
известной на момент компиляции таблицей базы данных. Такой класс должен быть 
производным от класса {\sf Effi::Domain}: 
\end{multicols}

\hrule

\vspace*{6pt}

\begin{verbatim}
class Bookstore : public Domain {
public :
  struct BookstoreDomain {
  Column ID;
  Column Title;
  Column Author;
  Column Price;
    BookstoreDomain(const SimpleTable& table)
    : ID(table, "ID");
    , Title(table, "Title");
    , Author(table, "Author");
    , Price(table, "Price"){}
  } Domain_;
  boost::optional<int> ID;
  boost::optional<string> Title;
  boost::optional<string> Author;
  Decimal Price;
  Bookstore() : Domain("Bookstore"), Domain_(*this) {
    // COLUMN_PK означает, что колонка входит в первичный ключ
    columns_.push_back(ColSpec(Domain_.ID.Bind(ID), COLUMN_PK));
    // COLUMN_ ORDINARY означает, что колонка не является ключевой
    columns_.push_back(ColSpec(Domain_.Title.Bind(Title), COLUMN_ORDINARY));
    columns_.push_back(ColSpec(Domain_.Author.Bind(Author), 
COLUMN_ORDINARY));
    columns_.push_back(ColSpec(Domain_.Price.Bind(Price), COLUMN_ORDINARY));
  }
  Bookstore(const Bookstore& copy) : Domain("Bookstore"), Domain_(*this)
  , ID(copy.ID);
  , Name(copy.Title);
  , Author(copy.Author);
  , Phone(copy.Price) {
    columns_.push_back(ColSpec(Domain_.ID.Bind(ID), COLUMN_SK));
    columns_.push_back(ColSpec(Domain_.Title.Bind(Title), COLUMN_ORDINARY));
    columns_.push_back(ColSpec(Domain_.Author.Bind(Author), 
COLUMN_ORDINARY));
    columns_.push_back(ColSpec(Domain_.Price.Bind(Price), COLUMN_ORDINARY));
  }
  Bookstore& operator= (const Bookstore& copy) {
    ID = copy.ID;
    Title =copy.Title;
    Author=copy.Author;
    Price =copy.Price;
    return *this;
  }
  virtual ~Bookstore() {}
  BookstoreDomain* operator->() { return &Domain_; }
};
\end{verbatim}

\vspace*{6pt}

\hrule

\begin{multicols}{2}

В классе-обертке определяются колонки таблицы и набор вспомогательных переменных, 
соответствующий набору колонок, а также устанавливается соответствие между ними. 

Имена объек\-тов-ко\-ло\-нок и имена вспомогательных переменных задаются 
совпадающими с именами полей таблиц. Имена объектов-колонок доступны посредством 
оператора <<$\rightarrow$>>, например Bookstore$\rightarrow$Price, а значения полей~--- 
посредством оператора <<.>>, например \mbox{Bookstore.Price}. 

Колонки, входящие в первичный 
ключ таблицы, помечаются как ключевые.

Таким образом, необходимость всякий раз при использовании экземпляров класса 
Bookstore связывать колонки таблицы со вспомогательными переменными отпадает. 

Только в тех случаях, когда вспомогательные переменные не имеют соответствующей 
колонки, но требуются в конкретном запросе (totalPrice в рассматриваемом примере), 
следует по-прежнему явным образом создавать сами переменные и устанавливать их связь 
с колонками таблицы результатов запроса.

Работа с классами-обертками обеспечивает ряд немаловажных преимуществ.

Во-первых, описание таких сущностей базы данных, как таблица и ее колонки, 
локализовано в одном месте кода. Это снижает до минимума риск появления 
синтаксических ошибок и облегчает процесс поддержки и развития приложения.

Во-вторых, код, формирующий рассмотренный выше SQL-за\-прос, оказывается гораздо 
короче: 
\begin{verbatim}
Bookstore tbl;
double threshold = 300;
double vat = 0.2;
double totalPrice;
Selector s;
s << tbl->ID << tbl->Title
  << (tbl->Price*(1+vat))
  .As("TotalPrice").Bind(totalPrice);
s.Where(tbl->Price>threshold);
\end{verbatim}

Легко видеть, что создание объекта, пред\-став\-ля\-юще\-го таблицу, сводится теперь к 
объявлению переменной, а объявление вспомогательных переменных и связывание их с 
колонками базы данных не требуется.

И, наконец, рассмотрим сценарий, в котором выгода от использования клас\-са-оберт\-ки 
наиболее существенна и очевидна. На практике чаще всего используются SQL-за\-про\-сы 
по первичному ключу таблицы. Синтаксис EffiDB в этом случае крайне прост, а размер 
текста кода оказывается даже меньшим, чем размер итогового SQL-за\-проса.

Попробуем, к примеру, выполнить все 4~возможных вида SQL-выражений на 
рассматриваемой базе данных: 
\begin{verbatim}
// Определение уникального кода
// для новой книги
// и проверка его доступности tbl.ID=100;
if (tbl.Select(conn)) throw Exception 
("Книга с таким кодом уже существует.");

// Добавление новой книги
tbl.Title = "Hobbit";
tbl.Author = "Tolkien";
tbl.Insert(conn);

// Изменение названия книги
tbl.Title = "Hobbit or There and
            Back Again";
tbl.Update(conn);

// Удаление книги
tbl.Delete(conn);
\end{verbatim}

Соответствующие SQL-выражения: 
\begin{verbatim}
SELECT *
FROM Bookstore
WHERE ID = 100;

INSERT INTO Bookstore (ID, Title, 
       Author, Price, Qty)
VALUES (100, "Hobbit", "Tolkien", 
       NULL, NULL);

UPDATE Bookstore
SET Title = "Hobbit or There and Back 
 Again", Author = "Tolkien", 
 Price = NULL, Qty = NULL
WHERE ID = 100;

DELETE FROM Bookstore
WHERE ID = 100;
\end{verbatim}

Аналогичным образом составляются запросы по составному первичному ключу.

\section{Интегрированная среда разработки приложений Effi}

Библиотека EffiDB является лишь одним из компонентов интегрированной среды 
разработки приложений Effi.

Разработчик, использующий среду Effi, описывает приложение на декларативном языке в 
формате XML (eXtensible Markup Language), 
оперируя понятиями классов, методов и элементов графического 
интерфейса. Все объекты C++ кода, представляющие понятия реляционной базы данных, 
генерируются автоматически. В~част\-ности, получается полностью готовый к 
использованию класс-оберт\-ка. Разработчик имеет возможность сосредоточиться на 
программировании логики приложения и не тратить усилия на описание вспомогательных 
объектов.

\section{Заключение}

Для решения проблемы унифицированного\linebreak взаимодействия с разнотипными СУБД 
создана оригинальная С++ библиотека EffiDB; библиоте-\linebreak ка доступна в сети Интернет по 
адресу {\sf http://\linebreak sourceforge.net/projects/effidb}~\cite{7-y}.

Библиотека EffiDB гарантирует полную переносимость программных приложений за счет изоляции 
прикладного кода от специфики конкретной СУБД. В~библиотеке реализован механизм 
динамического подключения драйверов разных СУБД в процессе работы приложения, а 
также возможность одновременного подключения нескольких СУБД. Библиотека 
обеспечивает защиту от синтаксических ошибок в SQL-выражениях за счет разбиения 
построения SQL-выражений на несколько этапов и проверки на момент компиляции.

Библиотека EffiDB используется в ряде проектов разработки ПО 
компании ASoft {\sf http://asoft.ru}, среди которых:
\begin{itemize}
\item аппаратно-программный комплекс центра хранения электронных копий 
материалов уголовных дел для Министерства внутренних дел РФ <<Невод-Р>>;
\item объединенная поисковая федеральная система генетической идентификации 
<<Ксенон-2>>;
\item единая автоматизированная информационная система дежурных частей органов 
внутренних дел;\\[-5pt]
\item система автоматизации деятельности по линии борьбы с экстремизмом для 
Департамента по противодействию экстремизму МВД Рос-\linebreak сии;\\[-5pt]
\item автоматизированная система управления взаимоотношениями с контрагентами 
ASoft CRM;\\[-5pt]
\item геоинформационная система хранения, обработки и визуального представления 
картографической информации;\\[-5pt]
\item конструктор отчетов, позволяющий строить отчеты любой степени сложности и 
вложенности, а также задавать макет представления дан-\linebreak ных;\\[-5pt]
\item информационная система для совместной работы над документами ASoft 
Collaboration.
\end{itemize}

{\small\frenchspacing
{%\baselineskip=10.8pt
\addcontentsline{toc}{section}{Литература}
\begin{thebibliography}{9}

 \bibitem{6-y} %1
Список современых средств объектно-ре\-ля\-ци\-он\-но\-го отображения доступа к данным.  {\sf 
http://en.wikipedia. org/wiki/List\_of\_object-relational\_mapping\_software}.

\bibitem{1-y} %2
\Au{Янушко А.\,В.} Современные реляционные СУБД~// Банки и технологии, 1998. №\,2.

\bibitem{2-y} %3
\Au{Ambler S.\,W., Sadalage P.\,J.}. Refactoring databases: Evolutionary 
database design.~--- Addison-Wesley Professional, 2006. 384~p.

\bibitem{4-y} %4
\Au{Gray J., Reuter A.} Transaction processing: Concepts and techniques.~--- Morgan 
Kaufmann Publs., 1993.

\bibitem{3-y} %5
\Au{Бегг К., Коннолли Т., Страчан~А.} Базы данных: Проектирование, реализация и 
сопровождение: Теория и практика~/ Пер. с англ.~--- М.: Вильямс, 2001.

\bibitem{5-y} %6
Библиотека Boost Optional в сети Интернет. {\sf 
http:// www.boost.org/doc/libs/1\_41\_0/libs/optional/doc/ html/index.html}.

\label{end\stat}

\bibitem{7-y} %7
Библиотека EffiDB в сети Интернет. {\sf http://sourceforge. net/projects/effidb}.
 \end{thebibliography}
}
}


\end{multicols}       