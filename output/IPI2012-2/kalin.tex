\def\stat{kalinich}

\def\tit{УНИФИКАЦИЯ ЯЗЫКОВ СИСТЕМ НА ПРАВИЛАХ ДЛЯ~ОБЕСПЕЧЕНИЯ 
ИНТЕРОПЕРАБЕЛЬНОСТИ ДЕКЛАРАТИВНЫХ ПРОГРАММ$^*$}

\def\titkol{Унификация языков систем на правилах для~обеспечения 
интероперабельности декларативных программ}

\def\autkol{Л.\,А.~Калиниченко, С.\,А.~Ступников}
\def\aut{Л.\,А.~Калиниченко$^1$, С.\,А.~Ступников$^2$}

\titel{\tit}{\aut}{\autkol}{\titkol}

{\renewcommand{\thefootnote}{\fnsymbol{footnote}}\footnotetext[1]
{Настоящая публикация является журнальным вариантом текста доклада Л.\,А.~Калиниченко и С.\,А.~Ступникова <<Анализ 
мотивации, целей и подходов проекта унификации языков на правилах>>, опубликованного в сборнике трудов Второго 
симпозума <<Онтологическое моделирование>>, М.: ИПИ РАН, 2011. Работа выполнена при финансовой поддержке 
РФФИ (проекты 08-07-00157-а, 10-07-00342-a, 11-07-00402-а) и Программы фундаментальных исследований Президиума РАН 
№\,15, проект~4.2.}}


\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{Институт проблем информатики Российской академии наук, leonidk@synth.ipi.ac.ru}
\footnotetext[2]{Институт проблем информатики Российской академии наук, ssa@ipi.ac.ru}


\Abst{Проанализированы рекомендации W3C RIF (Rule Interchange Format), 
ориентированные на обеспечение интероперабельности разнообразных систем на 
правилах введением расширяемого семейства унифицированных языков (диалектов) на 
правилах, позволяющих создавать сохраняющие семантику отображения в диалекты 
языков различных систем на правилах. Для определения мотивации проекта RIF  
дан краткий обзор развития и применения языков и систем на правилах в областях 
представления знаний, дедуктивных баз данных, логических моделей рассуждений. 
Также проанализированы различные семантики логических языков на правилах, 
оказавших влияние на конструкцию RIF. Рассмотрены основные классы применений 
интероперабельных программ на правилах, на основе которых были выработаны 
требования к RIF. Рассмотрены основные решения, принятые в проекте RIF.}

\KW{унификация языков; расширяемость языков;  
системы логического программирования; системы на активных правилах; 
продукционные системы; представление знаний; дедуктивные базы данных; логические 
модели рассуждений; стратифицированная семантика; стабильная модель логической 
программы; хорошо обоснованная семантика; диалекты RIF; каркас RIF}

  
   \vskip 14pt plus 9pt minus 6pt

      \thispagestyle{headings}

      \begin{multicols}{2}

            \label{st\stat}

\section{Введение}

Многообразие информационных технологий (ИТ) и их воплощений в конкретных 
ИТ-продуктах проявляется в многообразии языков, предназначенных для спецификации 
предметных областей, программ, схем баз данных, онтологий, интерфейсов 
информационных ресурсов (ИР), реализованных в рамках определенной ИТ, и~пр. Число 
таких языков, их разнообразие со временем быстро рас\-тет, порождая сложные проблемы 
интеграции и интероперабельности разноязыких ИР. Стандартизация языков несколько 
ограничивает разнообразие, однако число стандартов остается большим, а конкретные 
реализации одного и того же стандарта зачастую остаются несовместимыми.

Примерами классов подобных языков являются языки реляционных и объектных баз 
данных, языки\linebreak онтологического моделирования, языки пред\-став\-ле\-ния слабо 
структурированных, графовых, мультимедийных данных, языки представления баз\linebreak знаний, 
языки логического программирования, дедуктивные языки запросов к базам данных, языки 
спецификации процессов (потоков работ), языки спецификации интерфейсов программных 
ИР для обеспечения их (ИР) интероперабельности, языки со специализированной 
семантикой (например, для выражения темпоральных, пространственных моделей), языки 
для определения нечетких, вероятностных представлений, языки концептуального 
моделирования и метамодели и многие другие.

Проблемы унификации языков с целью нивелирования различий их синтаксиса и 
семантики исследуются давно. Так, язык IDL был разработан OMG в качестве стандарта 
языка спецификации интерфейсов объектов или программных компонентов, полученных в 
результате применения различных языков и систем программирования. Язык YAWL, 
основанный на сетях Петри, ориентирован на унифицированное представление 
разнообразных образцов поведения, представимых на различных языках описания 
процессов. Язык TSQL ориентирован на представление темпоральных реляционных баз 
данных.

Среди подходов к унификации языков особое место занимает концепция расширяемых 
языков, в которых фиксируется ядро, позволяющее унифицировать некоторую 
совокупность простых языков в определенном классе, и над таким ядром надстраиваются 
расширения, каждое из которых вместе с ядром является результатом сохраняющего 
семантику отображения некоторого исходного языка (языков)~[1]. Развитым проектом 
расширяемого языка является язык СИНТЕЗ~[2, 3], со\-про\-вож\-да\-емый методами и 
средствами построения его расширений. Основным сред\-ст\-вом поддержки процесса 
построения расширений языка-ядра является Унификатор информационных моделей~[4], 
поз\-во\-ля\-ющий конструировать расширения языка СИНТЕЗ и отображения конкретных 
исходных языков в такие расширения. При этом сохранение семантики операторов 
трансформации состояний и поведения в исходном языке в их отображении в язык СИНТЕЗ 
основано на принципе уточнения\footnote{Говорят, что спецификация~$A$ уточняет 
спецификацию~$B$, если систему, удовлетворяющую~$A$, можно использовать вместо 
системы, удовлетворяющей~$B$, и при этом пользователь не замечает этой замены.}~[5]. 
Таким образом, можно конструировать доказательно правильные расширения языка и 
отображения конкретных языков в язык СИНТЕЗ. Эти методы применялись к отображению 
в язык СИНТЕЗ языков баз данных, процессных языков, онтологических языков, языков 
спецификации объектных интероперабельных компонентов и~др.

Вместе с тем, за исключением языков манипулирования данными в базах данных, вопросы 
унификации языков программирования не рас\-смат\-ри\-ва\-лись вообще. Поэтому инициатива 
W3C, известная как RIF, заслуживает в контексте работ по 
унификации языков особого внимания~[6, 7]. Использование и развитие языков на 
правилах для логического программирования, дедуктивных баз данных, представления 
знаний, создания интеллектуальных информационных систем продолжается уже более 
30~лет. Технология языков на правилах созревала в этот период в результате 
теоретических исследований, практического и коммерческого применения таких языков. 
В~част\-ности, накопленный в этой об\-ласти опыт существенно превосходит опыт в области 
дескриптивных логик, активно развиваемых для онтологического моделирования.

Для эффективного использования потенциала подходов, основанных на правилах, 
сообщества применения языков на правилах в области искусственного интеллекта, в 
бизнесе, в Семантическом Вебе организовали проект по выработке решений по 
унифицированному, интероперабельному использованию спецификаций, представленных 
на различных языках на правилах (таких языках, как в работе~[8]). Применение 
результатов этого проекта должно быть общеупотребительным и не ограничиваться 
Семантическим Вебом. Идея RIF состоит в создании расширяемого унифицированного 
языка на правилах, обеспечивающего возможность построения сохраняющих семантику 
отображений в него различных языков на правилах. Такой унифицированный язык 
представляется как семейство диалектов, которые имеют общее ядро (корневой диалект) и 
совокупность расширяющих его диалектов, образующих ориентированный граф без цик\-лов. 
Каждое ребро графа (отношение расширения диалектов) отправляется от более простого к 
расширенному диалекту. Для сравнения, при построении аксиоматических расширений 
языка СИНТЕЗ отношение расширения интерпретировалось как включение множества 
аксиом более простого языка во множество аксиом более сложного языка~[1]. Итак, в RIF 
унифицированный язык на правилах представляется как семейство унифицированных 
языков (диалектов).

В RIF по отношению к диалекту каждая система программирования (система вывода) на 
правилах может выступать в двух независимых ролях~--- роли поставщика и роли 
потребителя. Первая роль означает, что система на правилах обеспечивает преобразование 
собственных программ в программы на унифицированном диалекте. Вторая роль означает, 
что система на правилах может воспринимать программы на диалекте и преобразовывать 
их в программы на собственном языке системы. Таким образом, для полновесного 
включения каждого языка на правилах в совокупность интероперабельных языков 
достаточно снабдить соответствующую систему программирования двумя сохраняющими 
семантику преобразователями~--- из собственного языка в адекватный диалект (роль 
поставщика) и из диалекта в собственный язык (роль потребителя). 

Для работы по проекту RIF в 2005~г.\ была образована рабочая группа W3C RIF WG~[9] с 
целью выработки <<обменного формата>> правил~--- так кратко именуется семейство 
определяемых RIF унифицированных диалектов языка на правилах. 

Изначально было 
декларировано, что целью RIF не является обеспечение единственного языка, объемлющего 
черты всех известных языков на правилах. Различные средства различных языков и систем 
на правилах зачастую не совместимы. Поэтому и была принята концепция диалектов RIF, 
обеспечи\-ва\-ющая возможность обмена модулями правил между различными системами на 
правилах. По замыслу проекта для правил, созданных в рамках некоторого приложения, 
должна быть обеспечена возможность их публикации, использования совместно с другими 
правилами, повторного использования в других приложениях и других сис\-те\-мах на 
правилах.

Кроме того, важной задачей RIF WG было обеспечение возможности совместной работы 
диалектов RIF и существующих стандартов Семантического Веба~--- таких как RDF 
(Resource Description Framework) и OWL (Web Ontology Language), 
не совместимых с большинством существующих языков на правилах. В~част\-ности, важно 
было показать, что существует возможность совместной работы дескриптивных логик и 
систем на правилах:
\begin{itemize}
\item сформировать общий базис для онтологических языков на правилах и на дескриптивной логике с 
целью достижения их интероперабельности;
\item проанализировать пересечение этих двух формализмов представления знаний для понимания того, 
какой выразительности можно достичь при их объединении (комбинации);
\item обеспечить использование машин на правилах как масштабируемых служб рассуждений в онтологиях, 
определяемых на таком пересечении. 
\end{itemize}

В октябре 2009~г.\ был завершен важный этап RIF~--- публикация документов 
спецификации RIF~[7] в качестве кандидатов для стандартизации W3C:
\begin{enumerate}[(1)]
\item RIF Overview; 
\item RIF Core Dialect;
\item RIF Basic Logic Dialect;
\item RIF Framework for Logic Dialects;
\item RIF RDF and OWL Compatibility;
\item RIF Datatypes and Built-Ins 1.0;
\item RIF Production Rule Dialect;
\item RIF Test Cases;
\item RIF Combination with XML data;
\item OWL 2 RL in RIF.
\end{enumerate}

В июне 2010~г.\ документы 2--6 были приняты в качестве стандарта W3C. Создание 
общепринятой\linebreak
 спецификации RIF~--- сложная задача. Выполненная RIF WG работа 
впечатляет глубиной за\-мыс\-ла, масштабом, точностью разработанных, тщательно
формализованных спецификаций. \mbox{Можно}\linebreak ожидать, что предложенная концепция окажет 
существенное влияние на развитие декларативных языков и их применение в различных 
областях, расширяя тем самым существующие пределы использования систем на правилах. 
Результаты, полученные RIF WG, заслуживают детального анализа и изучения. Настоящая 
работа посвящена именно такому анализу. 

Статья организована следующим образом. 
В~разд.~2 дан краткий анализ истории развития и применения языков и систем на 
правилах, включая области представления знаний, дедуктивных баз данных, логических 
моделей рассуждений. В~разд.~3 приведен обзор различных семантик логических 
программ на правилах, таких как стратифицированная семантика, семантика стабильной 
модели логической программы, хорошо обоснованная семантика. В~разд.~4 рассмотрены 
основные классы применений интероперабельных программ на правилах, на основе 
которых были выработаны требования к RIF. В~разд.~5 рассмотрены основные решения, 
принятые в проекте RIF.

\section{Языки на правилах и~их~применение: краткий исторический 
экскурс}

Настоящий раздел является введением в контекст, в рамках которого формировался проект 
RIF. При написании раздела использовались материалы известных обзоров 
симбиотического развития логики и программирования, логики и баз данных, а также 
применения полученных результатов для представления знаний и программирования 
различных моделей рассуждений в приложениях~[10--24].
   
   \subsection{Программы на правилах, классы применений} %2.1
Логическое программирование характеризуется тремя основными классами применений: в 
качестве универсального языка программирования, языка баз данных, языка 
представления знаний. В~качестве языка программирования оно позволяет представить и 
вычислить любую вычислимую функцию. Как язык баз данных оно обобщает реляционные 
базы данных, позволяя наряду с фактами представлять правила общего вида. Наконец, как 
язык представления знаний оно является немонотонной логикой, которую можно 
использовать для рассуждений по умолчанию (подробнее о моделях рассуждений см.\ 
п.~2.4).

Логические программы представляют собой множества условных высказываний вида:

\textit{if} $B_1$ \textit{and \ldots\  and} $B_n$ \textit{then} $H$\,,

\noindent
в которых \textit{следствие}~$H$ представляет собой атомарную формулу, а 
\textit{условия}~$B_i$ являются \textit{литералами}, представляющими собой атомарные 
формулы или их отрицания. Все переменные неявно связаны квантором всеобщности, 
располагаемым перед условным высказыванием. Условные высказывания в логических 
программах называются \textit{клаузами}. Факты являются клаузами специального вида, в 
которых $n\hm= 0$ (нет условий) и нет переменных. Клаузы, не являющиеся фактами, 
называются \textit{правилами}. Цели (или \textit{запросы}) представляют собой 
конъюнкции литералов, подобно условиям в клаузах. Однако все переменные в них неявно 
связаны квантором существования, и задачей цели является отыскание означиваний 
переменных цели, при которых цель приобретает истинное значение.

При \textit{обратных рассуждениях} (от следствий к условиям) условные высказывания 
рассматриваются как процедуры редуцирования цели: чтобы показать, что~$H$, нужно 
разрешить $B_1$ \textit{and}\ \ldots\ \textit{and}~$B_n$.

Поскольку условные высказывания в логических программах рассматриваются в таком 
обратном порядке, обычно они так и записываются:

$H$ \textit{ if} $B_1$ \textit{and\ \ldots\ and} $B_n$,

\noindent
так что обратные рассуждения становятся эквивалентными <<прямому связыванию>> или 
<<прямому сцеплению>> в направлении, в котором записывается условное высказывание. 
В~синтаксисе языка Prolog клауза выглядит так:

$H$:\;- $B_1$,\ \ldots , $B_n$.

\noindent
В таком виде клаузы можно трактовать либо декларативно как условные высказывания в 
обратной записи, либо процедурно как процедуры редуцирования цели, исполняемые в 
прямом направлении. 

Позитивные атомарные цели и подцели разрешаются в процессе обратных рассуждений. 
Цели\linebreak и подцели с отрицанием вида \textit{not} $G$, где $G$~--- атомарное предложение, 
разрешаются при трактовке отрицания как неудачи, согласно которой \textit{not}~$G$ 
удовле\-тво\-ря\-ет\-ся тогда и только тогда, когда обратные рассуждения с подцелью~$G$ терпят 
неудачу. Отрицание как неудача превращает логическое программирование в 
немонотонную логику.

Цели и условия клауз могут быть обобщены, так что вместо конъюнкций литералов могут 
быть использованы произвольные формулы логики первого порядка.
   
   \subsection{Применение логики для~представления знаний и~решения~задач} %2.2

В этом пункте кратко рассмотрено развитие подходов, основанных на применении языков 
на правилах для представления знаний и решения задач~\cite{10kal}. Рассматриваемые 
подходы важны для понимания мотивации проекта RIF.

К концу 1960-х гг.\ в подходах к искусственному интеллекту наметились две 
основных тенденции: эвристический подход, связываемый главным образом с 
продукционными системами и стремлением к представлению специальных знаний 
конкретных предметных областей, и формальный подход, применявшийся в системах, 
основанных на принципе резолюции, в рамках которого подчеркивалась важность 
универсальных методов решения задач, не зависящих от предметной области.

Процедурный подход как альтернатива логическому находит выражение в системах Planner 
и micro-Planner (MIT). В~1971~г.\ Виноградом на основе системы micro-Planner был 
реализован диалог на естественном языке для простой предметной об\-ласти. Ковальски в 
сотрудничестве с Кольмероэ предпринял попытку повторить в логике реализацию 
системы Винограда на основе принципа резолюции. Это привело к реализации процедурной 
интерпретации Хорновских клауз в 1974~г.\ и к разработке языка программирования 
Prolog в начале 1970-х~гг.\ в Марсельском университете А.~Кольмероэ и его сотрудниками на 
основе теоретических работ Р.~Ковальски (программа доказательства теорем, которая 
включала интерпретатор Хорновских клауз Ковальски).

В середине 1970-х гг.\ Марвин Минский (MIT) предпринял очередное 
наступление против логического подхода, предложив фреймы для пред\-став\-ле\-ния знаний по 
умолчанию без необходимости строгой и точной спецификации исключений.

Логическое сообщество ответило немонотонными логиками, включая очерчивание 
МакКарти (1980~г.), логику умолчания Рейтера (1980~г.), аутоэпистемическую логику Мура 
(1985~г.), обоснованное Кларком отрицание как неудачу в логическом программировании 
(1978~г.).

В этот же период было замечено, что рассуждение по умолчанию можно интерпретировать 
как форму абдуктивных рассуждений. Основываясь на этих результатах, Ковальски показал, 
что отрицание как неудачу в логическом программировании можно также 
интерпретировать в таких терминах. Дунг (2006~г.)\ показал, что большинство 
немонотонных логик может быть интерпретировано в терминах логики аргументации на 
основе абдуктивных гипотез. 

Абдуктивные модели логического програм\-мирования 
(Abductive Logic Programming, ALP) 
используют специальную трактовку различий между данными и ограничениями 
целостности в базах\linebreak данных для интерпретации убеждений как данных и целей как 
ограничений целостности. В~традиционных базах данных ограничения целостности 
используются пассивно, чтобы воспрепятствовать неправильным изменениям данных. 
В~абдуктивном логическом программировании они играют роль, подобную ограничениям 
целостности в активных базах данных, в которых они, с одной стороны, препятствуют 
неправильным изменениям, а с другой~--- выполняют корректирующие действия для 
поддержания целостности базы данных. 

Продукционные правила, используемые как ассоциации стимул--реакция, могут 
рассматриваться как ограничения целостности такого вида. По сравнению с классической 
логикой, которой соответствует как декларативная теоретико-модельная семантика, так и 
различные процедуры доказательства, продукционные системы не имеют декларативной 
семантики вообще. Продукционные правила имеют вид логических импликаций, не обладая 
семантикой импликаций.

Область дедуктивных баз данных~[19], в особенности область обработки рекурсивных 
запросов, становится быстро развивающейся во второй половине 1980-х\,--\,начале 
1990-х~гг. Дедуктивные базы данных заимствуют значительное число концепций от 
логического программирования. Так, правила и факты, представляемые в языке 
дедуктивных баз данных Datalog, похожи на представления программ на языке Prolog. 
Вместе с тем существует ряд существенных различий между дедуктивными базами данных 
и логическим программированием. Одним из основных различий является то, что 
логические программы ориентированы на покортежную обработку, в то время как 
дедуктивные базы данных оперируют множествами. Языки различных систем дедуктивных 
баз данных отличаются видом поддерживаемой рекурсии, интерпретацией отрицания, 
способностью поддерживать ограничения целостности, видом поддерживаемых внешних 
интерфейсов.

Если первоначально в работах по языкам логического программирования преобладало 
стремление достижения декларативности программ, то в\linebreak
дальнейшем доминирующим 
стало намерение поддержать средствами языков различные модели логических 
рассуждений. В большинстве своем систе\-мы поддержки логических рассуждений являются 
немонотонными (например, в области принятия решений, обработки исключительных 
ситуаций, аргументации, байесовских стратегий, статистического вывода и~пр.). 
Существенным для логических рассуждений моментом является трактовка ими 
предположений о замкнутости или открытости мира, а также интерпретация отрицания 
(например, отрицание как неудача~\cite{20kal, 19kal, 21kal, 22kal} связано с 
предположением о замкнутости мира, поскольку согласно ему каждый предикат считается 
ложным, если нельзя доказать его истинность). 

К подобным моделям логических рассуждений относятся, например, следующие.

\textit{Рассуждения на основе умолчания}~\cite{16kal, 17kal, 18kal}. Этот вид рассуждений 
поддерживается логиками умолчания~\cite{17kal}, отмены заключений, аргументации, 
программирования множества ответов (Answer Set Programming, ASP).

\textit{Абдуктивные рассуждения}~\cite{15kal} составляют процесс получения наиболее 
вероятных объяснений известных фактов. Абдуктивная логика является немонотонной, 
поскольку наиболее вероятные объяснения не обязательно являются правильными. 
Абдукция~--- познавательная процедура принятия гипотез.

\textit{Логика очерчивания} (\textit{circumscription})~--- это немонотонная логика, созданная 
Дж.~МакКарти для формализации предположений здравого смысла, которые должны 
действовать по отношению к сущностям реального мира, если нет других указаний.

\textit{Логика отмены заключений} (\textit{defeasible reasoning})~--- это разновидность 
рассуждений, основанных на суждениях, которые являются отменяемыми, в отличие от 
неотменяемых суждений, характерных для дедуктивной логики (такая способность 
является важной, например, при принятии решений).

\textit{Логика рассуждений о действиях и изменениях}. Большая часть работ в этой области 
посвящена применению ситуационного исчисления~--- формализма, предложенного 
Дж.~МакКарти для описания действий, рассуждений о них и эффектов действий. Активно 
исследуются логики действий, применение модальных логик для рассуждений о знаниях и 
действиях.

\textit{Логика рассуждений с неопределенностью}. Сюда относятся статистические методы 
обнаружения закономерностей в данных.

Следует заметить, что каждая из перечисленных моделей логических рассуждений является 
предметом серьезных исследований, результаты которых находят применение в различных 
областях. Эти исследования тесно связаны с развитием языков логического 
программирования с адекватной семантикой.

\vspace*{-8pt}

\section{Разнообразие семантик логических программ}

\vspace*{-3pt}
   
   \subsection{Минимальная модель программы. Стратифицированная семантика} %3.1
   
   \vspace*{-1pt}

Клауза Хорна представляет собой конъюнкцию литералов~--- атомарных формул (атомов) 
или их отрицаний с не более чем одним атомом в голове. Клауза Хорна с одним атомом в 
голове называется \textit{определенной} (definite) клаузой. Клаузы Хорна играют 
основополагающую роль в логическом программировании. Клауза Хорна, не содержащая 
атома в голове, называется целевой клаузой. Резолюция целевой клаузы с определенной 
клаузой, при которой образуется новая целевая клауза, составляет основу SLD-резолюции 
(Selective Linear resolution with Definite clauses)~--- одного из способов интерпретации 
логических программ. Теоретико-модельная семантика подразумевается при реализации 
вывода в прямом направлении (снизу вверх) или в обратном направлении (сверху 
вниз)\footnote{При обратном рассуждении атомарный запрос унифицируется с головой 
правила и заменяется соответствующим экземпляром тела. При прямом рассуждении 
голова означенного экземпляра правила включается в множество следствий после того, как 
все атомы тела этого правила уже были включены в множество следствий.}.

Семантика логической программы определяется ее минимальной моделью. Программа, 
содержащая только атомы без отрицаний, называется\linebreak
позитивной. Каждой позитивной 
программе соответствует единственная минимальная модель, называемая наименьшей 
моделью. Определение\linebreak
наименьшей модели достигается оператором вычисления 
наименьшей неподвижной точки логической программы.

Позитивные логические программы позволяют реализовать декларативное моделирование 
при решении разнообразных задач. Во многих случаях, однако, требуется использование 
отрицания, нуж\-да\-юще\-го\-ся в адекватной семантической интерпретации. Семантика языка 
Prolog представляет собой развитие от SLD к SLDNF резолюции на основе идеи отрицания 
как неудачи (Negation As Failure, NAF).

Реализация отрицания как неудачи в языке Prolog является проблематичной~\cite{25kal}: 
использование NAF в теле клауз приводит к сложностям в случае рекурсии при наличии 
циклических зависимостей предикатов (атомов) в правилах; поэтому современные системы 
логического программирования используют либо хорошо обоснованное отрицание по 
умолчанию~\cite{26kal}, либо отрицание с семантикой, определяемой стабильной 
моделью~\cite{19kal, 27kal}.

Важный класс программ с отрицанием со\-став\-ля\-ют \textit{стратифицированные 
программы}. Они обладают тем свойством, что можно установить порядок вычисления 
правил программы, при котором значения атомов с отрицанием могут быть 
предопре\-де\-ле\-ны. Иными словами, для вычисления тела правила, содержащего 
\textit{not}~$r(t)$, значение атома с отрицанием~$r(t)$ должно быть определено. С~этой 
целью предикаты вычисляются по слоям (стратам) программы снизу вверх. Этот подход 
работает, если в программе не возникает циклов с предикатами, содержащими отрицание.

Стратификация заключается в любом непротиворечивом присваивании номеров символам 
предикатов, гарантирующем существование однозначной формальной интерпретации 
логической програм\-мы. Говорят, что набор клауз вида 

\begin{center}
\textit{Q}$_1$\;$\land \cdots \land$\;\textit{Q}$_n$\;$\land \neg$\; 
\textit{Q}$_{n+1}$\;$\land \cdots \land\neg $\;\textit{Q}$_{n+m}$\;$\rightarrow$\;\textit{P}
\end{center}
 
\noindent
стратифицирован тогда и только тогда, 
когда существует стратификационная нумерация, удовлетворяющая следующим условиям:
\begin{enumerate}
\item Если предикат~$P$ позитивно выводим из предиката~$Q$ (т.\,е.\ $P$ находится в голове правила, а 
$Q$ позитивно входит в тело этого же правила), то стратификационный номер~$P$ должен быть 
б$\acute{\mbox{о}}$льшим 
или равным стратификационному номеру~$Q$: $S(P) \hm \geq S(Q)$.
\item Если предикат $P$ выводим из предиката с отрицанием~$Q$ (т.\,е.\ $P$ находится в голове правила, а 
$Q$ входит с отрицанием в тело этого же правила), то стратификационный номер~$P$ должен быть 
б$\acute{\mbox{о}}$льшим стратификационного номера~$Q$: $S(P) \hm> S(Q)$.
\end{enumerate}

Понятие стратифицированного отрицания позволяет получить эффективную 
операционную семантику стратифицированной программы на основе стратифицированной 
наименьшей неподвижной точки, вычисляемой итеративно. Оператор получения 
неподвижной точки применяется к каждой страте программы, двигаясь от страт с 
меньшими номерами к стратам с большими номерами.

В контексте IDB (Intensional DataBase) и EDB (Extensional DataBase)
последняя, представляющая собой набор фактов, получает номер 
(ранг)~0. Предикаты IDB, правила определения которых не включают отрицаний, также 
имеют ранг~0. Предикаты IDB, чьи единственные отрицательные зависимости выражаются 
посредством предикатов ранга~0, получают ранг~1 и~т.\,д. Стратифицируемость легко 
установить синтаксически анализом одной лишь IDB. 

Определение стратифицированной 
семантики реализуется индуктивно. После того как все атомы с рангом, меньшим~$k$, были 
классифицированы как позитивные или атомы с отрицанием, эти литералы используются 
для получения значений позитивных атомов ранга~$k$ и определения $\lnot q$ для всех 
атомов $q$ ранга~$k$, которые не были выведены. Полученный результат называется 
стратифицированной мо\-делью.

Стратифицированная семантика согласуется с семантикой хорошо обоснованной модели 
для всех рангов. Нестратифицируемым программам соответствует хорошо обоснованная 
семантика или семантика стабильной модели.
   
   \subsection{Семантика стабильной модели логической программы} %3.2

В логическом программировании существует два принципиально разных взгляда на 
семантику программ, отражающих две философски различные точки зрения~\cite{28kal}.

Первый подход отражает стремление сохранить единственную модель программы даже для 
проб\-лем\-ных классов программ с отрицанием. Этого можно достичь, определяя надлежащим 
образом выбор единственной модели среди всех возможных моделей программы. Наиболее 
популярная семантика в этом подходе основана на \textit{хорошо обосно\-ван\-ной модели}.

Второй подход характеризует противоположная точка зрения~--- соотнесение программе 
множества моделей, отбрасывая <<догматическое>> требование единственности модели. 
В~общем случае считается, что одной программе может соответствовать множество 
совместимых с ней сценариев получения модели. В~рамках этого подхода говорят о 
генерации множества \textit{стабильных моделей}. Этот подход выходит за рамки простого 
ответа на запрос, речь идет о получении решения задач.

Далее оба подхода рассматриваются более подробно, начиная с семантики стабильной 
модели. Интуитивно семантика стабильной модели основана на особой трактовке атомов с 
отрицанием, являющихся источником <<противоречий>> или <<нестабильности>>. 
<<Стабильность>> при этом заключается в следующем. Если интерпретация~$M$ 
программы~$P$ непротиворечива, то она стабильна.

Простой пример программы, которой соответствует множество моделей:

\smallskip

\textit{man}(\textit{petrov}). 

\textit{single}(\textit{X}):\;- \textit{man}(\textit{X}), \textit{not husband}(\textit{X}).

\textit{husband}(\textit{X}):\;- \textit{man}(\textit{X}), \textit{not single}(\textit{X}).

\smallskip

\noindent
Здесь утверждения \textit{single}(\textit{petrov}) и \textit{husband}(\textit{petrov}) 
взаимозависимы при использовании отрицания. Алгоритм SLD-резолюции зациклился бы 
здесь при попытке ответить на запрос \textit{single}(\textit{X}). Вместе с тем у этой 
программы есть две минимальных модели Эрбрана, являющихся стабильными:
%\begin{align*}

\smallskip


\textit{M}$_1$\;=\;\{\textit{man}(\textit{petrov}), \textit{single}(\textit{petrov})\},

\textit{M}$_2$\;=\;\{\textit{man}(\textit{petrov}), \textit{husband}(\textit{petrov})\}.
%\end{align*}

\smallskip


\noindent
Подход к логическому программированию на осно\-ве семантики стабильной 
модели~\cite{27kal}, вы\-ра\-жа\-ющий применение идеи аутоэпистемической 
логики~\cite{29kal} и логики умолчания~\cite{20kal} к анализу\linebreak
отрицания как неудачи, 
называется \textit{программированием множества ответов}~(ASP)~\cite{28kal}. 
Возможность использования средств вывода множества ответов как 
новой парадигмы программирования\linebreak
 была обосно\-ва\-на в~\cite{30kal} (название 
<<программирование множества ответов>> было впервые употреблено в заголовке 
соответствующей части сборника, вклю\-ча\-юще\-го эту статью) и в~\cite{31kal}.

Язык ASP отличается от многих языков представления знаний способностью выражать 
утверждения, основанные на умолчании, вида <<обычно экземпляры класса~$C$ 
удовлетворяют свойству~$P$>>.\linebreak
Выражение умолчаний, исключений из таких умолчаний, а 
также способов использования этой информации для вывода адекватных заключений 
может быть поддержано ASP. Язык ASP позволяет\linebreak
также выражать причинный эффект действий 
(<<утверждение~$F$ становится истинным в результате выполнения действия~$A$>>), 
утверждений, вы\-ра\-жа\-ющих недостаток информации (<<неизвестно, является ли 
утверждение~$P$ истинным или ложным>>), различные предположения общего вида, 
например <<утверждения, не следующие из базы знаний, являются ложными>>.

В ASP как в язык программирования синтаксически добавляются дизъюнкции, сильные 
отрицания (наряду со слабым отрицанием, использующем семантику отрицания как 
неудачи), ограничения.

В дизъюнктивном правиле голова может представлять собой дизъюнкцию нескольких 
атомов:

\begin{center}
\textit{A}$_1$\;$\vee$\ \ldots $\vee$\;\textit{A}$_k$: - \textit{B}$_1$, \ldots , 
\textit{B}$_m$, \textit{not}\ \textit{C}$_1$, \ldots , 
\textit{not}\ \textit{C}$_n$.
\end{center}

\noindent
Например, можно использовать правило вида

\begin{center}
\textit{female}(\textit{X})\;$\vee$\;\textit{male}(\textit{X}): - \textit{person}(\textit{X}).
\end{center}

\noindent
Пример записи дизъюнктивного факта:

\begin{center}
\textit{broken}(\textit{left}\_\textit{hand}, 
\textit{tom})\;$\vee$\textit{broken}(\textit{right}\_\textit{hand}, \textit{tom}).
\end{center}

\noindent
Правило

\begin{center}
\textit{ok}(\textit{C})\;$\vee\lnot$\;\textit{ok}(\textit{C}):\;- \textit{component}(\textit{c})\,.
\end{center}

\noindent
утверждает, что компонент может находиться в рабочем состоянии или не работать.

Для выражения правил с умолчанием используется сильное отрицание в комбинации со 
слабым. Например, выражение того, что <<по умолчанию птица летает>>, обеспечивается 
правилом

\begin{center}
\textit{flies}(\textit{X}):\;-  \textit{bird}(\textit{X}), \textit{not}\;$\lnot$\;\textit{flies}(\textit{X}).
\end{center}

\noindent
Здесь $\lnot$~--- сильное отрицание. Предикат \textit{not}~$p$ в теле правила можно 
интерпретировать (согласно В.~Лифшицу) как <<не верится, что~$p$>>. 



Программы в ASP могут включать также правило выбора, такое как 
$$
\{s, t\}:\mbox{-}\ p\,.
$$

\pagebreak

\noindent
Это правило означает следующее. Если~$p$ включается в стабильную модель, то следует 
выбрать произвольным образом, какой из атомов~--- $s$ или~$t$~--- нужно включить. 



Простое расширение позволяет использовать в программах ограничения правила, в 
которых отсутствует голова:

\begin{center}
:\;-\  \textit{B}$_1$, \ldots , \textit{B}$_m$, \textit{not}\ \textit{C}$_1$,\ldots , 
\textit{not}\ \textit{C}$_n$.
\end{center}

\noindent
Здесь \textit{B}$_1$, \ldots , \textit{B}$_m$, \textit{C}$_1$, \ldots , \textit{C}$_n$~--- 
атомы. Ограничению соответствует отрицание 
формулы, эквивалентной его телу:

\begin{center}
$\lnot$\;(\textit{B}$_1$\;$\land \ldots \land$ 
\textit{B}$_m$ $\land \lnot$ \textit{C}$_1$ $\land \ldots \land \lnot$ \textit{C}$_n$).
\end{center}

\noindent
В ASP ограничения играют важную роль. Включение ограничения в логическую 
программу~$P$ оказывает влияние на набор стабильных моделей~$P$: стабильные модели, 
нарушающие ограничение, исключаются из такого набора. Иными словами, для любой 
логической программы~$P$ с ограничениями и любого ограничения~$C$ стабильные 
модели $P\cup \{C\}$ включают те стабильные модели~$P$, которые удовле\-тво\-ря\-ют~$C$.

Далее следует пример спецификации задачи трехцветной (\textit{b}, \textit{r}, \textit{g}) 
раскраски графа $G \hm= 
(V, E)$, представленного узлами \textit{node}(\textit{n}) для каждого 
$n \hm\in V$ и ребрами \textit{edge}(\textit{n}, \textit{n}$^\prime$) 
для каждой пары $(n, n^\prime) \hm\in E$, задаваемой следующими правилами:

\smallskip

\textit{b}(\textit{X}):\;-\ \textit{node}(\textit{X}), 
\textit{not}\; \textit{r}(\textit{X}), \textit{not}\; \textit{g}(\textit{X}). 

\textit{r}(\textit{X}):\;-\ 
\textit{node}(\textit{X}), \textit{not}\; \textit{b}(\textit{X}), \textit{not} \textit{g}(\textit{X}).

\textit{g}(\textit{X}):\;-\ 
\textit{node}(\textit{X}), \textit{not}\; \textit{r}(\textit{X}), \textit{not} \textit{b}(\textit{X}).

\smallskip

\noindent
и ограничениями

\smallskip

:\;- \textit{b}(\textit{X}), \textit{b}(\textit{Y}), \textit{edge}(\textit{X}, \textit{Y}).

:\;- \textit{r}(\textit{X}), \textit{r}(\textit{Y}), \textit{edge}(\textit{X}, \textit{Y}).

:\;- \textit{g}(\textit{X}), \textit{g}(\textit{Y}), \textit{edge}(\textit{X},\textit{Y}).

\smallskip

Логическое программирование в парадигме ASP успешно применяется для решения задач в 
широком классе проблем, включая диагностику в разных областях, интеграцию 
информации, поиск решения при задании набора ограничений, планирование действий, 
прокладку маршрутов, проблемы биомедицины и биологии, извлечение информации из 
текстов, классификацию.

Пусть~$P$ представляет собой множество правил вида

\begin{center}
\textit{A}:\;-\ \textit{B}$_1$, \textit{B}$_2$, \ldots , \textit{B}$_m$, 
\textit{C}$_1$, \textit{C}$_2$, \ldots , \textit{C}$_n$.
\end{center}

\noindent
Здесь \textit{A}, \textit{B}$_1$, \textit{B}$_2$, \ldots , \textit{B}$_m$, 
\textit{C}$_1$, \textit{C}$_2$, \ldots , \textit{C}$_n$~--- базовые (ground) атомы. 
Если~$P$ не 
содержит отрицаний $(n \hm= 0)$ в каждом правиле программы, то по определению 
единственной стабильной моделью~$P$ является ее минимальная модель. Чтобы 
расширить это определение на случай программ с отрицанием, понадобится 
вспомогательное понятие редукта, определяемого следующим образом.

Для любого множество~$I$ базовых атомов \textit{редуктом}~$P$ по отношению к~$I$ 
называется множество правил без отрицания, полученных из $P$ исключением каждого 
правила, такого что, по крайней мере, один из атомов~$C_i$ в теле этого правила 
принадлежит~$I$, а затем исключением частей \textit{not}~$C_1$, \textit{not}~$C_2$,\ \ldots , 
\textit{not}~$C_n$ из тел оставшихся правил.

Это \textit{преобразование Гельфонда--Лифшица}~\cite{32kal}, иногда называемое 
стабильным преобразованием. Целью такого преобразования является пред\-став\-ле\-ние 
моделей как множества базовых атомов, в котором отсутствующие атомы представляют 
атомы с отрицанием. В~этом контексте <<минимальная модель>>~--- это модель, 
содержащая минимальное множество позитивных атомов, а <<монотонность 
преобразования>> полных интерпретаций заключается в том, что оно монотонно при 
рассмотрении одних лишь позитивных атомов. Стабильные модели представляются в 
двузначной логике.

Говорят, что $I$~--- это \textit{стабильная модель}~$P$, если $I$~--- стабильная модель 
редукта~$P$ по отношению к~$I$. Каждая стабильная модель~$P$ является моделью~$P$. 
Полная модель логической программы~$P$ является стабильной, если она является 
неподвижной точкой трансформации Гельфонда--Лифшица. Если программа~$P$ имеет в 
точности одну стабильную модель, то она называется уникальной стабильной 
моделью~$P$.
   
   \subsection{Хорошо обоснованная семантика и~ее~соотношение с~ASP} %3.3

Хорошо обоснованной семантикой Web Feature Service (WFS) программы~$P$ согласно определению 
из~\cite{26kal} является ее значение, представленное наименьшей неподвижной точкой 
трансформации множества литералов, атомы которых входят в базу Эрбрана данной 
программы~$P$. Каждый позитивный литерал означает, что его атом является истинным, 
каждый литерал с отрицанием означает, что его атом является ложным, а атомы не имеют 
присвоенного им значения истинности. Таким образом, эта модель является моделью 
трехзначной логики.

Например, если известно, что

\begin{center}
\textit{Объект~A}~--- \textit{ это ночная бабочка},\\
\textit{если~A не летает днем},
\end{center}

\noindent
но неизвестно, летает ли \textit{A} днем, в хорошо обоснованной семантике высказывание 
<<объект~\textit{A}~--- это ночная бабочка>> получает значение \textit{unknown}, т.\,е.\ его 
значением не является ни истина, ни ложь.

Если атом является истинным в хорошо обосно\-ван\-ной модели программ~$P$, то он 
принадлежит каждой стабильной модели~$P$. Обратное утверждение, вообще говоря, не 
выполняется. Например, программа

\smallskip

\textit{p}:\;- \textit{not q}.

\textit{q}:\;-  \textit{not p}.

\textit{r}:\;-  \textit{p.}

\textit{r}:\;-  \textit{q.}

\smallskip

\noindent
имеет две стабильные модели \{\textit{p},\,\textit{r}\} и \{\textit{q},\,\textit{r}\}. 
Несмотря на то что \textit{r} принадлежит 
обеим моделям, значением~\textit{r} в хорошо обоснованной модели является \textit{unknown}.

Более того, если атом является ложным в хорошо обоснованной модели программы, то он не 
принадлежит ни к одной ее стабильной модели. Таким образом, хорошо обоснованная 
модель логической программы является нижней гранью пересечения ее стабильных 
моделей и верхней гранью их объединения.

Одним из основных отличий ASP от хорошо обосно\-ван\-ной семантики является ориентация 
ASP на решение переборных задач, что невозможно в WFS. Из-за различия выразительной 
способности двух парадигм они используются в разных целях. Язык ASP идеально подходит для 
решения сложных комбинаторных задач, соответствующие этой парадигме системы обычно 
применяются как компоненты поддержки баз знаний, встраиваемые в императивные 
системы программирования. Например, система LPARSE первоначально была создана как 
фронтальный процессор для решателя множества ответов SMODELS, а впоследствии 
использовалась аналогичным образом с большинством других решателей множества 
ответов. Система DLV~\cite{33kal} является исключением: синтаксис ASP-программ в DLV 
отличается от синтаксиса, используемого в других системах.

Диалекты логического программирования, такие как Datalog с немонотонным отрицанием, 
над которыми надстраивается ASP (как расширение Datalog'а), часто рассматриваются в 
качестве естественного основания для слоя правил Семантического Веба. Современные 
системы ASP содержат расширения для извлечения данных в RDF и задания запросов к OWL. 
В~архитектуре Семантического Веба изучаются проблемы, возникающие в связи с 
добавлением правил с немонотонным отрицанием, основанным на предположении о 
замкнутости мира, над RDF и OWL, основанных на предположении об открытости 
мира\footnote{Эта проблема подробно изучается в проекте RIF.}.

В противоположность ASP, WFS-базированные системы являются вычислительно полными 
и используются как полновесные системы программирования. Хорошо обоснованная 
семантика является основой реализации многих систем (например, XSB, Ontobroker, 
Intellidimension, SweetRules, SILK, FLORA).
   
   \subsection{Фреймовая логика и~язык метапрограммирования} %3.4

В этом пункте кратко рассматриваются элементы языков F-Logic и HiLog (в их воплощении 
в языке системы на правилах FLORA-2~\cite{34kal}), которые оказали существенное 
влияние на формирование каркаса RIF.

Фреймовая логика (F-logic)~\cite{35kal, 36kal} рас\-смат\-ри\-ва\-ет\-ся как язык представления 
знаний и как онтологический язык. Она соединяет возможности\linebreak концептуального 
моделирования с объект\-но-ори\-ен\-ти\-ро\-ван\-ны\-ми, фрей\-мо\-во-ба\-зи\-ро\-ван\-ны\-ми языковыми 
средствами и предлагает компактное, декларативное представление программ в хорошо\linebreak 
обоснованной семантике логического языка программирования. Язык поддерживает такие 
средства, как, например, уникальная идентифицируемость сложно структурированных 
объектов,\linebreak
 наследование, полиморфизм, методы, поддерживающие запросы, инкапсуляция. 
Первоначально F-logic как язык был разработан в ориентации на дедуктивные базы данных, 
но в последнее время он используется все чаще для поддержки семантических технологий. 
При этом F-logic обеспечивает логические основания фрей\-мо\-во-базированного и 
объектно-ориентированного языка представления данных и знаний.

HiLog~--- это логическое расширение языка Prolog для поддержки средств 
метапрограммирования и программирования в логике высоких порядков при сохранении 
вычислимости в логике первого порядка.

Язык FLORA-2~--- это диалект F-logic с многочисленными расширениями, включая 
метапрограммирование в стиле языка HiLog и возможности изменения баз данных 
логическими\linebreak средствами, представленными в виде \textit{транзакционной логики}. FLORA-2 
обладает также развитыми средствами проектирования модульного программного 
обеспечения на основе динамических модулей. Области применения FLORA-2 включают 
область интеллигентных агентов, Семантический Веб, сети баз знаний, онтологическую 
инженерию, интеграцию информации. В~основе FLORA-2 используется машина вывода XSB.

Колорит языка логического программирования F-logic~\cite{34kal} придает ему 
немонотонную семантику при интерпретации операции отрицания как неудачи, поддержке 
множественного наследования с перекрытием, что выходит за рамки традиционного 
логического программирования.

В синтаксисе F-logic выражение при\-над\-леж\-ности экземпляра классу выглядит как 
\textit{John:student}, а выражение отношения подкласса реализуется как 
\textit{student::person}. Сами классы интерпретируются как объекты, так что один и тот же 
объект может играть роль класса в одной формуле и роль объекта в дру-\linebreak гой. Например, в 
формуле \textit{student:class} символ\linebreak
\textit{student} играет роль объекта, тогда как в 
формуле \textit{student::person} он выступает в роли класса.

F-logic также обеспечивает возможность задания информации о схеме при помощи 
сигнатурных формул. Например, \textit{person}[\textit{spouse} 
\{0:1\}\;$\Rightarrow$\;\textit{person}, \textit{name}\{0:1\}\;$\Rightarrow$\;\textit{string}, 
\textit{child}\;$\Rightarrow$\;\textit{person}]~--- это сигнатурная формула, которая выражает 
тот факт, что класс \textit{person} имеет три атрибута~--- однозначные атрибуты 
\textit{spouse} и \textit{name} (однозначность выражается при помощи ограничения 
кардинальности 0:1) и множественного атрибута \textit{child}. При этом также сообщается, 
что значением первого атрибута являются объекты типа \textit{person}, второй атрибут 
принимает значения типа \textit{string}, а последний имеет значением множество, 
экземплярами которого являются объекты типа \textit{person}.

Ниже представлен пример программы о базе данных публикаций на языке 
FLORA-2~\cite{37kal}. Схема выглядит следующим образом:

\smallskip

%\end{multicols}

%\hrule

\noindent
\textit{paper}[\textit{authors}\;$\Rightarrow$\;\textit{person}, 
\textit{title}\;$\Rightarrow$\;\textit{string}].

\noindent
\textit{journal}\_\textit{p}\;::\;\textit{paper}[\textit{in vol}\;$\Rightarrow$\;\textit{volume}].

\noindent
\textit{conf}\_\textit{p}\;::\;\textit{paper}[\textit{at}\_\textit{conf}\;
$\Rightarrow$\;\textit{conf}\_\textit{proc}].

\noindent
\textit{journal}\_\textit{vol}[\textit{of}\;$\Rightarrow$\;\textit{journal}, 
\textit{volume}\;$\Rightarrow$\;\textit{integer}, 

\textit{number}\;$\Rightarrow$\;\textit{integer}, 
\textit{year}\;$\Rightarrow$\;\textit{integer}].

\noindent
\textit{journal}[\textit{name}\;$\Rightarrow$\;\textit{string}, 

\textit{publisher}\;$\Rightarrow$\;\textit{string}, \textit{editors}\;$\Rightarrow$\;\textit{person}].

\noindent
\textit{conf}\_\textit{proc}[\textit{of}\_\textit{conf}\;$\Rightarrow$\;
\textit{conf}\_\textit{series}, \textit{year}\;$\Rightarrow$\;integer,

\textit{editors}\;$\Rightarrow$\;\textit{person}].

\noindent
\textit{conf}\_\textit{series}[\textit{name}\;$\Rightarrow$\;\textit{string}].

\noindent
\textit{publisher}[\textit{name}\;$\Rightarrow$\;\textit{string}].

\noindent
\textit{person}[\textit{name}\;$\Rightarrow$\;\textit{string}, 
\textit{affil}(\textit{integer})\;$\Rightarrow$\;\textit{institution}].

\noindent
\textit{institution}[\textit{name}\;$\Rightarrow$\;\textit{string}, \textit{address}\;$\Rightarrow$\;\textit{string}].


\smallskip

\noindent
Частью программы являются также определения объектов:

\smallskip

\noindent
\textit{o}\_\textit{j}1: \textit{journal}\_\textit{p}[\textit{title}\;$\rightarrow$\;
`\textit{Records}, \textit{Relations}, \textit{Sets},

\textit{Entities}, \textit{and Things}', \textit{authors}\;$\rightarrow$\;
\{\textit{o}\_\textit{mes}\},

 \textit{in vol}\;$\rightarrow$\;\textit{o}\_\textit{i}11].

\noindent
\textit{o}\_\textit{di}: \textit{conf}\_\textit{p}[\textit{title}\;
$\rightarrow$\;`\textit{DIAM II and Levels of Abstraction}',

\textit{authors}\;$\rightarrow$\;\{\textit{o}\_\textit{mes}, 
\textit{o}\_\textit{eba}\}, \textit{at}\_\textit{conf}\;$\rightarrow$\;\textit{o}\_\textit{v76}].

\noindent
\textit{o}\_\textit{i}11: \textit{journal}\_\textit{vol}[\textit{of}\;$\rightarrow$\;
\textit{o}\_\textit{is}, \textit{number}\;$\rightarrow$\;1,

\textit{volume}\;$\rightarrow$\;1, \textit{year}\;$\rightarrow$\;1975].

\noindent
\textit{o}\_\textit{is}: \textit{journal}[\textit{name}\;$\rightarrow$\;
`\textit{Information Systems}',

\textit{editors}\;$\rightarrow$\;\{\textit{o}\_\textit{mj}\}].

\noindent
\textit{o}\_\textit{v76}: \textit{conf}\_\textit{proc}[\textit{of}\;$\rightarrow$\;
\textit{vldb}, \textit{year}\;$\rightarrow$\;1976, 

\textit{editors}\;$\rightarrow$\;\{\textit{o}\_\textit{pcl},  \textit{o}\_\textit{ejn}\}].

\noindent
\textit{o}\_\textit{vldb}: \textit{conf}\_\textit{series}[\textit{name}\;$\rightarrow$\;
`\textit{Very Large Databases}'].

\noindent
\textit{o}\_\textit{mes}: \textit{person}[\textit{name}\;$\rightarrow$\;
`\textit{Michael\ E.\ Senko}'].

\noindent
\textit{o}\_\textit{mj}: \textit{person}[\textit{name}\;$\rightarrow$\;
`\textit{Matthias\ Jarke}', 

\textit{affil}(1976)\;$\rightarrow$\;\textit{o}\_\textit{rwt}].

\noindent
\textit{o}\_\textit{rwt}: \textit{institution}[\textit{name}\;$\rightarrow$\;`\textit{RWTH Aachen}'].


%\begin{multicols}{2}

\smallskip

Запросы можно задавать как относительно информации в схеме классов, так и относительно 
содержания структуры отдельных объектов. Это достигается помещением переменных в 
надлежащие синтаксические позиции. Так, запрос

\begin{center}
?~-  \textit{student}[?\textit{M}\;$\Rightarrow$\;\textit{person}]
\end{center}

\noindent
находит методы, определенные на множествах в классе \textit{student}, и возвращает 
объекты типа \textit{person}. Следующий запрос возвращает все суперклассы класса 
\textit{student}:

\begin{center}
?~-  \textit{student}::?\textit{C\ and\ student}[\textit{name}\;$\Rightarrow$\;?\textit{T}].
\end{center}


Для повышения гибкости таких метазапросов в HiLog введены синтаксические конструкции 
второго порядка, что позволяет использовать переменные на месте функциональных и 
предикатных символов. Например, допускаются запросы, подобные следующему:

\begin{center}
?~-\ \textit{person}[?\textit{M}(?\textit{Arg})\;$\Rightarrow$\;\textit{integer}].
\end{center}

\noindent
в котором переменная ?\textit{M} связывается с функциями. Тем не менее семантика таких 
символов второго порядка остается первопорядковой. Это значит, что переменные 
связываются не с экстенсионалами символов (т.\,е.\ с отношениями, интерпретирующими 
символы предикатов или функций), а с самими такими символами.

HiLog допускает также использование переменных над атомарными формулами. Например, 
рассмотрим запрос, который завершается связыванием переменной ?\textit{X} с атомом \textit{p}(\textit{a}):

\smallskip

\textit{p}(\textit{a}).

\textit{q}(\textit{p}(\textit{a})).

?~-  \textit{q}(?\textit{X}), ?\textit{X}.

\smallskip

\noindent
Здесь высказывание \textit{p}(\textit{a}) материализуется (is \mbox{reified}) в виде объекта, 
в результате чего 
оно может быть связано с переменной. Материализация атомарных формул в HiLog'е может 
быть расширена до произвольных бескванторных формул языков HiLog и F-logic. Например, 
можно сказать, что \textit{John} верит в то, что \textit{Mary} нравится \textit{Sally}:
\textit{John}[\textit{believes}\;$\rightarrow$\;\$~\{\textit{Mary}[\textit{likes}\;$\rightarrow$\;\textit{Sally}]\}].
Обозначение \$\{\ldots\} в языке FLORA-2 используется для обозначения операторов 
материализации. Примером более сложного оператора материализации является 
следующий:

\smallskip

\noindent
\textit{John}[\textit{believes}\;$\rightarrow$

\$\{\textit{Bob}[\textit{likes}\;$\rightarrow$\;?
\textit{X}]:\;-\ \textit{Mary}[\textit{likes}\;$\rightarrow$\;\textit{?X}]\}].

\smallskip

\noindent
Это предложение материализует правило (не прос\-то факт) и утверждает, что \textit{John} 
также верит, что \textit{Bob}'у нравятся все, кто нравится \textit{Mary}. Соединяя с 
предыдущим оператором, что \textit{John} верит в то, что \textit{Mary} нравится \textit{Sally}, 
можно было бы ожидать заключения, что \textit{John} также поверит в то, что \textit{Bob}'у 
нравится \textit{Sally}. Однако такое заключение не может быть получено, поскольку 
неизвестно, является ли \textit{John} способным к рассуждению существом, которое может 
употреблять modus ponens в повседневной жизни. Но эту информацию можно сообщить 
простым образом: 

\smallskip

\noindent
\textit{John}[\textit{believes}\;$\rightarrow$\;\textit{ ?A}]:\;-\ 

\textit{John}[\textit{believes}\;$\rightarrow$\;\{\$\{\textit{?Head}:\;-\ \textit{?Body}\}; 
\textit{?Body}\}].

\smallskip


FLORA-2 включает также транзакционную логику с некоторыми уточнениями, 
позволяющими отличать запросы от транзакций и обеспечить возможность реализации 
контроля в период компиляции. В~транзакционной логике как действия, так и запросы 
представляются предикатами. В~языке FLORA-2 транзакции представляются методами 
объектов с префиксом <<\%>>.

В случае если постусловие транзакции выполняется, изменения вносятся в базу данных. 
Если это условие не выполняется, текущая попытка изменения базы данных считается 
неприемлемой и предпринимается следующая попытка. Если не находится ни одного 
приемлемого выполнения, транзакция не выполняет никаких изменений в базе данных. 
Таким образом обеспечивается атомарность транзакций.

В языке FLORA-2 поддерживается концепция областей действия для отрицания по 
умолчанию. Модуль в языке FLORA-2~--- это контейнер для отдельной базы знаний (или ее 
части). Модули позволяют изолировать отдельные части базы знаний и обеспечивают 
интерфейс для взаимодействия таких частей. Модули могут образовываться динамически, 
связываться с нужными частями базы знаний, обеспечивая эффективный вид 
инкапсуляции. Область действия запроса ограничивается модулем или всеми модулями, 
зарегистрированными в приложении. Это решение позволяет считать предположение о 
замкнутости мира (Closed World Assumption, CWA) приемлемым даже в среде Веба, если область действия программы 
явно и точно определена. Тем самым удается устранить возражения, направленные против 
идеи предположения о замкнутости мира, основанные на том, что Веб практически 
бесконечен и неудача в выводе некоторого факта из имеющейся информации не дает 
гарантии правильности заключения о том, что этот факт является ложным.

\section{Примеры использования и~требования к~RIF}
   
   \subsection{Примеры использования RIF и~системы на~правилах в~области интересов группы RIF 
WG} %4.1

При создании средств унификации неоднородных языков и обеспечения 
интероперабельности соответствующих систем~\cite{38kal} для уточнения требований к 
методам и средствам унификации и проверки их адекватности с самого начала проекта 
следует позаботиться об установлении взаимодействия с группами создания и поддержки 
конкретных разнородных языков и систем. Группой RIF WG изначально было определено, 
что система на правилах представляет интерес для RIF WG, если для нее будут взяты 
обязательства разработать применения, в которых потребовался бы обмен правилами с 
другими представляющими интерес для RIF WG сис\-те\-ма\-ми на правилах, и реализовать 
со\-от\-вет\-ст\-ву\-ющий пример использования. Более 50~предложений примеров использования 
были получены RIF WG в 2005~г.~\cite{39kal}. 

Категоризация примеров использования, приведенная первоначально в~\cite{40kal}, 
продолжает эволюционировать до сих пор. По мере развития проекта RIF требования к 
примерам использования уточнялись, в частности, для того, чтобы они в наибольшей мере 
соответствовали уже определенным диалектам. Результаты этой деятельности определены 
в уточняющих документах RIF WG~\cite{41kal}.

Список категорий примеров использования, согласно~\cite{40kal}, выглядит следующим 
образом.
\begin{enumerate}[1.]
\item Интеграция информации.
\item Принятие решений.
\item Кросс-платформенная разработка и развертывание правил.
\item Стратегии авторизации транзакций и управления доступом.
\item Обмен бизнес-правилами, ориентированными на взаимодействие с пользователем.
\item Публикация программ на правилах.
\item Сервисы обмена правилами для третьей сто\-роны.
\item Развитое представление знаний.
\end{enumerate}

Анализ полученных примеров использования показывает, что правила применяются для 
реализации разнообразных задач, и поэтому системы на правилах нельзя считать 
монолитными. Правила использовались для контроля качества вывода, реализации 
вычислений, управления информационными потоками, проверки ограничений целостности 
в базах данных, представления стратегий и управления ими, управления устройствами и 
процессами в реальном масштабе времени, определения потребности вмешательства 
человека в процессы управления и~др.

\vspace*{-4pt}
   
   \subsection{Требования к~RIF} %4.2

RIF должен быть определен таким образом, чтобы обеспечивалась возможность создания 
новых диалектов (требование расширяемости) в соответствии с основными целями и общими 
требованиями RIF, равно как и возможность изменения существующих диалектов (при 
соблюдении требования совмес\-ти\-мости снизу вверх).

Достижение междиалектной интероперабельности само по себе является плохо 
определенной задачей, поскольку известно, что трансляция диалектов с различной 
семантикой при полном сохранении смысла едва ли реализуема в большинстве случаев. Это 
не означает, что междиалектная трансляция вообще невозможна, однако требуются 
дополнительные критерии для формулировки точного понимания того, что считать 
удовлетворительной трансляцией (посредством обмена RIF-пра\-ви\-ла\-ми). До сих пор 
определение критериев качества междиалектной трансляции не входило в задачи RIF WG. 

Цели проекта и примеры использования пред\-опре\-де\-ли\-ли требования к RIF. Требования, 
определенные как общие, предусматривают набор фундаментальных свойств, которыми 
должны обладать создаваемые диалекты.

\vspace*{-9pt}
   
   \subsubsection{Общие требования} %4.2.1


\noindent
\begin{enumerate}[1.]
\item \textit{Реализуемость}. RIF должен быть реализуем на основе устоявшихся методов и не должен 
требовать дополнительных исследований, например алгоритмических или семантических проблем 
разработки трансляторов.
\item  \textit{Семантическая точность}. Ядро RIF должно иметь ясно и точно определенные синтаксис и 
семантику. Каждый стандартный диалект RIF должен иметь ясно и точно определенные синтаксис и 
семантику, расширяющие ядро RIF.
\item  \textit{Расширяемость формата}. Должна быть обеспечена возможность создания новых диалектов 
RIF, расширяющих существующие диалекты (совместимость в обратном направлении с уже созданными 
диалектами) и допускающих их постепенное внедрение в системах, которые используют уже 
существующие диалекты (совместимость в прямом направлении, в направлении развития).
\item  \textit{Трансляторы}. Для каждого стандартного диалекта RIF должна существовать возможность 
создания трансляторов между языками правил, определяемыми данным диалектом и RIF, без изменения 
языка правил.
\item  \textit{Стандартные компоненты}. Реализации RIF должны обеспечивать возможность 
использования стандартных вспомогательных технологий, таких как парсеры XML, генераторы 
\mbox{парсеров}, и 
не должны требовать специализированных реализаций при возможности повторного использования 
существующих решений.
\item  \textit{Охват спектра языков на правилах}. Из-за большого разнообразия языков на правилах едва ли 
найдется единственный язык обмена, который\linebreak
 мог бы служить мостом для всех языков на правилах. 
Поэтому RIF предлагает диалекты, каж\-дый из которых ориентирован на кластер подобных друг другу 
языков на правилах. RIF\linebreak должен обеспечивать внутридиалектную интероперабельность, т.\,е.\ 
интероперабельность между семантически подобными языками на правилах (при помощи обмена 
правилами RIF) в рамках одного диалекта, а также он должен поддерживать междиалектную 
интероперабельность, т.\,е.\ интероперабельность между диалектами на максимально возможном их 
пересечении.
\end{enumerate}

\vspace*{-9pt}

   \subsubsection{Требования, мотивированные примерами использования} %4.2.2

\noindent
\begin{enumerate}[1.]
\item \textit{Модель совместимости}. Спецификации RIF должны определять четкие критерии 
конформности для идентификации реализаций RIF, которые являются конформными.
\item \textit{Поведение по умолчанию}. RIF должен специфицировать на соответствующем уровне 
детализации поведение по умолчанию, которого можно ожидать от приложения, совместимого с RIF, но не 
обладающего способностью обработки всех или части правил, определенных в RIF-до\-ку\-мен\-те, либо он 
должен обеспечивать способ описания подобного поведения по умолчанию.
\item \textit{Семантические различия}. RIF должен охватывать языки на правилах, имеющие различную 
семантику.
\item \textit{Ограниченное число диалектов}. RIF должен иметь стандартное ядро и ограниченное число 
стандартных диалектов, базирующихся на этом ядре.
\item \textit{Данные OWL}. RIF должен охватывать базы знаний на OWL как данные настолько, насколько 
они оказываются совместимыми с семантикой RIF.
\item \textit{Данные RDF}. RIF должен охватывать триплеты RDF как данные настолько, насколько они 
оказываются совместимыми с семантикой RIF.
\item \textit{Идентификация диалекта}. Семантика RIF-документа должна однозначно определяться его 
содержимым без привлечения данных извне.
\item \textit{Синтаксис XML}. RIF должен поддерживать синтаксис XML в качестве основного нормативного 
синтаксического представления.
\item \textit{Типы данных XML}. RIF должен поддерживать надлежащий набор скалярных типов данных с 
ассоциированными операциями в соответствии с их определениями в XML Schema part~2 и связанных с 
этим документом спецификациях.
\item \textit{Слияние наборов правил}. RIF должен поддерживать возможность слияния наборов правил.
\item \textit{Идентификация наборов правил}. RIF должен поддерживать возможность идентификации 
наборов правил. 
\end{enumerate}
Подробные описания примеров использования даны в~[39--41].

\section{Краткий обзор основных решений RIF}

Согласно~\cite{7kal}, RIF изначально был ориентирован на обмен правилами, а не на 
создание одного всеобъемлющего языка на правилах. В~противоположность другим 
стандартам Семантического Веба, таким как RDF, OWL и SPARQL, с самого начала было ясно, 
что од\-ним-един\-ст\-вен\-ным языком не удастся охватить все парадигмы на правилах, активно 
используемые для представления знаний и моделирования в сфере бизнеса. Было осознано, 
что даже обмен правилами сам по себе является сверхзадачей. Известные системы на 
правилах попадают в одну из трех широких категорий: системы на языках первого порядка, 
системы логического программирования, системы на активных правилах. Эти сис\-те\-мы 
синтаксически и семантически имеют мало общего. Более того, даже в пределах одной 
парадигмы имеются большие различия между системами. 

Такое разнообразие предопределило подход RIF WG, заключающийся в создании семейства 
языков, называемых диалектами, со строго определенными синтаксисом и семантикой. 
Семейство диалектов RIF должно быть однородным и расширяемым. Однородность 
означает, что диалекты должны впитать в себя как можно больше из существующего 
разнообразия синтаксического и семантического аппарата. Расширяемость означает, что 
при наличии обоснованной мотивации должна быть обеспечена возможность определения 
новых диалектов RIF как синтаксических расширений существующих диалектов, 
содержащих новые элементы с требуемой дополнительной функциональностью. Такие 
новые диалекты RIF, не являясь стандартами вначале, в дальнейшем могут быть 
стандартизованы.

Ввиду требования строгости определений слово <<формат>> в названии RIF звучит 
несколько уничижительно. Фактически RIF предоставляет больше, чем просто формат. 
Однако понятие формата является существенным для понимания способа предполагаемого 
использования RIF. В~конечном счете в качестве среды обмена при помощи RIF между 
различными системами на правилах предлагается XML-формат обмена данными. Основная 
идея обмена правилами при помощи RIF заключается в том, что для различных систем будут 
определены отображения их собственных языков в диалекты RIF и обратно. Такие 
отображения должны сохранять семантику, так что полученные наборы правил могут 
передаваться от одной системы к другой при условии, что эти системы могут общаться друг 
с другом при помощи подходящего диалекта, поддерживаемого обеими системами.

\vspace*{-6pt}
   
   \subsection{Диалекты RIF} %5.1

Работа RIF WG была сосредоточена на двух видах диалектов~--- диалектах, основанных на 
логике, и диалектах на правилах с действиями~\cite{7kal}. Вообще говоря, диалекты, 
основанные на логике, включают языки, использующие логику некоторого вида, такую как 
логика первого порядка (часто ограниченная логикой Хорна) или непервопорядковые 
логики, лежащие в основе различных языков логического программирования (например, 
логического программирования, следующего хорошо обоснованной или стабильной 
семантике). Диалекты на правилах с действиями включают системы на продукционных 
правилах, такие как Jess, Drools и JRules, и системы с реактивными правилами (или 
правилами <<со\-бы\-тие--усло\-вие--дейст\-вие>>), такие как Reaction RuleML и XChange. 
Из-за ограниченности ресурсов RIF WG были определены только два логических 
диалекта~--- базовый логический диалект (RIF-BLD) и его подмножество: диа\-лект-ядро RIF, 
расширяемое также диалектом продукционных правил (RIF-PRD). RIF-PRD~--- это 
единственный диалект на правилах с действиями, определенный RIF WG.

Диалект RIF-BLD соответствует логике Хорна с различными синтаксическими и 
семантическими расширениями\footnote{Расширения языка трактуются следующим 
образом~\cite{25kal}. Пусть $L_1\hm\subseteq L_2$~--- два логических языка, семантика 
которых определена на основе отношений следования (entailment) $\models_1$ и 
$\models_2$. Говорят, что $L_2$ является расширением $L_1$, если для любой пары формул 
$\varphi$, $\psi\hm\in L_1$ следование $\varphi\models_1\psi$ выполняется тогда и только 
тогда, когда выполняется $\varphi\models_2\psi$. Для языков на правилах множество 
правил, которые можно использовать в роли посылок (premises), не совпадает с множеством 
правил, которые можно использовать в качестве следствий (consequents). Поэтому нужно 
предположить, что $L_1=Premises_1 \cup Consequents_1$ и $L_2\hm=Premises_2\cup 
Consequents_2$. Более того, $L_1$ не обязательно должен быть подмножеством $L_2$. Скажем, 
он может включаться в $L_2$ на основе 1-1 трансформаций~$\iota$. В~используемых 
обозначениях это можно выразить как $\iota(Premises_1)\subseteq Premises_2$ и 
$\iota(Consequents_1)\subseteq Consequents_2$. Теперь можно определить, что $L_2$ 
расширяет $L_1$ относительно трансформации~$\iota$, если для каждой пары формул 
$\varphi\hm\in Premises_1$ и $\psi\hm\in Consequents_1$ следование $\varphi\models_1\psi$ 
выполняется тогда и только тогда, когда выполняется $\iota (\varphi)\models_2\iota 
(\psi)$.}. Основные синтаксические расширения включают синтаксис фреймов и предикаты 
с поименованными аргументами. Основные семантические расширения включают типы 
данных и внешне определенные предикаты. Хотя этот диалект не является достаточно 
выразительным для многих применений правил, он охватывает большое число 
существующих систем на правилах, что позволяет считать его необходимой предпосылкой 
создания более выразительных диалектов в будущем. Эту деятельность предполагается 
вести в рамках каркаса расширения RIF, называемого RIF-FLD.

RIF-PRD~--- это другой разработанный RIF WG крупный диалект, охватывающий основные 
аспекты различных систем на продукционных правилах. Серьезный интерес к технологиям 
на продукционных правилах был проявлен крупными компаниями. Продукционные 
правила в соответствии с существующей практикой в системах, подобных Jess или JRules, 
определяются, используя неформальные вычислительные схемы, не основанные на логике. 
Поэтому RIF-PRD не является частью набора логических диалектов RIF. Вместе с тем 
значительное внимание было уделено тому, чтобы выделить максимально возможную 
общую часть продукционного и логических диалектов. Выделение такой общей части 
послужило основанием для создания диа\-лек\-та-яд\-ра RIF.

Предполагается, что существующие и будущие диалекты RIF будут использовать один и тот 
же набор типов данных, встроенных функций и предикатов в соответствии с их 
определением в документе RIF Datatypes and Built-Ins (RIF-DTB).

\vspace*{-6pt}

   \subsection{Каркас RIF для логических диалектов} %5.2

Для упрощения создания новых диалектов и сокращения времени их разработки RIF WG 
определила каркас расширения RIF, называемый каркасом логических диалектов 
(RIF-FLD)~\cite{42kal}. Не исклю\-че\-но появление в будущем аналогичного каркаса правил с 
действиями. RIF-FLD не является собственно диалектом, он определен как универсальный 
каркас для создания новых логических диалектов, расширяющих существующие. Он был 
разработан для существенного упрощения процесса определения и верификации новых 
логических диалектов, расширяющих возможности RIF-BLD.

Разработка каркаса RIF-FLD оказалась возможной, поскольку, несмотря на различия 
логических теорий, составляющих основу различных логических систем на правилах, в них 
используется много общих синтаксических и семантических конструкций. Более того, 
способы образования комбинаций различных подобных конструкций для образования 
соответствующих систем хорошо изучены. Однако спецификация RIF-FLD уникальна, 
поскольку является результатом тщательного разбора этих знаний и представляет их в 
согласованном виде,\linebreak причем XML используется даже на уровне кар\-каса.
{\looseness=1

}

RIF-FLD представляет собой весьма общий логический язык, использующий значительную 
часть широко используемых синтаксических и семантических конструкций: при этом, 
однако, намеренно ряд параметров оставлен неопределенным для того, чтобы 
конструкторы конкретных диалектов могли добавить необходимые детали. Например, 
RIF-FLD предоставляет способ представления правил синтаксиса при помощи понятия 
сигнатур. В нем также можно специфицировать некоторые семантические понятия, такие 
как модели и логическое следование, оставляя при этом открытым выбор конкретных 
вариантов (например, какие конкретно модели следует использовать при рассмотрении 
следования). Конструктор конкретного диалекта может определить его синтаксис и 
семантику заданием их специализации на основе синтаксиса и семантики RIF-FLD. При этом 
конструктор осуществляет возможность выбора параметров из вариантов, 
предоставляемых RIF-FLD, не требуя определения формул, типов данных, моделей, 
следования и пр. Такой подход продемонстрирован на определении RIF-BLD. Этот диалект 
специфицирован двумя способами: прямым пе\-ре\-чис\-ле\-ни\-ем всех определений, что 
потребовало около 40~страниц текста, и заданием спецификации на основе RIF-FLD, что 
потребовало всего пяти страниц. Любое различие между двумя спецификациями следует 
рассматривать как ошибку, подлежащую исправлению. Таким образом, на примере двойной 
спецификации RIF-BLD показаны преимущества определения диалектов с помощью каркаса 
RIF-FLD.

Каркас RIF включает гибкий набор конструкций, достаточных для решения проблем: 
\begin{itemize}
\item формирования диалектов с различной семантикой, включая хорошо обоснованную и стабильную 
семантику;
\item введения правил, имеющих широкий диапазон представлений~--- от хорновских правил до 
универсальных правил с произвольными формулами в голове (таким образом, например, становятся 
представимыми как правила дизъюнктивного Datalog'а, так и GLAV (Global-and-Local-As-View) взгля\-ды);
\item выбора трактовки предположения об уникальности имен (в логическом программировании 
синтаксически разные базовые термы обозначают разные объекты, тогда как в дескриптивных логиках это 
не так);
\item обеспечения возможности использования функций в правилах;
\item использования развитых структур данных на основе фреймов;
\item определения иерархии классов и отношений наследования;
\item введения разнообразных скалярных типов данных (XML Schema).
\end{itemize}

Разработчики каркаса не считают его спецификацию незыблемой. Напротив, при 
необходимости в будущем она может быть изменена и расширена. 

К моменту написания настоящей статьи было известно, что RIF-FLD был использован для 
определения трех логических диалектов: базового логического диалекта (RIF-BLD), 
диа\-лек\-та-яд\-ра средств программирования множества ответов (RIF-CASPD) и диа\-лек\-та-яд\-ра 
логического программирования, базирующегося на хорошо обоснованной семантике 
(RIF-CLPWD). Известно также, что RIF-FLD используется для определения диалекта правил с 
неопределенностью (Uncertainty Logic Dialect, ULD) и диалекта логики умолчания 
(Default Logic Dialect, DLD) как расширения BLD. 
Ведутся также работы по средствам синтаксического контроля текстов программ на 
соответствие различным диалектам, например на соответствие диа\-лек\-ту-яд\-ру RIF.

\vspace*{-6pt}
   
   \subsection{Вопросы совместимости с~RDF и~OWL} %5.3

Признавая необходимость сопряжения правил RIF с RDF и онтологиями OWL, RIF WG 
определила также концепции обеспечения совместимости RIF с RDF и OWL. Учитывая, что 
RIF, RDF и OWL~--- языки с различным синтаксисом и семантикой, следовало определить, 
как из правил RIF ссылаться на факты RDF и OWL, и выяснить, может ли иметь логический 
смысл всеобъемлющий язык. Специальный документ RIF, посвященный совместимости RIF 
с RDF и OWL, дает ответ на эти вопросы. Основная идея заключается в использовании 
синтаксиса фреймов для взаимодействия с RDF/OWL. Фреймы отображаются в триплеты 
RDF и определяется объединенная семантика для такой комбинированной конструкции. 
Обмен правилами посредством RIF может находиться в зависимости от данных RDF, RDF 
Schema или онтологий OWL либо использоваться вместе с ними. Таким образом, требуется 
определить возможность обеспечения интероперабельности RIF с другими стандартами 
Семантического Веба. 

\textit{Гибридный подход к обеспечению интероперабельности правил и 
онтологий}~\cite{25kal}. Требуется создание логической надстройки над стеками OWL и 
правил, которая позволяла бы использовать вывод, реализуемый в OWL в правилах, и, 
наоборот, вывод на основе правил использовать в OWL. Основная идея такого 
взаимодействия заключается в том, что системы на правилах и OWL будут рассматривать 
друг друга как черные ящики с интерфейсом, реализуемым на основе экспортируемых 
предикатов. Онтологии OWL будут экспортировать свои классы и свойства, а базы знаний на 
правилах будут экспортировать некоторые из определенных в них предикатов. Каждая из 
баз знаний будет иметь возможность ссылаться на предикаты в другой базе знаний, причем 
одной из возможных трактовок таких предикатов является их экстенсиональная 
интерпретация как множеств фактов. В~част\-ности, онтологии можно использовать как 
разделяемые многими приложениями концептуализации предметных областей. В~этом 
случае различным приложениям в этой области могут соответствовать специфические 
программы на правилах.

Такой подход, называемый гибридным, обеспечивает возможность интегрированного 
использования существующих машин вывода в системах на правилах и в онтологических 
системах для реализации рассуждений в гибридном языке вместо того, чтобы создавать 
совершенно новую машину вывода~\cite{43kal}.

Можно представить себе два языка~--- язык логического программирования~$R$ и 
онтологический язык~$S$ (последний можно считать базированным на дескриптивной 
логике). Гибридное правило над~$R$ и~$S$ может иметь следующий вид:

\begin{center}
\textit{H}:\;-\ \textit{B}$_1$, \ldots , \textit{B}$_m$, \textit{Q}$_1$, \ldots , \textit{Q}$_n$.
\end{center}

\noindent
Здесь $m, n \hm\geq 0$; \textit{H}, \textit{B}$_i$~--- литералы, а 
\textit{Q}$_j$~--- запросы, представленные на языке 
запросов~\textit{Q}$_S$.

Гибридная база знаний $K = (D, P)$ представляет собой конечное множество $D$ аксиом в 
дескриптивной логике на онтологическом языке~$S$ и конечное множество гибридных 
правил~$P$ над~$R$ и~$S$, включающих атомы не в дескриптивной логике. Оба языка 
поддерживаются машинами вывода, отвечающими на запросы на соответствующем языке 
запросов~\textit{Q}$_R$ и~\textit{Q}$_S$. Язык запросов в гибридной парадигме 
синтаксически совпадает с 
языком запросов~\textit{Q}$_R$. Ответом на запрос является совокупность фактов, которая следует 
из гибридной базы знаний.

\textit{Однородный подход к обеспечению интероперабельности правил и 
онтологий}~\cite{44kal}. В~гибридном подходе обычные предикаты в языке на правилах и 
онтологические предикаты (которые чаще всего выступают в роли ограничений в посылках 
правил) строго разделены. Рассуждения осуществляются на основе сопряжения 
существующих машин вывода системы на правилах и онтологии.

В однородном подходе как онтологии, так и правила выражаются на одном языке~$L$ без 
необходимости установления априорных различий между предикатами на правилах и 
онтологическими предикатами.
   
   \subsection{Сценарии использования RIF совместно с~данными RDF или~онтологиями 
RDFS/OWL} %5.4

Такие сценарии определены следующим образом~\cite{45kal}. Партнер по 
взаимодействию~$A$ использует язык правил, в котором имеются возможности для работы 
с RDF/OWL. Подобные возможности могут включать поддержку доступа к данным RDF, 
использование онтологий RDFS или OWL либо расширение RDF(S)/OWL средствами языка 
правил~$A$. Используя RIF, $A$ посылает партнеру~$B$ свои правила, возможно, 
содержащие ссылки на нужные графы RDF. Партнер~$B$~получает правила и извлекает требуемые 
графы RDF. Правила транслируются во внутренний язык~$B$ и обрабатываются вместе с 
RDF-графами, используя возможности для работы с RDF/OWL машины вывода~$B$ 
(подобные названным выше для партнера~$A$).

Специализацией этого сценария является пуб\-ли\-ка\-ция правил RIF, ссылающихся на 
RDF-гра\-фы (публикация рассматривается как специальный вид взаимодействия <<один 
ко многим>>). Когда партнер~$A$ публикует свои правила в Вебе, может быть несколько 
потребителей, получающих RIF-пра\-ви\-ла и RDF-гра\-фы из Веба, транслирующих 
RIF-пра\-ви\-ла в соответствующие языки правил и обрабатывающих их вместе с 
RDF-гра\-фа\-ми в их собственных машинах вывода.

Другая возможная специализация сценария обме\-на правилами опирается на намерение 
расширения онтологии OWL правилами партнером, осуществляющим публикацию. Партнер 
по взаимодействию $A$ использует язык правил, расширяющий OWL. Партнер~$A$~расщепляет свое 
определение онтологии и правил в раздельные онтологию OWL и документ RIF, пуб\-ли\-ку\-ет 
онтологию OWL и посылает (или пуб\-ли\-ку\-ет) документ RIF, который включает ссылки на 
онтологию OWL. Потребитель правил извлекает и транслирует онтологию OWL и документ 
в комбинированное описание, содержащее онтологию и правила в собственном языке 
правил, рас\-ши\-ря\-ющем OWL.
   
   \subsection{Состояние реализации RIF} %5.5

RIF WG на основании отчетов по реализации RIF представила информацию в виде 
таблицы~\cite{46kal}:

{\footnotesize
\begin{center}
\tabcolsep=2pt
\begin{tabular}{|c|c|c|c|}
\hline
\tabcolsep=0pt\begin{tabular}{c}Система\\ на правилах\end{tabular}&
Организация&Диалект RIF&\tabcolsep=0pt\begin{tabular}{c}Поддержка\\ функций\end{tabular}\\
\hline
SILK&
\tabcolsep=0pt\begin{tabular}{c}Vulcan, BBN,\\ Stony Brook\\ University\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}BLD, DLD\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Producer,\\ consumer\end{tabular}\\
\hline
OntoBroker 5.3&
Ontoprise&BLD (partial)&\tabcolsep=0pt\begin{tabular}{c}Producer,\\ consumer\end{tabular}\\
\hline
Fuxi&\tabcolsep=0pt\begin{tabular}{c}Chimezie\\ Ogbuji\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}RIF Core and\\ OWL 2 RL\\ in RIF\end{tabular}&Producer\\
\hline
\tabcolsep=0pt\begin{tabular}{c}IBM\\ Websphere\\ ILOG JRules\end{tabular}&
IBM/ILOG&PRD\;+\;Core&
\tabcolsep=0pt\begin{tabular}{c}Producer (PRD),\\ consumer\\ (PRD\;+\;Core)\end{tabular}\\
\hline
Eye&Jos De Roo&BLD\;+\;DTB&Consumer\\
\hline
VampirePrime&
\tabcolsep=0pt\begin{tabular}{c}Alexandre\\ Riazanov\end{tabular}&BLD&Consumer\\
\hline
RIFle&
\tabcolsep=0pt\begin{tabular}{c}Jos$\acute{\mbox{e}}$ Maria\\ $\acute{\mbox{A}}$lvarez\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Core,\\ PRD, DTB\end{tabular}&Validator\\
\hline
OBR&Oracle&
\tabcolsep=0pt\begin{tabular}{c}PRD without\\ import\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Producer,\\ consumer\end{tabular}\\
\hline
IRIS&STI Innsbruck&BLD\;+\;DTB&\tabcolsep=0pt\begin{tabular}{c}Producer,\\ consumer\end{tabular}\\
\hline
N/A&\tabcolsep=0pt\begin{tabular}{c}Stijn Heymans,\\ Michael Kifer\end{tabular}&
FLD&\tabcolsep=0pt\begin{tabular}{c}RIF-CASPD\end{tabular}\\
\hline
N/A&\tabcolsep=0pt\begin{tabular}{c}Jidi Zhao,\\ Harold Boley\end{tabular}&
FLD&\tabcolsep=0pt\begin{tabular}{c}RIF-URD\end{tabular}\\
\hline
Riftr&Sandro Hawke&\tabcolsep=0pt\begin{tabular}{c}Core,\\ BLD, DTB,\\ RDF import\end{tabular}&
\tabcolsep=0pt\begin{tabular}{c}Producer,\\ consumer,\\ validator\end{tabular}\\
\hline
\end{tabular}
\end{center}
}

\section{Заключение}

Работа по стандарту унификации языков на прави\-лах, выполненная RIF WG, является 
значительным событием. Предложен тщательно обоснованный и формализованный подход 
к созданию семейства диалектов языков на правилах, позволяющий однородно представить 
многообразие су\-ще\-ст\-ву\-ющих языков на правилах. Для логических языков на правилах 
определен каркас конструирования различных диалектов, позволяющих 
создавать взаимные сохраняющие семантику отображения различных логических языков 
су\-ще\-ст\-ву\-ющих сис\-тем на правилах в такие диалекты. Такие отображения являются 
необходимой предпосылкой обеспечения интероперабельности и повторного 
использования логических программ. Новый диалект создается как расширение 
существующих диалектов, управляемое каркасом.

Впервые работа по унификации языков программирования выполняется как задача 
крупного консорциума. Само по себе осознание необходимости подобной работы таким 
разнородным сообществом, как W3C, уже является знаменательным событием.

Важным достижением является также выделение общего ядра для языков на правилах с 
совершенно различной парадигмой~--- логических и продукционных языков. Определение 
логического и продукционного диалектов как расширений ядра (первое из которых 
удовлетворяет каркасу) служит необходимой предпосылкой начала реализации RIF. 
Создание каркаса для совокупности продукционных языков~--- одна из задач развития RIF.

В результате выполненной RIF WG работы становится возможным рассмотрение программ 
на правилах как особого вида информационных ресурсов, которые могут быть 
использованы в различных средах интеграции и интероперабельного использования 
ресурсов (например, в средах поддержки предметных посредников). Благодаря высокому 
уровню абстракции и декларативности программ на правилах становится практически 
достижимой точная спецификация поведения предметных посредников (тогда как до сих 
пор при спецификации поведения на этом сугубо декларативном уровне приходилось 
ограничиваться спецификацией пред- и постусловий). В~част\-ности, применение 
различных моделей логических рассуждений становится реально возможным при решении 
задач с использованием множества неоднородных распределенных информационных 
ресурсов.

{\small\frenchspacing
{%\baselineskip=10.8pt
\addcontentsline{toc}{section}{Литература}
\begin{thebibliography}{99}

\bibitem{1kal}
\Au{Kalinichenko L.\,A.}
Methods and tools for equivalent data model mapping construction~// 
Advances in Database Technology:  
Conference (International) on Extending Database Technology EDBT'90 Proceedings, LNCS 416.~--- 
Berlin--Heidelberg: Springer-Verlag, 1990. P.~92--119.

\bibitem{2kal}
\Au{Kalinichenko L.\,A.}
SYNTHESIS: The language for desсription, design and programming of the heterogeneous interoperable 
information resource environment.~--- 2nd ed.~--- Moscow: IPI RAN, 
1993. 110~p.

\bibitem{3kal}
\Au{Kalinichenko L.\,A., Stupnikov S.\,A., Martynov~D.\,O.}
SYNTHESIS: A language for canonical information modeling and mediator definition for problem solving in 
heterogeneous information resource environments.~--- 4th ed.~--- 
Moscow: IPI RAN, 2007. 171~p.

\bibitem{4kal}
\Au{Захаров В.\,Н., Калиниченко Л.\,А., Соколов~И.\,А., Ступников~С.\,А.}
Конструирование канонических информационных моделей для интегрированных информационных 
систем~// Информатика и её применения, 2007. Т.~1. Вып.~2. С.~13--38.

\bibitem{5kal}
\Au{Abrial J.\,R.}
The B-Book~--- assigning programs to meanings.~--- Cambridge: Cambridge University Press, 1996.

\bibitem{6kal}
\Au{Kifer M.}
Rule interchange format: The framework~// Web Reasoning and Rule Systems:  2nd Conference (International) 
Proceedings, LNCS 5348.~--- Berlin--Heidelberg: Springer Verlag, 2008. P.~1--11.

\bibitem{7kal}
RIF Overview~// W3C Working Draft. {\sf http:// www.w3.org/TR/2010/WD-rif-overview-20100511}.

\bibitem{8kal}
List of rule systems. {\sf http://www.w3.org/2005/rules/ wg/wiki/List\_of\_Rule\_Systems.html}.

\bibitem{9kal}
RIF Working Group Web Page. {\sf http://www.w3.org/ 2005/rules/wiki/RIF\_Working\_Group}.

\bibitem{20kal} %10
\Au{Reiter R.}
A~logic for default reasoning~// Artificial Intelligence, 1980. Vol.~13. P.~81--132.

\bibitem{13kal} %11
\Au{Gallaire H., Minker J., Nicolas J.}
Logic and databases: A~deductive approach~// ACM Computing Surveys, 1984. P.~153--185.

\bibitem{16kal} %12
\Au{Bidoit N., Froidevaux C.}
Minimalism subsumes default logic and circumscription~// LICS-87 Proceedings, 1987. P.~89--97.

\bibitem{24kal} %13
\Au{Gelfond M.} On stratified autoepistemic theories~// AAAI-87 Proceedings, 1987. P.~207--211.

\bibitem{14kal} %14
\Au{Apt K.\,R., Blair H.\,A., Walker A.}
Towards a theory of declarative knowledge~// Foundations of deductive databases and logic programming.~--- 
Los Altos, CA: Morgan Kaufmann Publs., 1988. P.~89--148.

\bibitem{19kal} %15
\Au{Gelfond M., Lifschitz V.}
The stable model semantics for logic programming~// 5th Conference (International) on Logic Programming 
(ICLP) Proceedings.~--- 1988. P.~1070--1080.

\bibitem{17kal} %16
\Au{Besnard P.} An introduction to default logic.~--- Springer Verlag, 1989. 

\bibitem{21kal} %17
\Au{Gelfond M., Lifschitz V.}
Classical negation in logic programs and disjunctive databases~// New Generation Computing, 1991. Vol.~9. 
P.~365--385.

\bibitem{23kal} %18
\Au{Marek W., Truszczy$\acute{\mbox{n}}$ski M.}
Autoepistemic logic~// J.~ACM, 1991. Vol.~38. No.\,3. P.~587--618.

\bibitem{12kal} %19
\Au{Ramakrishnan R., Ullman J.}
A~survey of research on Deductive Database Systems: Technical report.~--- Stanford University, 1993.

\bibitem{11kal} %20
\Au{Minker J.} Logic and databases: A 20 year retrospective~// LNCS 1154.~--- Springer-Verlag, 1996.

\bibitem{22kal} %21
\Au{Baral C.}
Answer set programming: knowledge representation, reasoning and declarative problem solving using 
AnsProlog.~--- 2004. {\sf http://www.public.asu.edu/ $\sim$cbaral/tutorial-dallas-june-04.pdf}.


\bibitem{10kal} %22
\Au{Kowalski R.}
Reasoning with conditionals in artificial intelligence.~--- Department of Computing, Imperial College London, 
2009. {\sf http:// www.doc.ic.ac.uk/$\sim$rak/papers/conditionals.pdf}. 

\bibitem{18kal} %23
\Au{Wan H., Grosof B., Kifer M., \textit{et al}.}
Logic programming with defaults and argumentation theories~// Logic Programming, LNCS 564, 2009. 
P.~432--448.

\bibitem{15kal} %24
Abduction. {\sf http://iph.ras.ru/page54852159.htm}.



\bibitem{25kal} %25
\Au{Kifer M., de Bruijn J., Boley H., Fensel~D.}
A realistic architecture for the semantic web~//  1st Conference (International) on Rules and Rule Markup 
Languages for the Semantic Web (RuleML2005) Proceedings, LNCS 3791.~--- Springer-Verlag, 2005. P.~17--29.

\bibitem{26kal}
\Au{Van Gelder A., Ross K.\,A., Schlipf J.\,S.}
The well-founded semantics for general logic programs~// J.~ACM, 1991. Vol.~38. No.\,3. P.~620--650.

\bibitem{27kal}
\Au{Pearce D.}
A~new logical characterization of stable models and answer sets~// Non-monotonic extensions of logic 
programming: Lecture notes in artificial intelligence 1216.~--- Springer, 1997. P.~57--70.

\bibitem{28kal}
\Au{Eiter T., Ianni G., Krennwallner T.}
Answer set programming: A primer~// 5th International Reasoning Web Summer School 2009 Proceedings, 
LNCS 5689.~--- Springer-Verlag, 2009.

\bibitem{29kal}
\Au{Moore R.\,C.}
Semantical considerations on nonmonotonic logic~// Artificial Intelligence, 1985. Vol.~25. P.~75--94.

\bibitem{30kal}
\Au{Marek W., Truszczynski M.} Stable models and an alternative logic programming paradigm~// The logic 
programming paradigm: 25~year perspective.~--- Springer Verlag, 1999. P.~375--398.

\bibitem{31kal}
\Au{Niemel$\ddot{\mbox{a}}$~I., Simons P., Soininen~T.}
Stable model semantics of weight constraint rules~//  
5th Conference (International) on Logic Programming and 
Nonmonotonic Reasoning Proceedings.~--- Springer-Verlag, 1999.

\bibitem{32kal}
\Au{Lifschitz V.}
What is answer set programming?~// 23rd National Conference on Artificial Intelligence Proceedings.~--- AAAI 
Press, 2008. Vol.~3. P.~1594--1597.

\bibitem{33kal}
System DLV. {\sf http://www.dbai.tuwien.ac.at/proj/dlv}.

\bibitem{34kal}
\Au{Kifer M.} Nonmonotonic reasoning in FLORA-2~// Logic Programming and Nonmonotonic Reasoning, 
LNCS 3662.~--- Springer-Verlag, 2005. P.~1--12.

\bibitem{35kal}
\Au{Kifer M., Lausen G., Wu~J.}
Logical foundations of object-oriented and frame-based languages~// J.~ACM.~--- N.Y.: ACM New York, 
1995. Vol.~42. Iss.~4. P.~741--843.

\bibitem{36kal}
\Au{Lud$\ddot{\mbox{a}}$scher B., Himmer$\ddot{\mbox{o}}$der R., Lausen~G., May~W., Schlepphorst~C.}
Managing semistructured data with Florid: A~deductive object-oriented perspective~// 
Information systems.~--- 
Elsevier, 1998. Vol.~23. Iss.~8. P.~589--613.

\bibitem{37kal}
\Au{Yang G., Kifer M., Wan H., Zhao C.}
FLORA-2: User's\linebreak
 manual, 2008. {\sf http://flora.sourceforge.net/docs/\linebreak floraManual.pdf}. 

\bibitem{38kal}
\Au{Boley H., Kifer M., Patranjan P.-L., Polleres~A.}
Rule interchange on the Web reasoning~// Web 2007, LNCS 4636.~--- Springer-Verlag, 2007. P.~269--309.

\bibitem{39kal}
RIF Use Cases. {\sf http://www.w3.org/2005/rules/wg/\linebreak wiki/Use\_Cases.html}.

\bibitem{40kal}
General use case categories. {\sf http://www.w3.org/2005/ rules/wg/wiki/General\_Use\_Case\_Categories}.

\bibitem{41kal}
RIF Use Cases and Requirements~// W3C Working Draft, 2008. {\sf http://www.w3.org/TR/rif-ucr}.

\bibitem{42kal}
RIF Framework for logic dialects~// W3C Proposed recommendation~/ Eds. H.~Boley, M.~Kifer.~--- 2010. {\sf 
http://www.w3.org/TR/2010/PR-rif-fld-20100511}.

\bibitem{43kal}
\Au{Grosof B.\,N., Horrocks I., Volz R., Decker~S.}
Description logic programs: Combining logic programs with description logic~// 
WWW2003 Proceedings, 2003.

\bibitem{44kal}
\Au{Antoniou G., Damasio C.\,V., Grosof~B., \textit{et al}.}
Combining rules and ontologies. A survey. Project REWERSE Report, 2005.

\bibitem{45kal}
Implementations~--- RIF. {\sf http://www.w3.org/2005/ rules/wiki/Implementations}.

\label{end\stat}

\bibitem{46kal}
RIF RDF and OWL Compatibility~// W3C Candidate recommendation.~--- 2009. {\sf 
http://www.w3.org/ TR/2009/CR-rif-rdf-owl-20091001}.

 \end{thebibliography}
}
}


\end{multicols}