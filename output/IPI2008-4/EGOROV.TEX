\def\stat{egorov}

\def\tit{РЕГИОНЫ ВРЕМЕНИ КАК ОБЪЕКТЫ ОПЕРАЦИОННОЙ СИСТЕМЫ ОБЩЕГО
НАЗНАЧЕНИЯ}
\def\titkol{Регионы времени как объекты операционной системы общего
назначения}

\def\autkol{В.\,Ю.~Егоров, Е.\,А.~Матвеев}
\def\aut{В.\,Ю.~Егоров$^1$, Е.\,А.~Матвеев$^2$}

\titel{\tit}{\aut}{\autkol}{\titkol}

%{\renewcommand{\thefootnote}{\fnsymbol{footnote}}\footnotetext[1]
%{Работа выполнена при поддержке
%Российского фонда фундаментальных исследований,
%гранты 06-07-89056 и 08-07-00152.}}

\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{Пензенский государственный университет; ООО Научно-техническое предприятие
<<Криптософт>>, vec@cryptosoft.ru}
\footnotetext[2]{ООО Научно-техническое предприятие <<Криптософт>>, eugene@cryptosoft.ru}

\Abst{В статье предлагается ввести в состав операционных систем общего назначения новый
тип объекта~--- <<регион времени>>, который позволяет придать им свойства операционных
систем реального времени.}

\KW{операционная система; реальное время; регион времени; расширение языка Си;
аппаратный контроллер прерываний; многопроцессорная система}

      \vskip 36pt plus 9pt minus 6pt

      \thispagestyle{headings}

      \begin{multicols}{2}

      \label{st\stat}

\section{Введение}

     В настоящее время все операционные сис\-те\-мы принято делить на два больших класса:
операционные системы общего назначения (называемые также универсальными) и 
операционные %\linebreak 
сис\-те\-мы специ\-аль\-но\-го назначения. В состав класса 
операционных сис\-тем специального назначения отдельным пунктом входят 
операционные системы реального времени. В данной статье предлагается подход, 
позволяющий придать универсальной операционной системе черты системы реального 
времени.

   Реализация подсистемы реального времени в ядре операционной системы общего назначения
возможна, если в состав типов объектов операционной системы ввести особый тип объекта:
<<регион времени>>. Данный тип объекта характеризует учас\-ток кода программы, который
должен быть выполнен за определенное время.

   Регионы времени задаются границами, определяющими действие региона. Начальные границы
регионов во времени и в коде совпадают. Реакция системы на исполнение региона времени
зависит от того, какая из конечных границ региона будет достигнута раньше: граница во времени
или граница в коде. Если первой будет достигнута конечная граница региона в коде, то
выполнение последующего кода будет продолжено без какой-либо реакции от подсистемы
реального времени. Если первой будет достигнута конечная граница региона во времени, то
подсистема реального времени прерывает нормальную последовательность выполнения команд и
управление передается в ветвь, отвечающую за обработку состояния истечения времени
   (тайм-аута).

   Регионы времени обладают следующими характеристиками:
   \begin{itemize}
\item начало региона во времени;
\item конец региона во времени;
\item начало региона в коде системы;
\item конец региона в коде системы.
   \end{itemize}

   В качестве временн$\acute{\mbox{ы}}$х характеристик региона времени может быть выбрано либо абсолютное,
либо относительное время. Относительное время считается от текущей точки во времени.
Относительное время можно также привязать ко времени работы текущего процесса (нити) либо
ко времени работы всей системы. Характеристики региона времени иллюстрируются на
рис.~\ref{f1eg}.

   Изменение порядка следования команд при достижении конечной границы региона во времени
характеризуется двумя параметрами:
   \begin{enumerate}[(1)]
\item временем, в течение которого система определяет, что произошел тайм-аут, так
называемое <<время отсечки>>;
\item временем, которое система тратит на изменение порядка следования команд, так
на\-зы\-ва\-емое <<время переключения>>.
   \end{enumerate}

   После того как исполнение кода программы вошло в регион времени, диспетчер задач
операционной системы общего назначения начинает работать как диспетчер задач операционной
системы реального времени. Реализация объектов регионов времени требует изменения в
подходах к проектированию большого числа компонентов ядра операционной системы.

   Авторам исследования не удалось обнаружить в литературе и сети Интернет упоминаний о
пред\-став\-ле\-нии регионов времени в виде объектов операционной системы общего назначения.

\begin{figure*} %fig1
\vspace*{1pt}
\begin{center}
\mbox{%
\epsfxsize=110.522mm
\epsfbox{ego-1.eps}
}
\end{center}
\vspace*{-9pt}
\Caption{Понятия регионов времени
   \label{f1eg}}
   \end{figure*}

Одной из особенностей высокоточного таймера является использование его в режиме
од\-но\-крат\-ного программирования~--- на каждый регион време\-ни таймер программируется заново.
Про\-грам\-ми\-ро\-ва\-ние высокоточного таймера на пе\-ри\-оди\-ческое %\linebreak 
сраба\-ты\-ва\-ние при
программировании регионов времени просто не требуется. В отличие от вы\-со\-ко\-точ\-но\-го таймера
стандартный системный таймер должен функционировать в периодическом режиме, поскольку на
него возлагается обязанность актуализации системного времени.

   Длительность времени переключения при возникновении тайм-аута зависит от характеристик
операционной системы. Одной из важнейших характеристик является понятие аппаратного
приоритета~--- IRQL (Interrupt Request Level)~\cite{3eg}. IRQL представляет собой целое
беззнаковое число в интервале от 0 (PASSIVE\_LEVEL) до HIGH\_LEVEL. В зависимости от вида
операционной системы HIGH\_LEVEL может различаться. Однако аппаратные прерывания могут
происходить только до значения MAX\_DEVICE. Это значение определяется контроллером
прерываний и равно~15.

   Современные аппаратные средства в составе компьютера предоставляют возможность
аппаратной поддержки для реализации диспетчера задач операционной системы. В основном это
касается механизмов обслуживания прерываний. Все современные компьютеры, работающие на
платформе IA-32, имеют в своем составе расширенный контроллер прерываний~--- APIC
(Advanced Programmable Interrupt Controller)~\cite{8eg}.

  
   

   Контроллер APIC состоит из двух частей (рис.~2). Одна~--- в составе центрального
процессора, называемая LocalApic~\cite{6eg, 7eg}, вторая~--- в составе одной из микросхем
материнской платы компьютера, называемая IoApic~\cite{8eg, 9eg}. И LocalApic, и IoApic могут
присутствовать в системе в нескольких экземплярах~\cite{10eg}. Каждый IoApic имеет в своем
составе некоторое число линий (обычно~24), используемых как входы прерываний аппаратных
устройств. Если объединить несколько IoApic, то можно значительно увеличить число входов. В
современных серверах имеется более пятидесяти линий для подключения\linebreak

%\begin{figure*} %fig2
\begin{center}
%\vspace*{6pt}
\mbox{%
\epsfxsize=77.838mm
\epsfbox{ego-2.eps}
}
\end{center}
\vspace*{1pt}
%\Caption{
{{\figurename~2}\ \ \small{Организация расширенного контроллера прерываний}}
%\label{f1s}}
%\end{figure*}
%\bigskip
\addtocounter{figure}{1}  


\noindent
сигналов прерываний от
аппаратных устройств. Таким способом достигается расширение числа аппаратных прерываний от
подключаемых устройств.


   Отличительной особенностью контроллера является то обстоятельство, что понятие IRQL в
нем введено аппаратно. Такая организация позволяет обрабатывать прерывания значительно
быст\-рее. При возникновении сигнала прерывания контроллер APIC переключает процессор на
обработку прерывания и аппаратно повышает IRQL до уровня, заданного при установке
обработчика на прерывание. После этого могут возникнуть только прерывания, уровень IRQL
которых выше, чем текущий. Те сигналы прерываний, чей IRQL ниже или равен текущему,
остаются ожидать понижения IRQL, выполняемого операционной системой по завершении
обработчика прерывания.

   Благодаря APIC сводится к минимуму скорость реакции системы на возникновение
прерываний. Это имеет очень большое значение при реализации регионов времени, так как
уменьшает время переключения задачи на обработчик истечения вре\-мени.

\section{Зависимость регионов времени от аппаратного приоритета}



   
   Необходимо обратить особое внимание на использование регионов времени при различных
уровнях аппаратного приоритета (IRQL). По результатам проведения исследований было
выяснено, что функционирование регионов времени возможно на любых IRQL вплоть до
MAX\_DEVICE, т.\,е.\ до максимального уровня аппаратного прерывания компьютера. Однако
для этого, во-первых, необходима дополнительная поддержка со стороны операционной системы,
а во-вторых, при работе с регионами времени требуется соблюдать сле\-ду\-ющее правило: уровень
аппаратного приоритета не должен понижаться в течение выполнения всего региона времени.
Несоблюдение правила должно отслеживаться и непременно приводить к особой системной
ошибке: <<понижение IRQL в течение региона времени>>. Работа операционной системы после
возникновения такой ошибки должна прекращаться. Принцип функционирования региона
времени на высоких уровнях IRQL иллюстрируется на рис.~3.

   Если допустить возможность понижения IRQL в процессе выполнения региона времени, то
диспетчер задач операционной системы может переключить контекст нити. При этом, во-первых,
возрастет длительность выполнения региона времени, а во-вторых, и как следствие первого, может
возникнуть тайм-аут. Возникновение тайм-аута приведет к обработке истечения времени, которая
может быть произведена уже в контексте другой нити, что недопустимо.


   Алгоритм действий, выполняемых операционной системой при старте региона времени,
сле\-ду\-ющий:
   \begin{enumerate}[1.]
\item Запомнить адрес, куда будет передаваться управ\-ле\-ние после возникновения и
обработки тайм-аута.
\item Запомнить текущий уровень IRQL.
\item Вычислить абсолютное время возникновения ситуации тайм-аута.
\item Запрограммировать таймер на ближайшее по времени срабатывание тайм-аута для
списка всех текущих регионов времени.
\end{enumerate}

   При возникновении тайм-аута алгоритм дейст\-вий будет сле\-ду\-ющим:
   \begin{enumerate}[1.]
\item Получить значение текущего IRQL.
\item Если текущий IRQL равен IRQL региона времени и он выше или равен
DISPATCH\_LEVEL, то сразу перейти к обработчику истечения времени.
\item Если текущий IRQL равен IRQL региона времени и он ниже DISPATCH\_LEVEL, то
произвести переключение контекста на нить региона времени и затем перейти к
обработчику истечения времени.
\item Если текущий IRQL выше, чем IRQL региона времени, то выставить особое
прерывание в контроллере прерываний с IRQL, равным IRQL региона времени, по
которому управление получит обработчик истечения времени.
\end{enumerate}

%fig3   
\begin{center}
\vspace*{6pt}
\mbox{%
\epsfxsize=76.392mm
\epsfbox{ego-3.eps}
}
\end{center}
\vspace*{1pt}
%\Caption{
{{\figurename~3}\ \ \small{Использование регионов времени на высоких IRQL}}
%\label{f1s}}
%\end{figure*}
%\bigskip
\addtocounter{figure}{1}  

   Отсечка по тайм-ауту должна при этом всегда срабатывать на максимально высоком уровне
аппаратного приоритета, т.\,е.\ вне зависимости от наличия ждущих обработки аппаратных
прерываний.

   При использовании представленного выше алгоритма работы с регионами времени можно
регулировать <<жесткость>> реального времени системы. Таким образом, работа с регионом времени на
\mbox{PASSIVE\_LEVEL} будет, по сути, представлять собой улучшенный вариант программируемого
таймера. Работа с регионом времени на APC\_LEVEL и DISPATCH\_LEVEL будет
соответствовать системам мягкого реального времени, т.\,е.\ таким системам, где допускается
возникновение тайм-аута. Работа с регионом времени на MAX\_DEVICE будет соответствовать
жесткому реальному времени такому, которое обычно используется в специализированных
операционных системах. Работа региона времени на уровнях IRQL, промежуточных между
\mbox{PASSIVE\_LEVEL} и MAX\_DEVICE, будет представлять собой градации характеристики
реального времени от более мягкого к более жесткому.

   Длительность времени переключения системы на обработчик истечения времени при
IRQL\;=\;PASSIVE\_LEVEL определяется общей загруженностью процессора (процессоров)
системы. Обработчик истечения времени получит управление после того, как закончат работу все
прерывания, возникшие в текущий момент времени, а также нити, имеющие более высокий
приоритет.

   Длительность времени переключения системы на обработчик истечения времени при
IRQL\;=\;MAX\_DEVICE будет равна длительности времени отсечки плюс несколько десятков
тактов процессора на передачу управления обработчику истечения времени.

\section{Вложенность регионов времени} %3

   Абстракция регионов времени вполне допускает возможность вложенности одного региона
времени в другой и даже их пересечения. Вложенность регионов времени представляет собой
вложенность как участков кода, так и интервалов времени одного региона в другой. Пересечение
регионов пред\-став\-ля\-ет собой ситуацию, когда один регион времени стартует раньше другого, но и
завершается раньше во времени. Если при этом конечная точка кода первого региона также
находится до конечной точки второго региона, то такую ситуацию будем называть \textit{перекрестком
регионов}. Сказанное иллюстрируется на рис.~4.



Реализация перекрестка регионов на практике вполне осуществима. Однако если в данном
случае 
%fig4
\begin{center}
\vspace*{6pt}
\mbox{%
\epsfxsize=73.479mm
\epsfbox{ego-4.eps}
}
\end{center}
\vspace*{1pt}
%\Caption{
{{\figurename~4}\ \ \small{Иллюстрация одновременного действия двух регионов времени}}
%\label{f1s}}
%\end{figure*}
\bigskip
\addtocounter{figure}{1}  


\noindent
возникает срабатывание обоих регионов времени по тайм-ауту, то перекрестный участок
кода будет выполнен как минимум дважды: один раз при срабатывании по тайм-ауту первого
региона во времени, а второй раз при срабатывании по тайм-ауту второго региона времени. В
худшем случае в коде перекрестка возникнет временная петля (часто описываемая фантастами),
когда процессор будет вынужден бесконечно выполнять один и тот же участок кода. Поэтому от
практической реализации перекрестка регионов времени было решено отказаться.

Ниже описана реализация регионов времени с использованием расширений
языка программирования Си, которая полностью исключает возможность создания перекрестка
регионов времени, но при этом допускает возможность их вложения.

\section{Организация списка регионов времени} %4

   В процессе работы операционной системы вполне возможна ситуация, при которой своей
очереди на срабатывание дожидаются одновременно несколько регионов времени. Необходимо
рас\-смот\-реть вопрос, как именно должна быть организована в памяти последовательность регионов
времени. Решение данной задачи возможно следующими способами:
   \begin{enumerate}[(1)]
\item привязка регионов времени к нити, для которой они предназначены;
\item привязка регионов времени к системному таймеру.
\end{enumerate}

   В первом способе при возникновении прерывания таймера следует просмотреть все нити,
содержащие в себе регионы времени, и в случае истече-\linebreak\vspace*{-12pt}
\pagebreak
%\begin{figure*} %fig5
\vspace*{6pt}
\begin{center}
\mbox{%
\epsfxsize=42.832mm
\epsfbox{ego-5.eps}
}
\end{center}
\vspace*{1pt}
{{\figurename~5}\ \ \small{Организация списка регионов времени}}
%\label{f1s}}
%\end{figure*}
\bigskip
\addtocounter{figure}{1}  


\noindent
ния тайм-аута произвести отсечку региона
времени. Во втором способе формируется единый список регионов времени. Этот список должен
быть отсортирован по времени срабатывания. При возникновении прерывания таймера система
начинает последовательный просмотр регионов времени с самого раннего времени срабатывания.
Для всех сработавших регионов времени производится отсечка. Как только в списке встречается
еще не сработавший регион времени, просмотр заканчивается. Данный алгоритм иллюстрирует
рис.~5.

\begin{figure*} %fig6
\vspace*{1pt}
\begin{center}
\mbox{%
\epsfxsize=151.582mm
\epsfbox{ego-6.eps}
}
\end{center}
\vspace*{-9pt}
\Caption{Вложенность регионов времени в составе цикла
   \label{f6eg}}
   \vspace*{4pt}
   \end{figure*}
   
   Первый способ организации регионов времени не требует предварительной сортировки, и
потому предпочтительнее, когда число регионов времени невелико. В случае большого количества
регионов времени более предпочтительным следует признать второй способ. При создании
региона времени сортировка в этом случае сводится к поиску места для вновь созданного региона.
При срабатывании таймера отсутствие необходимости просмотра всего списка даст весомый
выигрыш во времени.

%\vspace*{-12pt}
\section{Уничтожение погрешности измерения времени во~вложенных
регионах времени} %5
%\vspace*{-12pt}

   Рассмотрим ситуацию, когда в одном длительном регионе времени (назовем его регионом~1)
исполняется цикл. В каждой итерации цикла заводится другой регион времени малой
длительности, который назовем регионом времени~2, так, как это показано ниже.

\medskip
\noindent
{\small
{\sf $\langle$Старт региона 1 в коде программы$\rangle$}\\
{\sf for (dwIndex=0; dwIndex\;$<$\;4; ++dwIndex)}\\
\{  \\
 \hspace*{5mm}\textsf{$\langle$Старт региона 2 в коде программы$\rangle$}\\
    \hspace*{5mm}\ldots\\
    \hspace*{5mm}{\sf $\langle$Конец региона 2 в коде программы$\rangle$}\\
\}\\
{\sf $\langle$Конец региона 1 в коде программы$\rangle$}\\
 }

   В результате выполнения программы во времени образуется последовательность регионов
времени, показанная на рис.~\ref{f6eg}.



   Для программирования регионов времени используется высокоточный таймер в составе
LocalApic процессора. Как уже отмечалось, высокоточный таймер в составе процессора один, и
его каждый раз требуется программировать однократно для каждого вложенного региона времени.
Это создает ситуацию, когда таймер должен будет программироваться на регион времени~2 в
начале каж\-дой итерации цикла и на регион времени~1 в конце итерации. Таким образом, на
регион времени~1 таймер будет программироваться 5~раз. Всего число программирований
таймера на регион времени~1 зависит от числа итераций цикла:
   \begin{multline*}
   \langle\mathrm{число\ программирований\ региона\ 1}\rangle ={}\\
   {}= \langle\mathrm{число\
итераций}\rangle + 1\,.
   \end{multline*}

   Иллюстрация числа программирований таймера приведена на рис.~\ref{f7eg}.

\begin{figure*} %fig7
\vspace*{1pt}
\begin{center}
\mbox{%
\epsfxsize=151.583mm
\epsfbox{ego-7.eps}
}
\end{center}
\vspace*{-9pt}
\Caption{Последовательность программирования таймера на регионы времени
   \label{f7eg}}
   \vspace*{4pt}
   \end{figure*}

   При задании региона времени для программиста удобнее всего задавать его длительность.
Программирование таймера также требует задания \mbox{интервала} времени. Однако, как показывает
вышеприведенный пример, если каждый раз при программировании таймера на регион времени~1
вычислять оставшуюся длительность региона путем вычитания уже прошедшего времени, то в
результате для региона~1 будет накапливаться систематическая погрешность вычисления
оставшегося времени. Каждое программирование таймера также занимает определенный интервал
времени, поэтому при большом числе итераций цикла систематическая погрешность сильно
возрастает.

   Выход из данной ситуации заключается в вы\-чис\-ле\-нии не длительности региона времени, а
конечной точки во времени, в которой регион времени должен завершиться. Эта конечная точка
во времени должна быть вычислена уже на этапе старта региона времени. При каждом
программировании таймера необходимо получить разность между временем истечения региона и
текущим временем. Эта разность и будет определять время, на которое следует программировать
таймер LocalApic.

   Однако данный способ также не лишен недостатков. Системное время в операционной системе
вычисляется с помощью стандартного таймера компьютера (аналога микросхемы~8253), который,
как известно, имеет весьма низкую точность. Тактовая частота системного таймера равна
1,193181~МГц~\cite{5eg}. Это означает, что погрешность измерения времени таймером составляет
800~нс. Это уже достаточно большая величина, чтобы нивелировать все преимущества
высокоточного таймера LocalApic. При этом в современных операционных системах счетчик
времени инкрементируется не с приведенной частотой, а по возникновению прерывания. В ОС
Windows, например, такое прерывание возникает примерно каждые 10~мс, и погрешность
системного времени также составляет 10~мс~\cite{4eg}. Конечно, такая точность измерения
времени неприемлема для подсистемы реального времени.

   Выход из ситуации возможен с использованием счетчика тактов процессора. Такой счетчик
(Time Stamp Counter~--- TSC) содержится в каждом процессоре, начиная с процессоров Intel
Pentium. Расширенный контроллер прерываний в составе процессоров появился позже,
следовательно, в каждом процессоре, где есть расширенный контроллер прерываний, имеется
также и счетчик тактов.

   Счетчик тактов представляет собой 64-битный регистр, значение которого монотонно
возрастает с каждым тактом частоты процессора. Для процессора с тактовой частотой 2~ГГц
погрешность измерения времени счетчиком тактов составляет~0,5~нс. Такой точности измерения
времени более чем достаточно даже для систем жесткого реального времени.

   Для того чтобы таймер LocalApic и счетчик тактов процессора можно было использовать для
измерения времени, необходимо произвести их ка\-либ\-ров\-ку. Единственным источником в
компьютере с известной тактовой частотой является стандартный системный таймер. С его
помощью необходимо производить калибровку частоты процессора и частоты системной шины
при инициализации операционной системы.

   При старте региона времени необходимо получить текущее значение счетчика тактовой
частоты, перевести длительность интервала времени в число тактов процессора и вычислить
значение счетчика тактов процессора при завершении региона времени. Это значение и будет
храниться в системе в течение действия региона времени. Алгоритм программирования таймера
LocalApic в данном случае будет выглядеть следующим образом:
   \begin{enumerate}[1.]
\item Получить текущее значение счетчика тактов процессора.
\item Вычислить разницу между конечным значением счетчика тактов и его текущим
значением.
\item Выполнить перевод количества тактов процессора в количество тактов таймера
LocalApic.
\item Запрограммировать таймер LocalApic.
   \end{enumerate}

Приведенный алгоритм позволяет уменьшить погрешность измерения времени до погрешности
таймера LocalApic. При частоте системной шины 200 МГц погрешность составит всего 5~нс.
Такой способ также полностью исключает систематическую погрешность при наличии вложенных
регионов времени.

\section{Реализация регионов времени на многопроцессорной системе}

   При наличии в составе аппаратной платформы нескольких процессоров или процессорных
ядер задача управления регионами времени усложняется. В данной статье будет рассматриваться
только случай симметричной многопроцессорной схемы SMP (Symmetric Multiprocessor) c
однородным доступом к памяти UMA (Uniform Memory Access)~\cite{1eg}. Такая структура
используется в настоящий момент в многоядерных и многопроцессорных вычислительных
системах от компаний Intel и AMD.

   Наличие многопроцессорной архитектуры предо\-став\-ля\-ет дополнительные преимущества, но и
вносит дополнительные сложности в реализацию регионов времени. С одной стороны, наличие
несколь\-ких процессоров позволяет одновременно выполнять код нескольких регионов времени. 
С~другой стороны, при использовании нескольких процессоров в системе возникают специфические
задержки, связанные с синхронизацией процессоров.


   B SMP-системах все процессоры имеют равные права на доступ к памяти. Память системы
общая для всех процессоров, и изменение одним из процессоров одной ячейки памяти приводит к
ее изменению на всех процессорах в системе. Данный механизм реализован аппаратно. Однако в
процессорах имеются данные, которые не обновляются аппаратно. К ним относится содержимое
регистра CR3, который хранит адрес таблицы страниц текущего процесса. Перезаписывание
регистра CR3 приводит к сбросу буферов TLB (Translation Lookaside Buffer~--- буфер быстрого преобразования адреса) процессора. Если два процессора в системе
выполняют код одного и того же процесса, то при изменении таблицы страниц в одном из
процессоров необходимо также изменять таблицу страниц другого процессора в системе.

   Для выполнения данной операции процессоры в многопроцессорной системе время от времени
приходится синхронизировать. На практике это выражается в том, что по команде от одного из
процессоров нормальная последовательность выполнения команд прерывается и процессор
начинает выполнять действия по синхронизации.

Несмотря на то что перезаписывание регистра CR3 выполняется всего за две процессорные
инструкции (считывание регистра CR3 в один из регист\-ров общего назначения и повторная запись
этого же значения в регистр CR3), реально эта операция выполняется в течение нескольких сотен
тактов процессора. Данная операция выполняется так час\-то, как скоро возникают изменения в
таблицах страниц. Откладывать ее выполнение нельзя, поскольку иначе у разных процессоров в
системе возникнут различия в представлении адресных пространств. Операция синхронизации
процессоров должна выполняться вне зависимости от наличия или отсутствия аппаратных
прерываний в системе. Поэтому логичнее всего команду синхронизации и обработчик установить
на немаскируемое прерывание (NMI, nonmaskable interrupt). Вход процессора в обработчик прерывания и выход из него
вносят дополнительные задержки в работу процессора.

   Несомненно, синхронизация процессоров в многопроцессорной системе снижает точность
выполнения регионов времени. Это является основным недостатком многопроцессорной системы.

   С другой стороны, SMP-системы обладают также неоспоримыми преимуществами. Наличие в
каждом из процессоров (процессорных ядер) собственного высокоточного таймера позволяет
одновременно обрабатывать несколько регионов времени в разных процессах, что повышает
гибкость системы в целом.

   Реализация регионов времени в мно\-го\-про\-цессорной системе требует изменения алгоритма
работы по программированию таймера. Теперь требуется обеспечить балансировку загрузки
процессоров регионами времени. Алгоритмы балансировки могут быть достаточно сложны и
разнообразны, но при этом они будут дополнительно занимать процессорное время, поэтому
предпочтительным представляется наиболее простой алгоритм.

   Регион времени всегда привязан к нити, на которой он выполняется. В многопроцессорной
системе всегда реализован тот или иной принцип распределения нитей между процессорами.
Поэтому наиболее оптимальным представляется принцип, по которому ответственным за регион
времени назначается тот процессор, на котором был обработан старт региона времени. В
результате происходит привязка региона времени к процессору и дополнительного алгоритма
балансировки регионов времени между процессорами не требует-\linebreak\vspace*{-12pt}
\pagebreak

%\begin{figure*} %fig8
\vspace*{1pt}
\begin{center}
\mbox{%
\epsfxsize=46.025mm
\epsfbox{ego-8.eps}
}
\end{center}
\vspace*{1pt}
{{\figurename~8}\ \ \small{Привязка регионов времени к процессорам}}
%\label{f1s}}
%\end{figure*}
\bigskip
\addtocounter{figure}{1}  




\noindent
ся. Для каждого процессора в
системе становится необходимым формировать список регионов времени, привязанных к данному
процессору. Данная схема иллюстрируется на рис.~8.



   Когда какой-либо из регионов времени срабатывает, процессор фиксирует отсечку региона
времени, изменяет текущий контекст нити и ставит ее на обработку. Затем процессор выбирает из
списка следующий регион времени, отнесенный к данному процессору, и программирует свой
таймер LocalApic заново.

\section{Реализация регионов времени с~помощью функций}

   Любая реализация регионов времени требует возможности запоминания точки, в которую
будет передано управление при завершении региона времени с тайм-аутом. Самый простой способ
реализации данного механизма заключается в использовании точки старта региона времени также
и в качестве точки его завершения. При таком способе реализации необходимо только выполнить
проверку~--- возврат из функции был стартом региона времени или его завершением. Такую
проверку легко осуществить по коду возврата из функции.

   Ниже представлен возможный вариант использования региона времени в низкоуровневом коде.
Функция StartTimeRegion фиксирует начало региона времени. При старте региона времени
функция возвращает значение TRUE. Функция FinishTimeRegion фиксирует конец кода региона
времени. При возникновении тайм-аута управление передается на точку выхода из функции
StartTimeRegion с результатом работы FALSE.

\medskip
\noindent
{\small
{\sf struct \_TimeRegion *pTimeRegion;}\\
{\sf BOOL bResult;}\\
{\sf LARGE\_INTEGER liTime;}\\
{\sf liTime.QuadPart = -10000000*2; // две секунды}\\
\


\noindent
{\sf// Старт региона времени}\\
{\sf bResult = StartTimeRegion( }\\
\hspace*{5mm}{\sf    SYSTEM\_TIME, // Системное время}\\
\hspace*{5mm}{\sf    liTime,}\\
\hspace*{5mm}{\sf    \&pTimeRegion);}\\
\

\noindent
{\sf if (bResult)}\\
{\sf \{}\\
\hspace*{5mm}{\sf    // Выполняется регион времени}\\
    \hspace*{5mm}{\sf \ldots}\\
\hspace*{5mm}{\sf    // Конец региона времени}\\
\hspace*{5mm}{\sf    FinishTimeRegion(pTimeRegion);}\\
{\sf \} else}\\
{\sf \{}
\hspace*{5mm}{\sf    // Конец региона времени}\\
\hspace*{5mm}{\sf    FinishTimeRegion(pTimeRegion);}\\
\hspace*{5mm}{\sf    // Действия по тайм-ауту}\\
\hspace*{5mm}{\sf \ldots }\\
{\sf \} }\\
}

   Подобный способ широко используется в операционных системах UNIX для
распараллеливания процессов. Функция fork производит создание нового процесса на базе
текущего. Оба процесса получают управление в точке выхода из функции.

В случае с регионами времени распараллеливания не происходит, поскольку работа
происходит всегда в контексте одной и той же нити. И вход в регион времени, и выход по
истечении тайм-аута происходят в точке выхода из функции StartTimeRegion. Различие
заключается только в коде возврата функции. Вне зависимости от вида завершения региона
времени~--- по завершении кода региона времени либо по истечении тайм-аута~--- необходимо
выполнить функцию FinishTimeRegion, которая фиксирует окончание региона времени и
осво\-бож\-да\-ет память, выделенную для него.

   Подобная организация регионов времени весьма удобна для системного программиста. Вход в
функцию StartTimeRegion фиксирует адрес, в который нужно передать управление в случае
истечения тайм-аута. Этот адрес сохраняется в структуре региона времени. Для прикладного
программиста такая организация регионов времени, наоборот, является весьма неудобной.
Отсутствие жесткой связи между стартом региона и его завершением позволяет программисту
создавать различные сочетания регионов времени, в том числе и перекресток регионов, которые
при выполнении могут давать непредсказуемые результаты. Этого недостатка лишен способ,
когда регионы времени интегрируются напрямую в язык программирования.

\section{Расширение языка программирования Cи для~регионов
времени} %8

     Наиболее предпочтительным способом использования регионов времени для программиста
является внедрение регионов времени непосредственно в язык программирования. Ниже
представлено предлагаемое расширение языка программирования Си, использующее новые
ключевые слова для задания регионов времени.

     В рамках расширения внесены следующие изменения в грамматику языка Си: добавлены два
новых нетерминала~--- \textit{try-except-statement} и \textit{try-finally-statement}~--- в грамматику
нетерминала statement. Последняя, в соответствии со стандартом ISO/IEC 9899:TC2~\cite{11eg} и с
учетом внесенных изменений, приведена ниже (добавленные нетерминалы выделены
подчеркиванием).

\medskip
\textit{statement:}

\textit{labeled-statement}

\textit{compound-statement}

\textit{expression-statement}

\textit{selection-statement}

   \textit{iteration-statement}

   \textit{jump-statement}

   \underline{\textit{try-except-statement}}

   \underline{\textit{try-finally-statement}}

   \underline{\textit{try-timeout-statement}}

\medskip
     Грамматика нетерминалов \textit{try-except-statement}, \textit{try-finally-statement},
     \textit{try-timeout-statement}, а также других связанных с ними конструкций приведена ниже:

   \medskip
   \textit{try-except-statement:}

   \_\textbf{try} \textit{compound-statement} \_\textbf{except} (\textit{expression})
\textit{compound-statement}

   \medskip
   \textit{try-finally-statement:}

   \_\textbf{try} \textit{try-finally-compound-statement} \_\textbf{finally} \textit{termination-block}

   \medskip
   \textit{try-timeout-statement:}
   \_\textbf{try} \textit{timeout-assignment compound-statement} \_\textbf{timeout}
\textit{termination-block}

   \medskip
   \textit{timeout-assignment:}

   \textit{timeout-specifiers$_{opt}$} (\textit{expression})

   \medskip
   \textit{timeout-specifiers:}

   \_\textbf{system\_timeout }

   \_\textbf{thread\_timeout}

   \medskip
   \textit{try-finally-compound-statement:}

   \{\textit{ try-finally-block-item-list$_{opt}$ }\}

   \medskip
   \textit{try-finally-block-item-list:}

   \textit{try-finally-block-item}

   \textit{try-finally-block-item-list try-finally-block-item}

   \medskip
   \textit{try-finally-block-item:}

   \textit{declaration}

   \textit{statement}

   \_\textbf{leave ;}

   \medskip
   \textit{termination-block:}

   \{\textit{ termination-block-item-list}$_{opt}$\}


   \medskip
   \textit{termination-block-item-list:}

   \textit{termination-block-item}

   \textit{termination-block-item-list termination-block-item}

   \medskip
   \textit{termination-block-item:}

   \textit{declaration}

   \textit{labeled-statement}

   \textit{compound-statement}

   \textit{expression-statement}

   \textit{selection-statement}

   \textit{iteration-statement}

   \textit{jump-statement}

   \textit{try-finally-statement}

   \medskip

     Помимо изменений в грамматике предлагается внесение изменений в семантику языка Си.
Конструкции \textit{try-except} и \textit{try-finally} реализуют <<классический>> механизм структурной
обработки исключений (SHE~--- Structured Exception Handling), совместимый с аналогичным
механизмом, поддерживаемым компилятором Microsoft вместе с операционной системой
Windows~\cite{2eg}. Данные расширения носят название ms-specific расширений языка Си/Си++.
В качестве расширения механизма SEH предлагается дополнительно ввести блок
\textit{try-timeout}.

Тайм-аут блока \textit{try-timeout} определяется выражением, которое при других обстоятельствах
могло бы явиться правой частью выражения присвоения (см.\ грамматику выше). Таким образом,
выражение, определяющее тайм-аут блока \textit{try-timeout}, должно быть $r$-значением (в том числе
константным) и иметь тип long long int. Значение данного выражения задает тайм-аут,
выраженный в 100-наносекундных интервалах. Тайм-аут может быть задан либо в единицах
системного времени с помощью ключевого слова \_\textbf{system\_time} в заголовке блока \textit{try}, либо в
единицах виртуального времени выполняющей код блока \textit{try} нити с помощью ключевого слова
\_\textbf{thread\_time} в заголовке блока \textit{try}. Знак значения выражения, определяющего тайм-аут, задает
режим отсчета времени: <<$+$>>~--- абсолютное время; <<$-$>>~--- относительное время. Режим
отсчета времени имеет ту же семантику, что подразумевается в других API-функциях,
принимающих в качестве одного из своих аргументов значение времени (тайм-аута), например
\textit{SetWaitableTimer}. Грамматикой допускается отсутствие спецификаторов режима отсчета в
заголовке блока \textit{try}. В этом случае подразумевается спецификатор \_\textbf{system\_time}.

При указании тайм-аута в блоке \textit{try-timeout} и при выполнении кода в блоке \textit{try} за время,
меньшее или равное указанному тайм-ауту, управление передается коду, следующему
непосредственно за блоком \textit{timeout}. Такая передача управления трактуется как нормальное
завершение кода блока \textit{try}. При возникновении тайм-аута или возникновении другой
исключительной ситуации управление передается в блок \textit{timeout}. Код в блоке \textit{timeout} способен
определить причину передачи управления в блок \textit{timeout}, используя функцию
\textit{GetTimeoutCode()}, и предпринять соответствующие действия.

     Функция \textit{GetTimeoutCode()} возвращает один из трех кодов завершения:
TIMEOUT\_EXPIRED, OVERLYING\_TIMEOUT\_EXPIRED,
OVERLYING\_ EXEPTION\_OCCURED. Код TIMEOUT\_EXPIRED означает возникновение
     тайм-аута в текущем блоке. Код OVERLYING\_TIMEOUT\_EXPIRED означает
возникновение тайм-аута в вышележащем блоке. Наконец, код
OVERLYING\_\linebreak EXEPTION\_OCCURED означает возникновение исключительной ситуации,
обработчик которой находится по коду выше текущего блока \textit{try-timeout}. В~случае возвращения
функцией \textit{GetTimeoutCode()} кода OVERLYING\_EXEPTION\_OCCURED обработчик
может вызвать функцию \textit{GetExceptionCode()} для определения кода исключения.

     Если программой заданы вложенные обработчики \textit{finally}, то при выходе из блока \textit{try} как при
нормальном завершении, так и при возникновении тайм-аута выполняется код обработчиков
\textit{finally}, а также выполняются другие действия, предусмот\-рен\-ные <<классическим>> механизмом
SEН, такие как <<раскрутка>> (unwinding) и другие.

\section{Связь регионов времени с~обработчиками исключений}

   После внесения изменений в язык программирования Си при выполнении программы могут
возникнуть следующие комбинации блоков, тре\-бу\-ющие корректной обработки:
   \begin{enumerate}[1.]
\item Если в процессе работы программы возникает завершение региона времени по
тайм-ауту, то необходимо произвести раскрутку обработчиков исключений, для того
чтобы остались только те обработчики, которые находятся в стеке SEH выше блока
\textit{timeout}.
\item Если в процессе работы программы возникает исключение, а обработчик исключения
находится в стеке выше, чем блок \textit{timeout}, отвечающий за обработку региона времени, то в
процессе раскрутки стека SEH по возникновении исключения необходимо выполнить код,
завершающий регион времени. В противном случае при возникновении тайм-аута стек
обработчика региона времени будет уже разрушен.
\item Если в процессе работы программы возникает завершение вышележащего региона
времени по тайм-ауту, то необходимо уведомить текущий обработчик, что его регион
времени завершается до завершения блока \textit{try}.
\item И при возникновении исключения, и при возникновении тайм-аута необходимо в
процессе раскрутки производить выполнение блоков \textit{finally}, расположенных ниже в стеке
SEH. Блоки \textit{finally} необходимы для корректного завершения работы с ресурсами
программы при возникновении исключения или тайм-аута.
   \end{enumerate}

   Для корректной работы программы также необходимо, чтобы в течение выполнения блока
\textit{finally} механизм регионов времени работал только на отсечку тайм-аутов, а переключения не
производились. В противном случае возникнет вероятность некорректной работы программы.

   Как видно из вышеприведенного списка, блок \textit{try-timeout} является одной из составных частей
стека SEH. При написании программ невозможно отделить регионы времени, оформленные в виде
\mbox{блоков} \textit{try-timeout} от других блоков структурной обработки исключений. В противном случае
корректная обработка исключений становится невозможной.

\section{Стиль написания программ, использующих регионы времени}

   Если в процессе написания программы возникает необходимость использования блока
\textit{try-timeout}, то вся нижележащая работа с ресурсами, включая системные ресурсы и
собственные ресурсы программы, должна быть оформлена в виде блоков \textit{try-finally}.
Использование данных блоков позволяет исключить утечку ресурсов при возникновении
   тайм-аута.

   Ниже приведен пример, иллюстрирующий использование блоков \textit{try-finally} для исключения
утечки памяти в процессе работы программы.

\medskip
\noindent
%{\small
%\begin{verbatim}
{\sf char *pData = NULL;}\\
\

{\sf \_try \_system\_time(-10000) \{ // регион на 1 мс}\\
    \hspace{2.5mm}{\sf \_try \{ }\\
        \hspace*{5mm}{\sf pData = (char*)malloc(512); // выделение памяти}
        \hspace*{5mm}{\sf // работа с памятью}\\
        \hspace*{2.5mm}{\sf \}}\\
    \hspace*{2.5mm}{\sf \_finally \{ }\\
        \hspace*{5mm}{\sf if (pData)}\\
                \hspace*{7.5mm}{\sf free(pData); // освобождение памяти}\\
 \hspace*{2.5mm}{\sf   \}}\\
{\sf \} }            \\
{\sf \_timeout } \\
{\sf \{ }        \\
    \hspace*{2.5mm}{\sf printf(``Timeout!'');}\\
{\sf \}}\\
%\end{verbatim}
%}

   В блоке \textit{try-finally}, расположенном в составе блока \textit{try-timeout}, происходит работа с памятью.
Осво\-бож\-де\-ние памяти помещено в состав блока \textit{finally}. В~результате при возникновении тайм-аута
в первую очередь будет выполнен код, находящийся в составе блока \textit{finally}, а именно
освобождение выделенной памяти. Только после этого управление будет передано блоку \textit{timeout}.
Таким образом, потеря памяти при возникновении тайм-аута будет исключена.

   Если тайм-аут возникнет, когда программа будет выполняться в блоке \textit{finally}, то переключение
на блок \textit{timeout} произойдет только после выхода из блока \textit{finally}.

\section{Заключение}

   Благодаря введению понятия <<регион времени>> становится возможным придание
операционной системе общего назначения черт, изначально присущих только операционным
системам реального времени. Регионы времени дают возможность написания более гибкого кода
как в составе ядра операционной системы, так и для прикладных программ.

   В статье исследованы вопросы аппаратной поддержки регионов времени в современных
персональных компьютерах. Рассмотрены принципы и проблемы реализации регионов времени
ядром операционной системы.

   В статье также предлагается два способа представления регионов времени для программиста:
на основе функций и на основе конструкций языка программирования. Второй способ придает
большую предсказуемость поведению регионов времени и связывает их с обработчиками
исключений, позволяя задавать единый код обработки исключительных ситуаций.

{\small\frenchspacing
{%\baselineskip=10.8pt
\addcontentsline{toc}{section}{Литература}
\begin{thebibliography}{99}


   \bibitem{3eg} %1
\Au{Соломон Д., Руссинович~М.}
Внутреннее устройство Microsoft Windows 2000. Мастер-класс~/ Пер. с англ.~--- СПб.: Питер; М.:
Издательско-торговый дом <<Русская редакция>>, 2001.  752~с.


\bibitem{8eg} %2
Intel 82371FB (PIIX) AND 82371SB (PIIX3) PCI ISA IDE XCELERATOR. April 1997.~---  {\sf
www.intel.com.}

   \bibitem{7eg} %3
BIOS and Kernel Developers Guide for AMD Athlon 64 and AMD Opteron Processors. Rev.~3.28.
October 2005.~--- {\sf www.amd.com.}


   \bibitem{6eg} %4
Intel 64 and IA-32Architectures Software Developers Manual. Vol.~3a: System Programming Guide,
Part~1. May 2007.~--- {\sf www.intel.com.}

\bibitem{9eg} %5
Intel 82093AA I/O ADVANCED PROGRAMMABLE INTERRUPT CONTROLLER (IOAPIC). May
1996.~--- {\sf www.intel.com.}

   \bibitem{10eg} %6
MultiProcessor Specification Version 1.4. May 1997.~--- {\sf www.intel.com.}


   \bibitem{5eg} %7
   \Au{Лукач Ю.\,С., Сибиряков~А.\,Е.}
    Программно-тех\-ни\-че\-ские средства персональных ЭВМ семейства IBM PC.~--- Свердловск:
Инженерно-техническое бюро, 1990.  139~с.

   \bibitem{4eg} %8
\Au{Рихтер Дж., Кларк~Дж.\,Д.}
Программирование серверных приложений для Microsoft Windows 2000. Мастер-класс~/ Пер. с
англ.~--- СПб.: Питер; М.: Издательско-торговый дом <<Русская редакция>>, 2001.  592~с.

   \bibitem{1eg} %9
\Au{Дейтел Х.\,М., Дейтел~П.\,Дж., Чофнес~Д.\,Р.}
Операционные системы. Основы и принципы~/ Пер. с англ. 3-е изд.~--- М.: ООО
<<Бином-Пресс>>, 2007.  1024~с.

\label{end\stat}

   \bibitem{11eg} %10
International Standard ISO/IEC 9899:TC2. May 2005.~--- {\sf www.open-std.org.}

   \bibitem{2eg} %11
   \Au{Рихтер Дж.}
    Windows для профессионалов: создание эффективных Win32-приложений с учетом специфики
64-разрядной версии Windows. 4-е изд.~--- СПб.: Питер; М.: Издательско-торговый дом <<Русская
редакция>>, 2001.  752~с.
\end{thebibliography}
}
}
\end{multicols}