
\def\blackbox{\vrule height 7pt width 7pt depth 0pt}
\def\modn#1{\mathop{=}\limits_{#1}}
\def\modp#1{\mathop{+}\limits_{#1}}
\def\modm#1{\mathop{-}\limits_{#1}}


\def\stat{mironov}

\def\tit{МЕТОД ДОКАЗАТЕЛЬСТВА НАБЛЮДАЕМОЙ ЭКВИВАЛЕНТНОСТИ
ПРОЦЕССОВ С ПЕРЕДАЧЕЙ СООБЩЕНИЙ}

\def\titkol{Метод доказательства наблюдаемой эквивалентности
процессов с передачей сообщений}

\def\autkol{А.\,М.~Миронов}

\def\aut{А.\,М.~Миронов$^1$}

\titel{\tit}{\aut}{\autkol}{\titkol}

%{\renewcommand{\thefootnote}{\fnsymbol{footnote}} \footnotetext[1]{Работа
%выполнена при финансовой поддержке РФФИ (проект 11-01-00515а).}}

\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{Институт проблем
информатики Российской академии наук, amironov66@gmail.com}

\vspace*{-9pt}


\Abst{Рассматривается проблема
доказательства наблюдаемой эквивалентности для  класса
вычислительных процессов, называемых процессами с передачей сообщений.
Действия, выполняемые такими процессами,  заключаются в посылке или приеме сообщений,
проверке логических условий и обновлении значений
внутренних переменных процессов. Основным результатом статьи является
теорема, сводящая задачу доказательства наблюдаемой эквивалентности
пары процессов с передачей сообщений к задаче нахождения формул, ассоциированных
с парами состояний этих процессов, удовлетворяющих некоторым условиям, которые
связаны с переходами этих процессов.
Данное сведение является обобщением известного метода Флойда верификации
блок-схем, в котором задача верификации блок-схе\-мы сводится
к задаче нахождения формул (называемых промежуточными
утверждениями), связанных с некоторыми точками в блок-схе\-мах
и удовлетворяющих некоторым условиям, соответствующим переходам в блок-схе\-мах.
Изложенный метод  доказательства наблюдаемой эквивалентности
процессов с передачей сообщений иллюстрируется
примером верификации протокола скользящего окна.}

\KW{верификация; процессы с передачей сообщений; наблюдаемая эквивалентность;
протокол скользящего окна}

\DOI{10.14357/19922264140206}

\vskip 10pt plus 9pt minus 6pt

      \thispagestyle{headings}

      \begin{multicols}{2}

            \label{st\stat}

\section{Введение}

\subsection{Понятие наблюдаемой эквивалентности процессов}

Понятие наблюдаемой эквивалентности процессов было сформулировано
Р.~Милнером и подробно изучено им в основополагающей работе~\cite{1-mir}.
Данное понятие зарекомендовало себя как  одно из наиболее
эффективных средств для решения задач спецификации и верификации
различных свойств вычислительных процессов.

В своей исходной формулировке понятие наблюдаемой эквивалентности
относится к процессам, определяемым в терминах исчисления
взаимодействующих систем  Милнера~\cite{1-mir}. Одним из наиболее важных
достоинств понятия наблюда\-емой эквивалентности является возможность
сформулировать аналог данного понятия (и разработать основанные на
нем методы спецификации и верификации) в самых различных классах
вычислительных процессов, в том числе в классах вероятностных
процессов~\cite{larsen}, процессов реального времени~\cite{realtime}
и~др.

В настоящей работе  рассматривается один из классов вычислительных процессов,
называемых процессами с передачей сообщений.
Определяется понятие наблюдаемой эквивалентности таких
процессов, формулируется достаточное условие наблюдаемой эквивалентности процессов с передачей сообщений.
Применение данного понятия иллюстрируется примером
спецификации и верификации протокола скользящего окна.

\vspace*{-4pt}

\subsection{Мотивация предлагаемого метода}

\vspace*{-2pt}

Предлагаемый в настоящей работе метод доказательства наблюдаемой
эквивалентности про\-цессов с передачей сообщений предназначен для\linebreak
решения различных проблем, связанных со спе\-цификацией и верификацией
вычислительных сис\-тем. Проблемы спецификации и верификации\linebreak сис\-тем
образуют одно из наиболее актуальных на\-прав\-ле\-ний в теоретической
информатике. Существует несколько подходов, относящихся к этому
на\-прав\-ле\-нию, наиболее важными из них являются: исчисление
взаимодействующих сис\-тем Р.~Милнера (CCS~--- calculus of communicating systems)
и $\pi$-ис\-чис\-ле\-ние~[1, 4],
теория взаимодействующих процессов А.~Хоара (CSP~--- communicating sequential
processes) и ее обобщения~\cite{3-mir},
темпоральная логика и model checking~\cite{4-mir}, сети Петри~\cite{5-mir},
процессные алгебры~\cite{6-mir}, теория взаимодействующих
машин с конечным числом состояний~\cite{7-mir}. Основным недостатком
современных методов верификации дискретных процессов является их
высокая сложность. В~частности,
\begin{itemize}
\item основным недостатком методов верификации, основанных на подходе model checking, является высокая
вычислительная сложность, связанная с проблемой <<взрыва числа
состояний>> (state explosion problem);
\item недостатки методов, основанных на доказательстве теорем, связаны с высокой
слож\-ностью
построения соответствующих теорем и их доказательств, а также со
сложностью понимания этих доказательств.
\end{itemize}

Мотивация предлагаемого подхода  к моделированию и верификации дискретных
 систем заключается в желании упростить  и сделать более явными следующие аспекты
 моделирования и анализа дискретных систем:  представление математических моделей
анализируемых систем,  построение доказательств корректности этих систем и
 понимание этих доказательств любым, кто не является экспертом в математической
теории верификации дискретных систем.

Рассматриваемая в настоящей работе модель дискретных процессов
представляет собой синтез Милнеровской модели процессов~\cite{1-mir} и модели
взаимодействующих машин с конечным числом состояний~\cite{7-mir}.
Дискретные процессы представляются в данной модели в виде графов,
ребра которых помечены  операторами. Эти операторы состоят из
внутренних действий и действий вво\-да-вы\-во\-да.
Доказательства корректности процессов пред\-став\-ля\-ют\-ся множествами формул, связанных
с парами состояний анализируемых процессов. Этот метод верификации процессов является
синтезом метода Милнера, основанного на понятии наблюдаемой эквивалентности~\cite{1-mir},
и метода индуктивных утверждений Флойда~\cite{8-mir}.
Для упрощения анализа процессов  вводятся операции упрощения на процессах.


\subsection{Преимущества предлагаемого подхода}

Предлагаемая математическая модель
процессов с передачей сообщений позволяет
строить такие математические модели анализируемых систем, которые во многом
похожи на исходные описания этих систем на
ка\-ком-ли\-бо императивном языке программирования.
В разд.~7  будет приведен
пример такой модели, которая соответствует программе на
языке~C, описывающей функционирование протокола скользящего окна с возвратом на~$n$
(эта программа была взята из~\cite[п.~3.4.2]{12-mir}.

Основные преимущества предложенного подхода
заключаются в возможности использования операций упрощения моделей анализируемых
сис\-тем, которые позволяют облегчить решение
проб\-ле\-мы верификации этих моделей.
Следует отметить, что эти упрощенные модели позволяют более ясно понимать основные особенности
анализиру\-емых систем
и облегчают построение  доказательств корректности ана\-ли\-зи\-ру\-емых сис\-тем.
В~разд.~7  будет приведен пример такого
упрощения модели для протокола скользящего окна: эта модель может быть упрощена
до модели с одним состоянием.

Если анализируемое свойство ка\-кой-ли\-бо сис\-те\-мы
имеет вид поведения, которое описывается в виде некоторого процесса, например в том случае, когда
анализируемая система представляет собой телекоммуникационный протокол и
свойство этой системы представляет собой
описание внешнего поведения этого протокола
(связанного с его взаимодействием с протоколом вышестоящего уровня),
то доказательством корректности такой системы в этой модели является множеством формул,
ассоциированных с парами состояний, первое из которых является состоянием анализируемой
системы, а второе -- состоянием процесса, который описывает свойство этой системы.
В~разд.~7 будет приведен пример доказательства
такого типа, которое представляет собой небольшое множество простых формул.
Эти формулы могут быть естественным образом
извлечены из упрощенной модели анализируемого протокола.

Другое преимущество предлагаемого подхода заключается в возможности верифицировать
на его основе системы с неограниченными множествами состояний.

\subsection{Сравнение с другими работами}

В этом пункте  излагается обзор работ, относящихся
к проблеме верификации систем с  передачей сообщений,
которые наиболее тесно связаны с настоящей статьей.

В статье~\cite{9-mir} рассматривается моделирование и верификация
процессов, описание которых производится на алгебраическом языке  $\mu$CRL.
Для\linebreak анализа таких процессов используется система доказательства теорем
PVS (Prototype Verification\linebreak System).
В частности, рассматривается пример ав-\linebreak томатической
верификации протокола передачи сообщений  с выборочным повтором.
Отметим, что этот протокол может быть верифицирован
существенно проще (по сравнению с тем рас\-суж\-де\-ни\-ем,
обосновывающим корректность
данного протокола, которое приведено в работе~\cite{9-mir})
при помощи подхода, излагаемого в настоящей работе.

Существует большое количество работ, отно\-сящихся к верификации систем с передачей
со\-об\-щений, основанных на темпоральной логике и методе верификации model checking.
Наиболее близкое отношение к материалу, излагаемому в
настоящей статье, имеют работы~[13--19].
Главным недостатком всех этих методов является их ограниченная
возможность: они позволяют верифицировать только системы с конечным числом состояний.

Среди других подходов следует отметить те, которые основаны на использовании
логики первого порядка и верификации путем построения вспомогательных
утверждений~\cite{21-mir, 20-mir},
а также подходы, связанные с использованием
процессной ал\-геб\-ры~[22--24].

Наиболее существенным недостатком всех этих подходов является высокая сложность
по\-стро\-ения доказательств корректности анализируемых сис\-тем.

\section{Вспомогательные понятия}

\subsection{Термы}

Будем считать, что заданы множество~${\cal X}$  {\bf переменных},
множество~${\cal D}$  {\bf значений},
множество~${\cal C}$  {\bf констант} и множество~${\cal F}$  {\bf функциональных
символов}. Каждая константа из~${\cal C}$ интерпретирована
некоторым значением из~${\cal D}$ и каждый функциональный
символ~--- некоторой операцией на~${\cal D}$.
Будем считать, что ${\cal C}$ содержит константы~0 и~1, а
${\cal F}$ содержит булевы функциональные
символы  $\wedge,\vee,\to$, которым соответствуют
стандартные булевы операции на $\{0,1\}$.

Множество ${\cal E}$ {\bf термов} определяется стандартным образом.
Переменные и константы являются термами.
Другие термы имеют вид $f(e_1,\ldots, e_n)$, где
$f\hm\in {\cal F}$ и $e_1,\ldots, e_n$~--- термы.
Для каждого $e\hm\in {\cal E}$ запись~$X_e$ обозначает
множество всех переменных, входящих в~$e$.

Если $X\subseteq {\cal X}$, то {\bf означиванием} переменных из~$X$ называется соответствие~$\xi$,
сопоставляющее каж\-дой переменной $x \hm\in X$ некоторое значение из~${\cal D}$,
которое  будем обозначать записью~$x^\xi$.
Множество всех означиваний переменных из~$X$  будем обозначать
записью~$X^\bullet$. Для каждого $e\hm\in {\cal E}$,
каждого $X\supseteq X_e$ и каждого $\xi\hm\in X^\bullet$
запись~$e^\xi$ обозначает объект, называемый {\bf значением}~$e$ на~$\xi$
и определяемый стандартным образом.
Будем считать термы~$e_1$ и~$e_2$ равными, если
$\forall\,\xi\hm\in (X_{e_1}\cup X_{e_2})^\bullet\;\;
e_1^\xi\hm=e_2^\xi$.

Терм $e$ называется {\bf формулой}, если $\forall\,\xi\hm\in X_e^\bullet$
значение $e^\xi$ равно~0 или~1. Символ~${\cal B}$ обозначает множество всех формул.
Символы~$\top$ и~$\bot$ обозначают
истинную и ложную формулу соответственно. Формулы вида
$\wedge(b_1,b_2)$, $\vee(b_1,b_2)$ и~т.\,д.\ будем записывать в более
привычном виде $b_1\wedge b_2$, $b_1\vee b_2$ и~т.\,д. Формулы вида
$b_1\wedge \ldots\wedge b_n$ могут записываться также в виде
$\left\{
\begin{array}{c}
b_1\\[3pt] \vdots \\[3pt] b_n\end{array}\right\}$.

\subsection{Атомарные операторы}
%\label{oe}

Будем считать, что задано множество~${\cal N}$, элементы которого   рассматриваются
как имена объектов, которые могут посылать или получать про\-цессы.

{\bf Атомарный оператор (АО)}~---  это конструкция~$o$ одного из трех
перечисляемых ниже видов. Каждой паре $(o, \xi)$, где $o$~--- АО и
$\xi$~--- означивание переменных, входящих в~$o$,
соответствует  некоторое действие~$o^{\xi}$, неформально определяемое ниже.
\begin{enumerate}[1.]
\item
{\bf Ввод}~--- это АО вида $\alpha?x$, где $\alpha\hm\in  {\cal N}$
и $x \hm\in {\cal X}$. Действие
$(\alpha?x)^{\xi}$ заключается в получении от другого процесса
объекта с именем~$\alpha$ вместе с присоединенным к этому объекту сообщением,
которое записывается в  переменную~$x$.

\item {\bf Вывод}~--- это АО вида $\alpha ! e$, где
$\alpha\hm\in  {\cal N}$ и $e \hm\in {\cal E}$.
Действие $(\alpha ! e)^{\xi}$ заключается
в посылке другому процессу объекта с именем~$\alpha$, к которому присоединено
сообщение~$e^\xi$.

\item {\bf Присваивание}~--- это АО вида $x := e$, где $x\hm \in {\cal X}$,
$e \hm\in {\cal E}$. Действие $(x := e)^{\xi}$ заключается
в присваивании переменной~$x$ значения~$e^\xi$.
\end{enumerate}

Ниже  будем использовать следующие обозначения:
\begin{itemize}
\item для каждого АО~$o$ запись~$X_{o}$ обозначает множество
всех переменных, содержащихся в~$o$;
\item если $e\hm\in {\cal E}$ и $o$~--- присваивание, то
запись $\dey{o}{e}$ обозначает терм, определяемый сле\-ду\-ющим образом: пусть
$o$ имеет вид $(x:=e')$, тогда $\dey{o}{e}$ получается из~$e$
заменой всех вхождений в него переменной~$x$ на терм~$e'$;
\item если $o$~--- присваивание и  $\xi\hm\in X^\bullet$,
где $X_o\hm\subseteq X\subseteq {\cal X}$, то запись $\deyc{\xi}{o}$
обозначает означивание из~$X^\bullet$, определяемое следующим образом:
пусть $o\hm=(x:=e)$, тогда $x^{\deyc{\xi}{o}}\hm= e^\xi$
и $\forall\,y\hm\in X\setminus \{x\}\;\; y^{\deyc{\xi}{o}}\hm= y^\xi$.
\end{itemize}

Нетрудно доказать, что если $o$~--- присваивание и $e\hm\in {\cal E}$,
то для каждого $\xi\hm\in X^\bullet$, где
$X_o\cup X_e\subseteq X\subseteq {\cal X}$,
будет верно равенство $\dey{o}{e}^\xi\hm= e^{\deyc{\xi}{o}}$. Данное равенство
доказывается индукцией по структуре терма~$e$.

\subsection{Операторы}
%\label{concatt}

{\bf Оператор}~--- это запись~$O$ вида $b[o_1, \ldots, o_n]$, где
$b$~--- формула, называемая {\bf предусловием} оператора~$O$ (данная
формула будет обозначаться записью $\langle O \rangle$), и $o_1, \ldots, o_n$~---
последовательность АО (данная последовательность будет обозначаться
записью $[O]$), среди которых присутствует не более одного ввода или
вывода. Последовательность $[O]$ может быть пустой ($[\,]$).

Если в $[O]$ есть ввод (или вывод), то будем называть~$O$ {\bf оператором
ввода} (или {\bf вывода}) и обозначать записью~$N_O$ имя, входящее в~$O$.
Если же в $[O]$ нет вводов и выводов, то будем называть~$O$
{\bf внутренним} оператором.

Если $\langle O\rangle\hm=\top$, то такое предусловие в записи оператора~$O$ можно опускать.

Ниже будем использовать следующие обозначения.
\begin{enumerate}[1.]
\item Для каждого оператора~$O$ запись~$X_{O}$ обозначает множество
всех переменных, содержащихся в~$O$.

\item Если $O$~--- оператор и $b\hm\in {\cal B}$, то запись $\deyc{O}{b}$
обозначает объект, который либо является формулой, либо не определен.
Данный объект определяется рекурсивно следующим образом.
Если $[O]$ пуста, то $\deyc{O}{b}\eam \langle{O}\rangle\wedge b$.
Если $[O]=o_1,\ldots, o_n$, где $n\hm\geq 1$, то обозначим записью
$O\setminus o_n$ оператор, получаемый из~$O$ удалением последнего АО, и
\begin{itemize}
\item если $o_n=\alpha?x$, то
$$
\deyc{O}{b}
\begin{cases}
& \mbox{ не определен для }  x\in X_b\,;\\
&\eam    \deyc{(O\setminus o_n)}{b}\ \mbox{иначе;}
\end{cases}$$
\item если $o_n=\alpha!e$, то $\deyc{O}{b} \eam    \deyc{(O\setminus o_n)}{b}$;
\item если $o_n = (x:=e)$, то $\deyc{O}{b} \eam \deyc{(O\setminus o_n)}{\dey{o_n}{b}}$.
     \end{itemize}

\item Если $O$~--- внутренний оператор и
 $\xi\hm\in X^\bullet$,
где $X_O\subseteq X\subseteq {\cal X}$, то запись $\deyc{\xi}{O}$
обозначает означивание из~$X^\bullet$, определяемое следующим образом:
если $[O]$ пуста, то $\deyc{\xi}{O}\eam \xi$, и если
$[O]\hm=o_1,\ldots, o_n$, где $n\hm\geq 1$, то
$\deyc{\xi}{O}\eam \deyc{(\deyc{\xi}{(O\setminus o_n)})}{o_n}$.
\end{enumerate}

Нетрудно доказать, что если оператор~$O$~--- внут\-ренний и $b\hm\in {\cal B}$,
то для каждого $\xi\hm\in X^\bullet$,
где $X_O\cup X_b\subseteq X\subseteq {\cal X}$,
такого что $\langle{O}\rangle^\xi\hm=1$, будет верно равенство
$(\deyc{O}{b})^\xi\hm=b^{\deyc{\xi}{O}}$. Данное равенство доказывается
индукцией по длине $[O]$.

\subsection{Конкатенация операторов}

Пусть заданы операторы~$O_1$ и~$O_2$, причем хотя бы один из них внутренний.

{\bf Конкатенацией} $O_1$ и~$O_2$ называется объект, обозначаемый
записью $O_1\cdot O_2$, который либо является оператором, либо не определен.
Данный объект определен в том и только в том случае, когда определена формула
$\deyc{O_1}{\langle{O_2}\rangle}$, и в этом случае
$$
O_1\cdot O_2\eam (\deyc{O_1}{\langle{O_2}\rangle})\left[[O_1], [O_2]\right]\,.
$$

Нетрудно доказать, что конкатенация операторов обладает следующими свойствами.
\begin{enumerate}[1.]
\item  Если операторы $O_1$, $O_2$ и формула~$b$
таковы, что определены все объекты в обеих частях равенства
$$
\deyc{(O_1\cdot O_2)}{b} = \deyc{O_1}{(\deyc{O_2}{b})}\,,
$$
то данное равенство верно.
\item Если операторы $O_1$, $O_2$, $O_3$ таковы, что определены
все объекты в обеих частях равенства
$$
(O_1\cdot O_2)\cdot O_3 = O_1\cdot (O_2\cdot O_3)\,,
$$
то данное равенство верно.
\end{enumerate}

\section{Процессы с передачей сообщений}

\subsection{Понятие процесса с передачей сообщений}

{\bf Процесс с передачей сообщений} (называемый также просто {\bf
процессом})~--- это четверка $P$ вида
\begin{equation}
\label{process}
P=(S_P, s^0_P, T_P, I_P)\,,\end{equation}
компоненты которой имеют следующий смысл:
\begin{itemize}
\item $S_P$~---
множество {\bf состояний} процесса~$P$;
\item $s^0_P \in S_P$~--- {\bf начальное состояние} процесса~$P$;
\item $T_P$~--- множество {\bf переходов} процесса~$P$,
каждый из которых имеет вид $s_1\ra{O}s_2$,
где $s_1, s_2 \hm\in S_P$ и $O$~--- оператор;
\item $I_P\in {\cal B}\setminus \{\bot\}$~--- {\bf предусловие} процесса~$P$.
\end{itemize}

Будем называть переход $s_1\ra{O}s_2$ {\bf вводом}, {\bf выводом}
или {\bf внутренним}, если $O$ является оператором ввода, вывода или внутренним
соответственно.

Для каждого процесса~$P$
\begin{itemize}
\item запись $X_P$ обозначает множество,
состоящее из
\begin{itemize}
\item всех переменных, входящих в ка\-кой-ли\-бо из переходов из~$T_P$
или в~$I_P$, и
\item переменной at$_P$, не входящей в переходы
и в~$I_P$, значениями которой являются со\-сто\-яния из~$S_P$
\end{itemize}
\item запись $\langle{P}\rangle$ обозначает
формулу $(\mathrm{at}_P\hm=s^0_P) \wedge I_P$.
\end{itemize}

Для каждого перехода $t\hm\in T_P$
записи $O_t$, $\langle{t}\rangle$, $\mathrm{start}\left(t\right)$ и $\mathrm{end}
\left(t\right)$
 обозначают оператор, формулу и состояния, определяемые следующим образом:
если $t$ имеет вид $s_1\ra{O}s_2$, то
$O_t\eam O$, $\langle{t}\rangle\eam (\mathrm{at}_P=s_1)\wedge \langle{O}\rangle$,
$\mathrm{start}\left(t\right)\eam s_1$, $\mathrm{end}\left(t\right)\eam s_2$.
Если $t$~--- ввод или вывод, то запись~$N_t$ обозначает имя $N_{O_t}$.

Множество~$X^s_P$ {\bf существенных переменных} процесса
$P$ оп\-ре\-де\-ля\-е\-тся как наименьшее (по включению)
множество, удовлетворяющее следующим условиям.
\begin{itemize}
\item $X^s_P$ содержит все переменные, содержащиеся в предусловиях
и выводах в операторах процесса~$P$;
\item если $P$ содержит АО $x:=e$ и $x\hm\in X^s_P$,
то $X^s_P$  содержит все переменные, входящие в~$e$.
\end{itemize}

Процессу $P$ соответствует помеченный граф (обозначаемый тем же символом~$P$),
вершинами которого являются состояния из~$S_P$,
а ребрами~--- переходы из~$T_P$: каждому переходу $s_1\ra{O}s_2$
соответствует ребро из~$s_1$ в~$s_2$ с меткой~$O$.

\subsection{Действия процессов}

Будем называть {\bf действием процесса} (или просто {\bf действием})
запись одного из следующих трех видов:
\begin{enumerate}[($i$)]
\item $\alpha?d$, где $\alpha\hm\in {\cal N}$ и $d\hm\in {\cal D}$.
Действие такого вида называется {\bf получением объекта} с именем~$\alpha$
вместе с присоединенным к этому объекту сообщением~$d$;

\item $\alpha!d$, где $\alpha\hm\in {\cal N}$ и $d\hm\in {\cal D}$.
Действие такого вида называется {\bf посылкой
объекта} с именем~$\alpha$ вместе с присоединенным к этому объекту сообщением~$d$;

\item $\tau$.
Действие такого вида называется {\bf невидимым действием}.
\end{enumerate}

Множество всех действий будем обозначать символом~${\cal A}$.

\subsection{Выполнение процесса}

{\bf Выполнение} процесса~(\ref{process})
представляет собой обход графа~$P$,
начиная с~$s^0_P$, с выполнением АО, входящих в метки проходимых ребер.
На каждом шаге $i\hm\geq 0$ этого обхода определены текущее состояние $s_i\hm\in S_P$
и текущее означивание $\xi_i \hm\in X_P^\bullet$.
Предполагается, что $s_0\hm= s^0_P$,
$\langle{P}\rangle^{\xi_0} \hm= 1$ и для каждого шага~$i$ этого обхода
$\mathrm{at}_P^{\xi_i} \hm= s_i$.

Выполнение процесса~$P$ на шаге~$i$ неформально описывается
следующим образом. Если в~$T_P$ нет переходов с началом в~$s_i$, то
$P$ заканчивает свою работу, иначе
\begin{itemize}
\item $P$ недетерминированно выбирает переход~$t$,
удовлетворяющий условиям: $\langle{t}\rangle^{\xi_i}\hm=1$, и
если $t$~--- ввод или вывод, то в текущий момент времени~$P$ имеет
возможность принять  или послать соответственно объект с именем~$N_t$
(т.\,е.\ в этот  же момент времени выполняется еще один процесс,
который в этот момент может послать процессу~$P$ или принять  от~$P$
соответственно объект  с именем~$N_t$). Если таких переходов нет,
      то  $P$  временно приостанавливает свою работу до
      того момента, когда появится хотя бы один такой переход, и после возобновления своей
      работы~$P$ недетерминированно выбирает один из
таких переходов;
\item после последовательного выполнения всех АО,
входящих в оператор~$O_t$ выбранного перехода~$t$, $P$
переходит в состояние $\mathrm{end}\left(t\right)$.
\end{itemize}

Выполнение каждого из АО~$o$, входящих в $[O_t]$,
заключается в выполнении некоторого действия $a\hm\in {\cal A}$
и замене текущего означивания~$\xi$ на  означивание~$\xi'$,
которое будет считаться текущим после выполнения  этого АО.
Выполнение АО~$o$ производится следующим образом:
\begin{itemize}
\item если $o \hm= \alpha?x$, то $P$ выполняет действие вида~$\alpha?d$
и $x^{\xi'} \eam d$, $\forall\,y \hm\in X_P \setminus \{x\}\quad
y^{\xi'} \eam y^{\xi}$;
\item если $o \hm= \alpha!e$, то $P$  выполняет действие
$\alpha!(e^{\xi})$ и $\xi'\eam \xi$;
\item если $o =  (x := e)$, то $P$  выполняет действие~$\tau$
и $x^{\xi'} \eam e^{\xi}$, $\forall\,y \hm\in X_P \setminus \{x\}\quad
y^{\xi'} \eam y^{\xi}$.
\end{itemize}

\section{Реализации процессов}

\subsection{Реализации атомарных операторов
и~последовательностей атомарных операторов}
%\label{xio}

{\bf Реализацией АО}~$o$ называется  тройка вида
$(\xi, a, \xi')$, удовлетворяющая следующим
условиям:
\begin{itemize}
\item $\xi,\xi' \in X^\bullet$,
где $X_o\subseteq  X\subseteq {\cal X}$, и $a\hm\in {\cal A}$;
\item если $o=\alpha?x$, то $a\hm=\alpha?(x^{\xi'})$ и
$\forall\,y\in X\setminus \{x\}$
$y^{\xi'}\hm=y^\xi$;
\item если $o=\alpha!e$, то $a\hm=\alpha!(e^\xi)$ и $\xi'\hm=\xi$;
\item если $o=(x:=e)$, то $a\hm=\tau$ и
$\xi'\hm=\deyc{\xi}{o}$.
\end{itemize}

Пусть $o_1,\ldots, o_n$~--- последовательность АО,
которая, возможно, пуста и содержит не более одного ввода или вывода.
{\bf Реализацией последова\-тель\-ности $o_1,\ldots, o_n$}
называется произвольная тройка вида $(\xi, a, \xi')$,
удовлетворяющая следующим условиям:
\begin{itemize}
\item $\xi,\xi' \in X^\bullet$, где $X\hm\subseteq {\cal X}$,
и $a\hm\in {\cal A}$;
\item если $n=0$, то $\xi'\hm=\xi$ и $a\hm=\tau$, иначе
существует последовательность
\begin{equation}
\label{sdfsadfsadfsa}
(\xi_0, a_1, \xi_1),\,
(\xi_1, a_2, \xi_2),\,\ldots ,
(\xi_{n-1}, a_n, \xi_n),
\end{equation}
где
$\xi_0=\xi$, $\xi_n\hm=\xi'$,
$\forall\,i\hm=1,\ldots, n$ $(\xi_{i-1}, a_i, \xi_i)$~---
реализация~$o_i$ и $a\hm=\tau$,
если все~$a_i$ в~(\ref{sdfsadfsadfsa})
равны~$\tau$, иначе $a$ совпадает с тем из этих~$a_i$, который отличен от~$\tau$.
\end{itemize}

\subsection{Реализации переходов}
%\label{realper}

Пусть задан процесс~$P$ вида~(\ref{process}) и переход $t\hm\in T_P$.

{\bf Реализацией перехода~$t$}
называется  тройка  $(\xi_1,a,\xi_2)$, где
$\xi_1, \xi_2\hm\in X_P^\bullet$ и $a\hm\in {\cal A}$, такая что
$\langle{t}\rangle^{\xi_1}\hm=1$ и $(\xi_1\cdot\left(\mathrm{at}_P:=\mathrm{end}\left(t\right)\right),a,\xi_2)$
является реализацией $[O_t]$.

Верны следующие свойства.
\begin{enumerate}[1.]
\item Если переход $t$~--- внутренний или вывод,
то для каждого $\xi\hm\in X_P^\bullet$ такого, что $\langle{t}\rangle^\xi\hm=1$,
существуют единственные $\xi'\hm\in X_P^\bullet$ и
$a\hm\in {\cal A}$ такие, что
 $(\xi, a, \xi')$~--- реализация~$t$.
Будем обозначать такое~$\xi'$  записью $\deyc{\xi}{t}$.

\item Если  переход $t$~--- ввод, то для каждого $\xi\hm\in X_P^\bullet$
такого, что $\langle{t}\rangle^\xi \hm= 1$, и каждого $d\hm\in {\cal D}$
существует единственное $\xi'\hm\in X_P^\bullet$ такое, что
 $(\xi, N_t?d, \xi')$~--- реализация~$t$.
Будем обозначать такое  $\xi'$ за\-писью $\deyc{\xi}{t^d}$.
\end{enumerate}

\subsection{Реализации процессов} %\label{defpr}

{\bf Реализацией процесса~$P$} называется граф~$P^r$, имеющий следующие компоненты:
\begin{itemize}
\item вершинами графа~$P^r$ являются означивания из~$X_P^\bullet$, а также еще одна
вершина, обо\-зна\-ча\-емая записью~$P^{0}$;
\item для  каждой реализации $(\xi_1, a, \xi_2)$ ка\-ко\-го-ли\-бо перехода из~$T_P$
граф~$P^r$ имеет ребро из~$\xi_1$ в~$\xi_2$ с меткой~$a$;
\item для каждого  $\xi \hm\in X_P^\bullet$ такого, что
$\langle{P}\rangle^{\xi} \hm= 1$, и каж\-до\-го ребра  графа~$P^r$
из~$\xi$ в~$\xi'$ с меткой~$a$ данный  граф содержит ребро из~$P^0$
в~$\xi'$ с меткой~$a$.
\end{itemize}

Будем обозначать множества вершин  и ребер графа~$P^r$
записями~$S_{P}^r$  и~$T_{P}^r$ соответственно.
Также будем использовать следующие обозначения:
для любой пары $v, v'$ вершин графа~$P^r$
\begin{itemize}
\item запись $v_1\ra{a} v_2$ обозначает ребро из~$v_1$ в~$v_2$ с меткой~$a$;
\item запись $v\ra{\tau^*} v'$ означает, что $v\hm=v'$ или
$\exists\,v_0, v_1, \ldots, v_n:$ $\forall\,i\hm=1,\ldots, n$
граф~$P^r$ содержит ребро $v_{i-1}\ra{\tau}v_i$ и
$v_0 \hm= v$, $v_n \hm= v'$;
\item запись $v\ral{\tau^*a\tau^*} v'$ (где $a\hm\in {\cal A}$)
означает, что $\exists\,v_1, v_2:$ граф~$P^r$  содержит ребро $v_1\ra{a}v_2$
и $v\ral{\tau^*} v_1$, $v_2\ral{\tau^*} v'$.
\end{itemize}

\section{Наблюдаемая эквивалентность процессов}

\subsection{Понятие наблюдаемой эквивалентности процессов} %\label{definition}

Будем называть процессы $P_1$ и $P_2$ {\bf наблюдаемо эквивалентными}, если
$P^r_1$ и $P^r_2$ наблюдаемо эквивалентны в смысле Милнера~\cite{1-mir},
т.\,е.\ существует $\mu\hm\subseteq S_{P_1}^r \hm\times S_{P_2}^r$,
удовлетворяющее следующим условиям:
\begin{enumerate}[($i$)]
\item $(P_1^0, P_2^0)\in \mu$;
\item  если $(v_1, v_2)\in \mu$ и
$v_1\ra{\tau}v'_1$, то
$$
\exists\,v'_2: v_2\ra{\tau^*}v'_2,\;
(v'_1, v'_2)\in \mu\,;
$$
если $(v_1, v_2)\hm\in \mu$ и $v_2\ra{\tau}v'_2$,
то
$$
\exists\,v'_1: v_1\ra{\tau^*}v'_1,\; (v'_1, v'_2)\hm\in \mu\,;
$$
\item  если $(v_1, v_2)\in \mu$ и $v_1\ra{a}v'_1$,
где $a\hm\neq \tau$, то
$$
\exists\,v'_2: v_2\ral{\tau^*a\tau^*}v'_2,\;
(v'_1, v'_2)\in \mu\,;
$$
если $(v_1, v_2)\hm\in \mu$ и $v_2\ra{a}v'_2$,
где $a\hm\neq \tau$, то
$$
\exists\,v'_1: v_1\ral{\tau^*a\tau^*}v'_1,\;
(v'_1, v'_2)\in \mu\,.
$$

\end{enumerate}

Большинство проблем, связанных с верификацией дискретных систем,
может быть сведено к проблеме доказательства наблюдаемой эквивалентности двух процессов.
Как правило, первый из этих процессов является моделью анализируемой системы,
а второй~--- моделью ка\-ко\-го-ли\-бо свойства
этой системы. В разд.~7 будет рассмотрен пример доказательства
наблюдаемой эквивалентности двух процессов, первый из которых является моделью протокола
скользящего окна, а второй~--- моделью процесса, изображающего внешнее поведение
этого протокола.

\subsection{Метод доказательства наблюдаемой
эквивалентности процессов}
%\label{theor}

Один из возможных методов доказательства
наблюда\-емой эквивалентности двух процессов
основан на нижеследующей теореме.
Для формулировки и доказательства
этой теоремы  введем вспомогательные понятия  и обозначения.
\begin{enumerate}[1.]
\item  Пусть задан процесс~$P$ и пара состояний
$s,s'\hm\in S_P$.

{\bf Составной переход (СП)} из~$s$ в $s'$~--- это последовательность~$T$
переходов процесса~$P$ вида
\begin{equation}
\hspace*{-3mm}s=s_0\ra{O_1}s_1\,;\enskip
s_1\ra{O_2}s_2\,;\ldots ;
s_{n-1}\ra{O_n}s_n=s' \!\!
\label{l7}
\end{equation}
такая что среди $O_1,\ldots, O_n$ не более одного
оператора ввода или вывода и
определены все конкатенации в выражении
\begin{equation}
\label{sdsdfsdfs444}
(\cdots(O_1\cdot O_2)\cdots)\cdot O_n\,.
\end{equation}

Последовательность~(\ref{l7}) может быть пустой, в~этом случае $s\hm=s'$.

Если СП $T$ не пуст и имеет вид~(\ref{l7}), то
запись $O_T$ обозначает значение выражения~(\ref{sdsdfsdfs444}), а  если $T$ пуст,
то $O_T\eam [\,]$.

Будем использовать для СП те же понятия и обозначения, что и для
обычных переходов ($\mathrm{start}\left(T\right)$,
$\mathrm{end}\left(T\right)$, $N_T$  и~т.\,п.). Будем
называть СП~$T$ вводом, выводом или внутренним, если $O_T$~---
оператор ввода, вывода или внутренний соответственно.

Как и для обычных переходов, для СП можно ввести понятие реализации,
которое будет обладать свойствами, аналогичными свойствам,
изложенным в п.~4.2, в частности:
\begin{itemize}
\item[(a)] если СП $T$~--- внутренний или вывод, то для каждого
$\xi\hm\in X_P^\bullet$ такого, что $\langle{T}\rangle^\xi\hm=1$, существуют единственные $\xi'\hm\in X_P^\bullet$ и
$a\hm\in {\cal A}$ такие, что  $(\xi, a, \xi')$~--- реализация~$T$.
Будем обозначать такое~$\xi'$  записью $\deyc{\xi}{T}$;
\item[(б)] если  СП $T$~--- ввод, то для каждого $\xi\in X_P^\bullet$
такого, что $\langle{T}\rangle^\xi \hm= 1$, и каждого $d\hm\in {\cal D}$ существует
единственное $\xi'\hm\in X_P^\bullet$ такое, что
 $(\xi, N_T?d, \xi')$~--- реализация~$T$. Будем обозначать такое~ $\xi'$
 записью $\deyc{\xi}{T^d}$.
\end{itemize}

\item Если $b$ и $b'$~--- формулы, то запись $b\hm\leq b'$
является сокращенной записью утверждения о том, что формула $b\hm\to b'$ истинна.

\item Если $O_1$ и $O_2$~--- операторы и $b\hm \in {\cal B}$, то
запись $\deyc{(O_1,O_2)}{b}$ обозначает формулу, определяемую
излагаемым ниже рекурсивным определением,
в котором записи вида $O\setminus o$ и $o(b)$ обозначают оператор
и формулу соответственно, определяемые так же, как в п.~2.3.

Пусть $[O_1]=o_1,\ldots, o_n$ и
$[O_2]\hm=o'_1,\ldots, o'_m$, тогда
формула
\begin{equation}
\label{fgvfdsgdsfgdsfgd}
\deyc{(O_1,O_2)}{b}
\end{equation}
определяется следующим образом:
\begin{itemize}
\item[(a)] $\langle{O_1}\rangle\wedge \langle{O_2}\rangle\wedge b$, если $n\hm=m\hm=0$;
\item[(б)] $\deyc{(O_1\setminus o_n, O_2)}{o_n(b)}$, если
$o_n$~--- присваивание;
\item[(в)] $\deyc{(O_1, O_2\setminus o'_m)}{o'_m(b)}$, если
$o'_m$~--- присваивание;
\item[(г)] $\deyc{((O_1\setminus o_n), (O_2\setminus o'_m))}
{b(z/x,z/y)}$,
если $o_n\hm=\alpha?x$, $o'_m\hm=\alpha?y$ и
$b(z/x,z/y)$~--- формула, получаемая из~$b$ заменой всех вхождений~$x$ и~$y$ на новую
переменную~$z$ (не входящую в~$O_1$, $O_2$ и~$b$);
\item[(д)] $\deyc{((O_1\setminus o_n), (O_2\setminus o'_m))} {((e_1=e_2)\wedge b)}$,
если $o_n\hm=\alpha!e_1$ и $o'_m\hm=\alpha!e_2$;
\item[(е)] $\bot$ в  остальных случаях.
\end{itemize}
\end{enumerate}


\noindent
\textbf{Теорема~1}.\
\textit{Пусть $P_i\hm=(S_{P_i}, s^0_{P_i}, T_{P_i}, \langle{P_i}\rangle)$
$(i\hm=1,2)$~--- процессы, причем}
$S_{P_1} \cap S_{P_2} \hm= \emptyset$
и $X_{P_1} \cap$\linebreak $\cap X_{P_2} \hm= \emptyset$.
Процессы~$P_1$ и~$P_2$
\textit{наблюдаемо эквивалентны, если существует совокупность}
$\{b_{s_1s_2}\mid s_i\in$\linebreak $\in S_{P_i}$ $(i\hm=1,2)\}$
\textit{формул с переменными из}
$(X_{P_1}\hm\cup X_{P_2})\setminus\{\mathrm{at}_{P_1}, \mathrm{at}_{P_2}\}$,
\textit{обладающих следующими свойствами}:
\begin{enumerate}[($i$)]
\item $\langle{P_1}\rangle\wedge \langle{P_2}\rangle\leq b_{s^0_{P_1}s^0_{P_2}}$;
\item для  каждого перехода $s_1\ra{O}s'_1$    процесса~$P_1$ и
каждого состояния $s_2\hm\in S_{P_2}$    существует  совокупность СП процесса~$P_2$,
имеющая вид $\{s_2\ra{T_i}s_2^i\mid i\in\Im\}$
и такая, что
$$
b_{s_1s_2} \wedge \; \langle{O}\rangle \leq
\mathop{\vee}\limits_{i\in\Im} \deyc{(O, O_{T_i})} {b_{s'_1s^{i}_2}};
$$
\item свойство, симметричное предыдущему свойству:
для  каждого перехода $s_2\ra{O}s'_2$
   процесса $P_2$ и каждого состояния $s_1\hm\in S_{P_1}$
   существует    совокупность    СП процесса~$P_1$, имеющая вид
$\{s_1\ra{T_i}s_1^i\mid i\hm\in\Im\}$ и такая, что
$$
b_{s_1s_2} \wedge \; \langle{O}\rangle \leq
\mathop{\vee}\limits_{i\in\Im} \deyc{(O_{T_i}, O)} {b_{s^{i}_1s'_2}}\,.
$$
\end{enumerate}

\noindent
Д\,о\,к\,а\,з\,а\,т\,е\,л\,ь\,с\,т\,в\,о\,.\ \
Поскольку $X_{P_1}\cap X_{P_2}\hm=\emptyset$,
то существует естественная биекция между
$X_{P_1}^\bullet \times X_{P_2}^\bullet$
и $(X_{P_1}\cup X_{P_2})^\bullet$.
Ниже будем отождествлять эти два множества.

Определим  отношение $\mu\hm\subseteq S_{P_1}^r \hm\times S_{P_2}^r$:
\begin{multline*}
\mu\eam \left\{(\xi_1, \xi_2) \in X_{P_1}^\bullet \times X_{P_2}^\bullet
\mid b_{at_{P_1}^{\xi_1}at_{P_2}^{\xi_2}}^{(\xi_1,\xi_2)}=1
\right\}\cup{}\\
{}\cup\left\{(P_1^0, P_2^0)\right\}\,.
\end{multline*}

Докажем, что $\mu$ удовлетворяет условиям из п.~5.1.

Первое из этих условий непосредственно следует из определения~$\mu$.

Докажем второе и третье условия.

Пусть $(v_1, v_2)\in \mu$ и $v_1\ra{a}v'_1$.
Требуется доказать, что
\begin{equation}
\label{fdgd4444}
\exists\,v'_2: v_2\ra{a_\tau}v'_2,\,
(v'_1, v'_2)\in \mu\,,
\end{equation}
где
$$
a_\tau=
\begin{cases}
\tau^*,&\ \mbox{ если } a=\tau\,,\\
\tau^*a\tau^*,&\ \mbox{ если } a\neq\tau\,.
\end{cases}
$$

Изложим доказательство лишь для случая
$v_1\hm=P^0_1$ (в случае $v_1\hm\neq P^0_1$ доказательство выглядит аналогично).

Если $v_1=P^0_1$, то $v_2\hm=P^0_2$ и согласно определению~$P_1^r$
(см.\ п.~4.3) $\exists\,\xi_1\hm\in X_{P_1}^\bullet:
\langle{P_1}\rangle^{\xi_1}\hm=1$ и $P_1^r$ содержит ребро
$\xi_1\ra{a}\xi'_1\hm=v'_1$, т.\,е.\ $(\xi_1, a, \xi'_1)$~--- реализация
перехода~$t$ вида $s_{P_1}^0\ra{O_1}s'_1$ из~$T_{P_1}$.

Согласно п.~($ii$) в формулировке теоремы, существует совокупность
$\{s_{P_2}^0\ra{T_i}s_2^i\mid i\hm\in\Im\}$
   СП процесса~$P_2$ такая, что
\begin{equation}
\label{fdgdsfgfdsgr4r}
b_{s_{P_1}^0s_{P_2}^0} \wedge \; \langle{O_1}\rangle
\leq \mathop{\vee}\limits_{i\in\Im} \deyc{(O_1, O_{T_i})}
{b_{s'_1s^{i}_2}}\,.
\end{equation}

Поскольку $\langle{P_2}\rangle\neq \bot$, то $\exists\,\xi_2\hm\in X_{P_2}^\bullet$:
$\langle{P_2}\rangle^{\xi_2} \hm= 1$, поэтому
\begin{multline}
\label{fdgdsfgfdsgr4r1}
1=\langle{P_1}\rangle^{\xi_1} \wedge\langle{P_2}\rangle^{\xi_2}={}\\
{}=
(\langle{P_1}\rangle\wedge \langle{P_2}\rangle)^{(\xi_1,\xi_2)}\leq
b_{s^0_{P_1}s^0_{P_2}}^{(\xi_1,\xi_2)}
\end{multline}
(последнее неравенство верно на основании свойства~($i$) в формулировке теоремы).

Согласно определению реализации перехода
верно равенство $\langle{O_1}\rangle^{\xi_1}\hm=1$,
из которого, а также из~(\ref{fdgdsfgfdsgr4r}) и~(\ref{fdgdsfgfdsgr4r1})
следует, что для некоторого $i\hm\in \Im$ верно равенство
\begin{equation}
\label{s44dfsdfsd}
\left(\deyc{(O_1, O_{T_i})}
{b_{s'_1s^{i}_2}}\right)^{(\xi_1,\xi_2)} = 1\,,
\end{equation}
которое в случае $a\hm=\alpha?d$ следует понимать в следующем
смысле: для каждого означивания
$\xi\in (X_{P_1}\sqcup X_{P_2}\sqcup \{z\})^\bullet$ (где $z$~--- переменная,
упомянутая в п.~3г определения из п.~5.2, можно считать, что
$z\hm\not\in (X_{P_1}\sqcup X_{P_2})$),
совпадающего с $\xi_i$ на $X_{P_i}\;\;(i=1,2)$, верно равенство:
$$
\left(\deyc{(O_1, O_{T_i})}{b_{s'_1s^{i}_2}}\right)^{\xi} = 1\,.
$$

Рассмотрим возможные виды~$a$.

\smallskip

1.\ $a=\tau$. В~этом случае $O_1$~--- внутренний оператор и
\begin{equation}
\label{sdfsd55}
\left (\deyc{(O_1, O_{T_i})}{b_{s'_1s^{i}_2}}\right)^{(\xi_1,\xi_2)} =
{b_{s'_1s^{i}_2}}^{(\xi_1\cdot O_1,\xi_2\cdot O_{T_i})}\,.
\end{equation}

Равенство~(\ref{sdfsd55}) является аналогом
равенства, приведенного в последнем
абзаце п.~2.3, и доказывается индукцией по общему числу АО в $[O_1]$
и $[O_2]$.

Из~(\ref{s44dfsdfsd}) и~(\ref{sdfsd55}) следует, что
\begin{equation}
\label{sdfsd5345}
{b_{s'_1s^{i}_2}}^{(\xi_1\cdot O_1,\xi_2\cdot O_{T_i})}=1\,.
\end{equation}

По определению~$\mu$ и~$\xi_2$ доказываемое соотношение~(\ref{fdgd4444})
в рассматриваемом случае ($v_1\hm=P^0_1$) следует из соотношения:
\begin{equation}
\label{dfgfdgdrr}
\exists\,\xi'_2: \xi_2 \ra{\tau^*}\xi'_2,\;
b_{\mathrm{at}_{P_1}^{\xi'_1}\mathrm{at}_{P_2}^{\xi'_2}}^{(\xi'_1,\xi'_2)}=1\,.
\end{equation}

Определим $\xi'_2\eam (\xi_2\cdot (\mathrm{at}_{P_2}:=s_2^i))\cdot O_{T_i}$.
Поскольку $\mathrm{at}_{P_1}^{\xi'_1}\hm= s'_1$ и
$\xi'_1\hm=(\xi_1\cdot(\mathrm{at}_{P_1}:=s'_1))\cdot O_1$,
то (\ref{dfgfdgdrr}) следует из соотношений
\begin{equation}
\label{dfgfd2gdrr}
\xi_2 \ra{\tau^*}(\xi_2\cdot (\mathrm{at}_{P_2}:=
s_2^i))\cdot O_{T_i}\,;\end{equation}
\begin{equation}
\label{dfgfd2gdr3r}
b_{s'_1s^i_2}^{((\xi_1\cdot(\mathrm{at}_{P_1}:=s'_1))\cdot O_1,(\xi_2\cdot
(\mathrm{at}_{P_2}:=s_2^i))\cdot O_{T_i})}=1\,.
\end{equation}

Соотношение~(\ref{dfgfd2gdrr}) следует из определений понятия СП и конкатенации операторов,
а также из соотношений $\mathrm{at}_{P_2}^{\xi_2}\hm=s_{P_2}^0$
и $\langle{O_{T_i}}\rangle^{\xi_2}\hm=1$.
Первое из этих соотношений является следствием равенства $\langle{P_2}\rangle^{\xi_2}\hm=1$,
а второе обосновывается следующим образом.
Из определения формул вида $(O_1,O_2)\cdot b$
следует, что соотношение~(\ref{s44dfsdfsd}) можно переписать в виде:
\begin{equation}
\label{sfdgfdsg4455}
\left(\langle{O_1}\rangle\wedge \langle{O_{T_i}}\rangle
\wedge b \right)^{(\xi_1,\xi_2)} = 1\,,
\end{equation}
где $b$~--- некоторая формула.
Поскольку $X_{P_1}\cap X_{P_2}\hm=\emptyset$,
то из~(\ref{sfdgfdsg4455}) следует искомое
соотношение $\langle{O_{T_i}}\rangle^{\xi_2}\hm=1$.

Соотношение~(\ref{dfgfd2gdr3r}) следует из~(\ref{sdfsd5345}) и из предположения о том, что
 $\mathrm{at}_{P_1}$ и $\mathrm{at}_{P_2}$ не входят в $b_{s'_1s^i_2}$,
$O_1$ и~$O_{T_i}$.

\smallskip

2.\  $a=\alpha?d$. В~этом случае
$O_1$~--- оператор ввода и из~(\ref{s44dfsdfsd}) следует, что
$O_{T_i}$~--- тоже оператор ввода и $N_{O_{T_i}} \hm= N_{O_1}=\alpha$.

Используя обозначение, введенное в конце п.~4.2, можно написать, что
$\xi'_1 \hm= \xi_1\cdot t^d$.


Определим $\xi'_2\eam \xi_2\cdot T_i^d$.
Нетрудно доказать, что $\xi_2 \ra{\tau^*a \tau^*}\xi'_2$, и доказываемое
соотношение~(\ref{fdgd4444}) следует из равенства
\begin{equation}
\label{1dfgf33dgdrr}
b_{s'_1s^i_2}^{(\xi_1\cdot t^d,\xi_2\cdot T_i^d)}=1\,,
\end{equation}
 которое обосновывается следующим образом.

В рассматриваемом случае~$O_1$ и~$O_{T_i}$ можно представить как
конкатенации вида
$$
O_1=(O'_1\cdot[\alpha?x])\cdot O''_1\,;\enskip
O_{T_i} = (O'_{T_i}\cdot[\alpha?y])\cdot O''_{T_i}\,.
$$
Из определения формул вида~(\ref{fgvfdsgdsfgdsfgd})  следует, что
 \begin{multline}
\deyc{(O_1, O_{T_i})}{b_{s'_1s^{i}_2}}={}\\
{}=
\deyc{\left((O'_1\cdot[\alpha?x])\cdot O''_1,
(O'_{T_i}\cdot[\alpha?y])\cdot
O''_{T_i}\right)}{b_{s'_1s^{i}_2}}={}\\
{}=
\deyc{\left(O'_1\cdot[\alpha?x],
O'_{T_i}\cdot[\alpha?y]
\right)}{\left((O''_1,O''_{T_i})\cdot b_{s'_1s^{i}_2}\right)}
={}\\
\!\!{}=
\deyc{(O'_1, O'_{T_i} )}
\left(\left(\left(O''_1,O''_{T_i}\right)\cdot b_{s'_1s^{i}_2}\right)
\left(\fr{z}{x},\fr{z}{y}\right)\right).\!
 \label{1s44dfsdfsd11}
\end{multline}

Из~(\ref{s44dfsdfsd}) и~(\ref{1s44dfsdfsd11}) следует, что верно равенство
$$
\left(\left(\left(O''_1,O''_{T_i}\right)\cdot b_{s'_1s^{i}_2}\right)
\left(\fr{z}{x},\fr{z}{y}\right)\right)^{(\xi_1\cdot O'_1,\xi_2\cdot O'_{T_i})} = 1\,,
$$
частным случаем которого является равенство
$$
\left(\left(\left(O''_1,O''_{T_i}\right)\cdot b_{s'_1s^{i}_2}\right)
\left(\fr{d}{x},\fr{d}{y}\right)\right)^{(\xi_1\cdot O'_1,\xi_2\cdot O'_{T_i})} = 1\,.$$
Последнее равенство можно переписать в виде:
$$
\left(\left(O''_1, O''_{T_i}\right)\cdot b_{s'_1s^{i}_2}
\right)^{(\xi_1\cdot O'_1\cdot (x:=d),\xi_2\cdot O'_{T_i}
\cdot (y:=d))} = 1\,,
$$
откуда следует равенство
\begin{equation}
\label{sfdgdsfsdfsdadfsdsf}
\left(b_{s'_1s^{i}_2} \right)^{(\xi_1\cdot O'_1\cdot (x:=d)\cdot
O''_1,\xi_2\cdot O'_{T_i} \cdot (y:=d)\cdot O''_{T_i})} = 1\,.
\end{equation}

Нетрудно видеть, что левая часть в~(\ref{sfdgdsfsdfsdadfsdsf})
совпадает с левой частью доказываемого равенства~(\ref{1dfgf33dgdrr}).

\smallskip

3.\ $a=\alpha!d$. В~этом случае
$O_1$~--- оператор вывода и из~(\ref{s44dfsdfsd})
следует, что $O_{T_i}$~--- тоже оператор вывода и $N_{O_{T_i}}\hm = N_{O_1}\hm=\alpha$.

Определим $\xi'_2\eam \xi_2\cdot T_i$.
Для доказательства~(\ref{fdgd4444}) достаточно доказать соотношения
\begin{align}
\xi_2 \raz{\tau^*a \tau^*} &\xi'_2\,;
\label{sdfsdfsdfsfs}\\
b_{s'_1s^i_2}^{(\xi_1\cdot t,\xi_2\cdot T_i)}&=1.
\label{11dfgf33dgdrr}
\end{align}

В~рассматриваемом случае~$O_1$ и~$O_{T_i}$ можно представить как
конкатенации вида:
\begin{align}
O_1&=(O'_1\cdot[\alpha!e_1])\cdot O''_1\,;\label{sdfsdafsad}\\
O_{T_i} &= (O'_{T_i}\cdot[\alpha!e_2])\cdot
O''_{T_i}\,.
\label{sdfsdafsad1}
\end{align}

Из определения формул вида~(\ref{fgvfdsgdsfgdsfgd})
 следует, что
\begin{multline}
\label{21s44dfsdfsd11}
\deyc{(O_1, O_{T_i})}{b_{s'_1s^{i}_2}}={}\\
{}= \deyc{\left(\left(O'_1\cdot[\alpha!e_1]\right)\cdot O''_1,
\left(O'_{T_i}\cdot[\alpha!e_2]\right)\cdot
O''_{T_i}\right)}{b_{s'_1s^{i}_2}}={}\\
{}=
\deyc{\left(O'_1\cdot[\alpha!e_1],
O'_{T_i}\cdot[\alpha!e_2]
\right)}{\left(\left(O''_1, O''_{T_i}\right)\cdot b_{s'_1s^{i}_2}\right)}
={}\\
{}=
\deyc{(O'_1, O'_{T_i} )}
\left\{ \begin{array}{c}
e_1=e_2\\
\left(O''_1,O''_{T_i}\right)\cdot b_{s'_1s^{i}_2}
\end{array}\right\}\,.
\end{multline}

Из (\ref{s44dfsdfsd}) и~(\ref{21s44dfsdfsd11}) следует, что верно равенство
$$
\left\{
\begin{array}{c}
e_1=e_2\\[3pt]
\left(O''_1,O''_{T_i}\right)\cdot b_{s'_1s^{i}_2}
\end{array}
\right\}^{(\xi_1\cdot O'_1,\xi_2\cdot O'_{T_i})} = 1\,,
$$
из которого следуют равенства
\begin{align}
\label{dfgfdsgdsf5554}
e_1^{\xi_1\cdot O'_1}&=e_2^{\xi_2\cdot O'_{T_i}}\,;
\\
\label{dfgfdsgdsf55541}
\left(\left(O''_1, O''_{T_i}\right)\cdot b_{s'_1s^{i}_2}\right)^{(\xi_1\cdot O'_1,\xi_2\cdot O'_{T_i})}
&= 1\,.
\end{align}

По предположению, $(\xi_1, \alpha!d, \xi'_1)$ является
реализацией  перехода $s_{P_1}^0\ra{O_1}s'_1$.
Из представления~$O_1$  в виде конкатенации~(\ref{sdfsdafsad}) следует, что
$d\hm=e_1^{\xi_1\cdot O'_1}$, откуда согласно~(\ref{dfgfdsgdsf5554}) получаем равенство
$d\hm=e_2^{\xi_2\cdot O'_{T_i}}$.
Из этого равенства и из представления~$O_{T_i}$  в виде конкатенации~(\ref{sdfsdafsad1})
следует, что $(\xi_2, \alpha!d, \xi_2\cdot T_i)$ является
реализацией  СП~$T_i$.
Поскольку $\xi_2\cdot T_i\hm = \xi'_2$ и $\alpha!d\hm=a$, то, следовательно,
соотношение~(\ref{sdfsdfsdfsfs}) обосновано.

Соотношение~(\ref{11dfgf33dgdrr}) следует из~(\ref{dfgfdsgdsf55541}).

\smallskip


Условия на~$\mu$, симметричные рассмотренным условиям (т.\,е.\ вторые
части условий на~$\mu$, изложенные в пп.~($ii$) и~($iii$)
разд.~5.1, рассматриваются аналогично.\hfill$\blackbox$

\section{Упрощение процессов}
%\label{simp}

Понятие упрощения процессов предназначено для решения проблемы
понижения сложности верификации процессов.

{\bf Упрощение}
процесса~$P$ представляет собой последовательность
преобразований этого процесса, каждое из которых
производится согласно ка\-ко\-му-ли\-бо из излагаемых ниже правил.
Каждое из этих преобразований (кроме первого) производится над результатом
предыдущего преобразования.
{\bf Результатом} упрощения является результат последнего из
этих преобразований.

Правила упрощения определяются следующим образом.
Пусть задан процесс~$P$.

\smallskip

\noindent
\textbf{Правило 1 (удаление состояний).}
Если $s\hm\in S_P\setminus \{s^0_P\}$~и
\begin{itemize}
\item совокупность переходов из~$T_P$
     с концом~$s$ имеет вид
$s_1\ra{O_1}s$, $\ldots$, $s_n\ra{O_n}s$;

\item  совокупность переходов из~$T_P$
     с началом~$s$ имеет вид $s\ra{O'_1}s'_1$, $\ldots$, $s\ra{O'_m}s'_m$,
и если все эти переходы внутренние, то $\langle{O'_i}\rangle\wedge \langle{O'_j}\rangle=\bot$
при $i\hm\neq j$;

  \item $s\not\in\{s_1,\ldots,      s_n,s'_1,\ldots,s'_m\}$;

  \item  $\forall\,i=1,\ldots, n$, $\forall\,j=1,\ldots, m$
$\exists\,O_i \cdot O'_j$,
\end{itemize}
то из $P$ удаляются состояние~$s$ и все переходы, началом или концом которых
является~$s$, и добавляются переходы
\begin{equation*}
 s_i  \xrightarrow{O_i\cdot O'_j} s'_j\enskip
         (\forall\,i=1,\ldots, n,\
         \forall\,j=1,\ldots, m)\,.
         \end{equation*}

         \noindent
         \textbf{Правило 2 (склейка).}
  Если~$P$ содержит
  пару переходов вида $s_1\ra{O}s_2$,   $s_1\ra{O}s_2$
и $[O]\hm=[O']$,    то эта пара заменяется на один переход
из~$s_1$ в~$s_2$  с оператором $(\langle{O}\rangle\vee \langle{O'}\rangle)[O]$.

\smallskip

\noindent
\textbf{Правило 3 (удаление несущественных присваиваний).}
Если~$P$ содержит   присваивание $(x:=e)$, где $x\hm\not\in$\linebreak $\not\in X^s_P$,
  то данный АО удаляется из~$P$.

  \smallskip


\noindent
\textbf{Теорема~2.}
\textit{Если $P'$ является упрощением $P$,
то $P'\approx P$}.

\section{Пример: верификация протокола скользящего окна}
%\label{sec8}

В этом разделе излагается пример использования теоремы~1
для верификации протокола скользящего окна.

Протокол скользящего окна обеспечивает передачу сообщений от одного
агента другому через среду, в которой сообщения могут искажаться или
пропадать. В этом разделе рассматривается двунаправленный протокол
скользящего окна, в котором агенты могут посылать и принимать
сообщения друг от друга. Здесь не приводится детальное описание
этого протокола, его можно найти в~\cite[п.~3.4.2]{12-mir}
(протокол с возвратом на~$n$).

\subsection{Структура протокола}

Протокол скользящего окна является системой,
состоящей из нескольких взаимодействующих компонентов, в том числе
\begin{itemize}
\item  компонентов, которые осуществляют формирование, посылку, получение,
обработку сообщений (эти компоненты называются {\bf агентами}, а сообщения, посылаемые
одними агентами другим агентам, называются {\bf кадрами});
\item среды, через которую пересылаются кадры (эта среда называется
{\bf каналом}).
\end{itemize}
Связь между этими компонентами представляется
в виде потокового графа (рис.~1).

\vspace*{8pt}

\noindent
\begin{center}  %fig1
\mbox{%
\epsfxsize=75.215mm
\epsfbox{mir-1.eps}
}
  \vspace*{5pt}

{{\figurename~1}\ \ \small{Потоковый граф}}
  \end{center}

%\vspace*{8pt}

\addtocounter{figure}{1}



\subsection{Кадры}

Каждый кадр~$f$, пересылаемый ка\-ким-ли\-бо
из агентов, содержит пакет~$x$ и два числа:
\begin{enumerate}[(1)]
\item
$s \in {\bf Z}_n\eam\{0,1,\ldots, n-1\}$
   (где $n$~--- фиксированное натуральное число), $s$
ассоциировано с пакетом~$x$ и с кадром~$f$;
\item $r \in {\bf Z}_n$,
   $r$~ассоциировано с последним полученным  неискаженным кадром.
   \end{enumerate}
Для построения кадров используется
функция~$\varphi$: каждый кадр имеет вид $\varphi(x, s, r)$.

Для извлечения компонентов~$x$, $s$, $r$
из кадра $\varphi(x, s, r)$ используются функции
info, seq и ack, эти функции имеют следующие свойства:
\begin{gather*}
\mathrm{info}\left(\varphi(x, s, r)\right) = x\,;
\enskip
\mathrm{seq}\left(\varphi(x, s, r)\right) = s\,;\\
% \enskip
\mathrm{ack}\left(\varphi(x, s, r)\right) = r\,.
 \end{gather*}

\vspace*{-12pt}

\subsection{Окно}

Агент
содержит среди своих переменных массив $x[n]$, в компонентах которого могут содержаться отправленные,
но еще не подтвержденные пакеты. Совокупность компонентов массива~$x$,
в которых содержатся такие пакеты в текущий момент времени,
называется {\bf окном}.

С окном связаны три переменных этого агента:
$b$ (нижняя граница окна);
$s$ (верхняя граница окна);
$w$ (количество пакетов в окне).
Значения переменных~$b$, $s$ и~$w$ принадлежат множеству~${\bf Z}_n$.
В начальный момент времени значения переменных~$b$, $s$ и~$w$ равны~0.

 В~любой момент времени окно может быть пус\-тым  (если  $b \hm= s$) или не пустым
(если $b \hm\neq s$).
В~последнем случае окно состоит из элементов массива~$x$
с индексами из  $[b, s[$, где  $[b, s[$
обозначает множество
\begin{itemize}
\item $\{b, b + 1, \ldots, s-1\}$, если $b \hm< s$\,;
\item $\{b, b + 1, \ldots, n\} \cup \{0, 1, \ldots, s -1\}$,
   если $s \hm< b$.
\end{itemize}

Добавление нового пакета к окну происходит путем выполнения
следующих действий: данный пакет записывается в компоненту $x[s]$,
$s$ увеличивается на~1 по модулю~$n$ (т.\,е.\ новое значение~$s$
полагается равным $s\hm+1$, если $s\hm < n\hm-1$, и 0, если $s\hm = n-1$) и  $w$
увеличивается на~1. Удаление пакета из окна происходит путем
выполнения следующих действий: $b$ уменьшается на~1 по модулю~$n$,
$w$ уменьшается на~1 (т.\,е.\ удаляется тот пакет, номер которого
равен нижней границе окна).

Если агент получает кадр, третья компонента $r$ которого  (т.\,е.\
номер подтверждения) такова, что $r \in [b, s[$, то все пакеты в
окне с номерами из $[b, r[$ рассматриваются как подтвержденные и
удаляются из окна (даже если их подтверждения не получены).

\begin{figure*}[b] %fig2
\vspace*{1pt}
\begin{center}
\mbox{%
\epsfxsize=124.723mm
\epsfbox{mir-2.eps}
}
\end{center}
\vspace*{-9pt}
\Caption{Блок-схема}
\end{figure*}

\vspace*{-4pt}

\subsection{Таймеры}

Каждая компонента $x[i]$  массива~$x$ связана с соответствующим таймером,
который определяет продолжительность ожидания подтверждения от другого агента
получения им пакета, содержащегося в компоненте $x[i]$.
Совокупность этих таймеров рассматривается как процесс Timer, который имеет массив
$t [n]$ булевых переменных. Процесс Timer имеет одно состояние и переходы,
помеченные следующими операторами:
\begin{itemize}
\item $[\mathrm{start}?i , t\,[i]:=1]$;
\item $[\mathrm{stop}?i,\; t\,[i]:=0]$;
\item $(t\,[j]=1)[ \mathrm{timeout}\,!\,j, t\,[j]:=0]$,
где $j \hm= 0,\ldots$\linebreak $\ldots , n-1$.
\end{itemize}

Предусловие имеет вид $t \hm= (0,\ldots,0)$.

Если агент получает объект с именем timeout от таймера, то этот агент посылает
еще раз все пакеты из своего окна.

\vspace*{-4pt}

\subsection{Агенты}

Поведение обоих агентов описывается
одним и тем же процессом,
сочетающим функции отправителя и получателя.
Это поведение представляется блок-схе\-мой (рис.~2),
где
\begin{itemize}
\item    $\forall\,i\in \{0,n-2\}\;\;i\modp{n}1\eam
     i{+}1$ и $(n-1)\modp{n}1 \eam 0$,
\item   send обозначает список АО
   $$
   \begin{pmatrix}
   C\,! \,\varphi (x[s], s,
   r\modm{n}1)\\[2pt]
   \mathrm{start}\;!\;s\\[2pt]
   s:=s\modp{n}1
   \end{pmatrix}\,;
   $$
\item    $\forall\,i,j\hm\in \{0,n-1\}\;\;i\modm{n}j\eam
     i{-}j$, если $i{-}j \hm\in  \{0,n-1\}$, и
$n+i{-}j$ иначе;
\item символ $*$ обозначает искаженное сообщение,
\item значение переменной enable равно~1, если агент
имеет возможность получать новые пакеты от сетевого
уровня (т.\,е.\ $w \hm< n \hm- 1$), и~0 иначе.
\end{itemize}


Процессы Agent$_1$ и Agent$_2$ получаются путем несложного преобразования
этой блок-схе\-мы с добавлением соответствующего
индекса (1 или~2) к их переменным и именам.

\vspace*{-6pt}

\subsection{Спецификация}

Внешние действия описанного выше протокола (т.\,е.\ действия, которые
связаны со взаимодействием с сетевым уровнем) имеют вид In$_1?d$,
In$_2?d$, Out$_1!d$ и Out$_2!d$. Предположим, что учитываются
только внешние действия In$_1?d$ и Out$_2!d$ и игнорируются
другие внешние действия (т.\,е.\ рассматривается передача только в
одном направлении~--- слева направо). Докажем, что такое поведение
эквивалентно поведению процесса $B_{n-1}$, который называется
<<буфер, вмещающий не более $n-1$ кадров>> и определяется следующим
образом:
\begin{itemize}
\item переменными $B_{n-1}$ являются\\[-14pt]
\begin{itemize}
\item массив
$(x[0],\ldots, x[n-1])$, тип элементов которого совпадает с типом
кадров протокола;\\[-14pt]
\item переменные $r$, $s$ и $u$, значения которых
принадлежат ${\mathbf Z}_n$ и имеют следующий смысл: в~каж\-дый момент времени\\[-14pt]
\begin{itemize}
\item  значение~$u$ равно числу кадров, содержащихся в
буфере;\\[-14pt]
\item  значения  $r$ и $s$ могут быть интерпретированы как
нижняя и верхняя границы той части массива~$x$, где содержатся
полученные кадры, которые пока еще не были выведены из буфера;\\[-14pt]
\end{itemize}
\end{itemize}
\item $B_{n-1}$ имеет одно состояние и два перехода с метками

\noindent
   \begin{gather*}
   (u<n-1)\,[In?x[s],\;s:=s\modp{n}1,\;u:=u+1]\,;\\
   (u>0)\;[\mathrm{Out}\,!\,x[r],\;r:=r\modp{n}1,\;u:=u-1]\,;
\end{gather*}

\vspace*{-6pt}

\item  предусловие имеет вид $r \hm= s \hm= u \hm= 0$.
\end{itemize}

\vspace*{-6pt}

\subsection{Процесс, соответствующий протоколу}

Процесс, описывающий поведение этого протокола с учетом указанного выше ограничения
(при котором игнорируются действия вида In$_2 ? d$ и Out$_1 ! d$),
определяется как параллельная композиция процессов, соответствующих компонентам
этого протокола, с удалением АО,
относящихся к игнорируемым взаимодействиям.

Определение параллельной композиции процессов будет изложено
лишь для пары процессов (параллельная композиция
произвольного числа процессов определяется аналогично).

Пусть $P_1$ и $P_2$~--- процессы, такие что $S_1\cap S_2=\emptyset$
и $X_{P_1}\cap X_{P_2}\hm=\emptyset$.
{\bf Параллельной композицией} процессов~$P_1$ и~$P_2$
называется процесс $P\hm=(S_P, s^0_P,  T_P, I_P)$,  определяемый следующим образом:
$$
S_P \eam S_1\times S_2\,;\enskip
s^0_P\eam (s^0_1, s^0_2)\,,\enskip
I_P\eam I_1\wedge I_2\,,
$$
и $T_P$ состоит из следующих переходов:
\begin{itemize}
\item для каждого перехода $s_1\ra{O}s'_1$
процесса~$P_1$ и каждого состояния~$s$ процесса~$P_2$
процесс~$P$ содержит переход $(s_1,s)\ra{O}(s'_1,s)$;

\item для каждого перехода $s_2\ra{O}s'_2$
процесса~$P_2$ и каждого состояния~$s$ процесса~$P_1$
процесс~$P$ содержит переход $(s,s_2)\ra{O}(s,s'_2)$;

\item для каждой пары переходов вида
$$
\left\{ \begin{array}{l}
s_1\ra{O_1}s'_1\in T_{P_1}\,;\\[9pt]
s_2\ra{O_2}s'_2\in T_{P_2}\,,\end{array}
\right.
$$
где один из операторов $O_1$, $O_2$ имеет вид $O'_1\cdot[\alpha?x]\cdot O''_1$,
а другой~--- $O'_2\cdot [\alpha!e]\cdot O''_2$,
 $P$ имеет переход $(s_1,s_2)\ra{O}(s'_1,s'_2)$, где
$\langle{O}\rangle \hm= \langle{O_1}\rangle\wedge\langle{O_2}\rangle$ и
$$
[O]= O'_1\cdot O'_2\cdot [x:=e]\cdot O''_1\cdot O''_2\,.
$$
\end{itemize}

\vspace*{-8pt}

\subsection{Верификация}

С использованием упрощающих преобразований,
описанных в разд.~6, можно преобразовать
процесс, соответствующий протоколу,
в процесс~$P$ с одним состоянием и переходами, помеченными следующими операторами:
\begin{itemize}
\item $(w<n-1)\;[\mathrm{In}?x[s], \; M_1:=M_1 \cdot
\varphi(x[s], s, \ldots)$, $s:=s\modp{n}1, \;w:=w+1]$;

\columnbreak

\item $(M_1\neq \varepsilon)\wedge
\left(\mathrm{seq}\left(\hat M_1\right)=r\right)$ $\left[
\vphantom{\modp{n}}
\mathrm{Out}\,!\,\mathrm{info}\left(
\hat M_1\right)\right.$,\linebreak
$\left. r:=r\modp{n}1,\; M_1:=M_1'\right]$;
\item $(M_2\neq \varepsilon)\wedge\left(\mathrm{ack}\left (\hat M_2\right)
\in [b, s[ \right)\;\left[
\vphantom{\left(\hat M_2\right)\modp{n}1}
b:=\right.$\linebreak $:=\;\mathrm{ack} \left(\hat M_2\right)\modp{n}1$,
$\left.w:=s\modm{n}b,\; M_2:=M_2'\right]$;
\item $[M_1:=
   M_1\cdot \varphi(x[b], b,\ldots)
   ,\ldots\; ,
   M_1:=M_1\cdot$\linebreak $\cdot\;\varphi(x[s\modm{n}1], s\modm{n}1,
   \ldots)]$;
\item $(M_1\neq \varepsilon)\;[M_1:=M'_1]$;
\item $(M_2\neq \varepsilon)\;[M_2:=M'_2]$;
\item $[M_2:=  M_2\cdot \varphi(\ldots, \ldots, r\modm{n}1)]$,
\end{itemize}
где многоточия обозначают те компоненты термов,  которые являются
несущественными, и символы~$M_i$, $\hat M_i$, $M'_i$, $\cdot$ и~$\varepsilon$
имеют следующий смысл:
\begin{itemize}
\item $M_1$ и $M_2$~--- переменные процесса Channel,  значения этих переменных
являются списками кад\-ров, полученных процессом Channel
($M_i$ содержит кад\-ры, полученные от агента Agent$_i$),
каждый полученный кадр добавляется в конец соответствующего списка;
\item $\hat M_i\;(i=1,2)$~--- терм, значение которого равно первому
компоненту списка~$M_i$;
\item $M'_i\;(i=1,2)$~--- терм, значение которого равно
списку~$M_i$, из которого удален первый элемент;
\item $\cdot$~--- функция добавления кад\-ра в конец списка;
\item $\varepsilon$~--- константа, значением которой является пус\-той список.
\end{itemize}

Для доказательства того, что процесс~$P$ наблюдаемо эквивалентен
процессу~$B_{n-1}$, определим формулу $b_{s_1s_2}$, где
$s_1$~--- единственное состояние процесса~$P$ и
$s_2$~--- единственное состояние процесса $B_{n-1}$,
как конъюнкцию следующих формул:
\begin{itemize}
\item $(M_1\neq \varepsilon)\wedge \left(\mathrm{seq}\left(\hat M\right)=r\right)
    \;\Rightarrow\;u>0$;
\item $\forall\; f\in M_1\;  \mathrm{info}\left(f\right)=x[\mathrm{seq}\,(f)]$;
\item $\forall\; f\in M_2\quad \mathrm{ack}\left(f\right)\hm\in [b\modm{n}1,r[$;
\item $[r,s[\;\subseteq \;[b,s[$;
\item $w=s\modm{n}b\leq n-1$;
\item $u=s\modm{n}r\leq w$;
\item  если значение
    $M_2$ равно $f_1\cdots f_k$,
то последовательность $\mathrm{ack}\left(f_1\right),\ldots , \mathrm{ack}\left(f_k\right)$
является монотонно возрастающей (mod~$n$) подпоследовательностью
последовательности $[b\modm{n}1,r[$
\end{itemize}
(последняя запись не является формулой, но может быть представлена в виде формулы).
Нетрудно проверить, что $b_{s_1s_2}$ удовлетворяет условиям теоремы~1,
что доказывает наблюдаемую эквивалентность процессов~$P$ и~$B_{n-1}$.\hfill$\blackbox$

%\vspace*{-6pt}

  \section{Заключение}

Понятие процесса с передачей сообщений, изложенное в настоящей работе,
может рассматриваться как формальная модель взаимодействующих нерекурсивных программ.
В статье было изложено достаточное условие наблюдаемой эквива\-лент\-ности процессов
с передачей сообщений. Следующими шагами исследований в этом направлении могут быть, например, следующие.
\begin{itemize}
\item нахождение необходимых и достаточных условий наблюдаемой эквивалентности процессов
с передачей сообщений;
\item обобщение введенного понятия до такого понятия процесса с передачей
сообщений, которое может служить формальной моделью
взаимодействующих рекурсивных программ, и на\-хож\-де\-ние необходимых и достаточных
условий наблюдаемой эквивалентности таких процессов.
\end{itemize}

%\vspace*{-6pt}

{\small\frenchspacing
{%\baselineskip=10.8pt
\addcontentsline{toc}{section}{References}
\begin{thebibliography}{99}



\bibitem{1-mir} %1
\Au{Milner~R.} A~calculus of communicating systems.
Lecture notes in computer science ser.~--- Berlin\,--\,Heidelberg\,--\,New York:
Springer-Verlag, 1980. Vol.~92. 172~p.

\bibitem{larsen} %2
\Au{Larsen~K.\,G.,  Skou~A.} Bisimulation through probabilistic
testing~// Inform. Comput., 1991. Vol.~94.
No.\,1. P.~1--28.

\bibitem{realtime} %3
\Au{Larsen K.\,G., Wang~Y.} Time-abstracted bisimulation: Implicit
specifications and decidability~// Inform.
Comput., 1997. Vol.~134. No.\,2. P.~75--101.

\bibitem{2-mir} %4
\Au{Milner~R.} Communicating and mobile systems: The\linebreak
$\pi$-calculus.~--- Cambridge: Cambridge University Press, 1999. 162~p.

\bibitem{3-mir} %5
\Au{Hoare C.\,A.\,R.} Communicating sequential processes.~---
Prentice Hall, 1985. 256~p.

\bibitem{4-mir} %6
\Au{Clarke~E.\,M., Grumberg~O., Peled~D.} Model checking.~---
MIT Press, 1999. 314~p.

\bibitem{5-mir} %7
\Au{Petri C.\,A.} Introduction to general net theory~//
Net theory and applications. Lecture notes in computer science ser.~/
Ed. W.~Brauer.~--- Berlin--Heidelberg: Springer-Verlag, 1980. Vol.~84. P.~1--19.

\bibitem{6-mir} %8
\Au{Handbook of process algebra}~/ Eds.\ J.\,A.~Bergstra,
A.~Ponse, S.\,A.~Smolka.~---  Amsterdam: North-Holland, 2001. 1357~p.

\bibitem{7-mir} %9
\Au{Brand~D., Zafiropulo~P.} On communicating finite-state machines~//
J.~ACM, 1983. Vol.~30. No.\,2. P.~323--342.

\bibitem{8-mir} %10
\Au{Floyd~R.\,W.} Assigning meaning to programs~// Mathematical
Aspects of Computer Science:  Symposium on Applied
Mathematics Proceedings~/ Ed. J.\,T.~Schwartz.~--- American Mathematical Society,
1967. Vol.~19. P.~19--32.

\bibitem{12-mir} %11
\Au{Tanenbaum~A.} Computer networks.~--- 4th ed.~---
Prentice Hall, 2002. 674~p.

\bibitem{9-mir} %12
\Au{Badban~B., Fokkink~W.\,J., van de Pol~J.\,C.}
 Mechanical verification of a two-way sliding window protocol
 (full version including proofs).~--- Twente: University of Twente,
Centre for Telematics and Information Technology, 2008.
Internal Report TR-CTIT-08-45. 55~p.


\bibitem{13-mir} %13
\Au{Hailpern~B.} Verifying concurrent processes using temporal
logic. Lecture notes in computer science ser.~---
Berlin--Heidelberg: Springer-Verlag,  1982. Vol.~129.
216~p.

\bibitem{14-mir} %14
\Au{Holzmann~G.} Design and validation of computer protocols.~---
Prentice Hall, 1991. 558~p.

\bibitem{15-mir} %15
\Au{Holzmann~G.} The model checker Spin~// IEEE
Trans. Software Eng., 1991. Vol.~23. No.\,5. P.~279--295.

\bibitem{16-mir} %16
\Au{Kaivola R.} Using compositional preorders in the verification
of sliding window protocol~// Computer aided verification.
Lecture notes in computer
science ser.~/ Ed.\ O.~Grumberg.~--- Berlin--Heidelberg:
Springer-Verlag, 1997. Vol.~1254. P.~48--59.

\bibitem{17-mir} %17
\Au{Godefroid P., Long D.} Symbolic protocol verification with
queue BDDs~// Formal Methods  Syst. Design, 1999.
Vol.~14. No.\,3. P.~257--271.

\bibitem{18-mir} %18
\Au{Stahl~K., Baukus~K., Lakhnech~Y., Steffen~M.} Divide, abstract,
and model-check~// Theoretical and practical aspects of SPIN model
cheking. Lecture notes in computer science ser.~/
Eds. D.~Dams, R.~Gerth, S.~Leue, M.~Massink.~--- Berlin--Heidelberg:
Springer-Verlag, 1999. Vol.~1680. P.~57--76.

\bibitem{19-mir} %19
\Au{Latvala T.} Model checking LTL properties of high-level Petri
nets with fairness constraints~// Applications and theory of Petri nets.
Lecture notes in computer science ser.~/ Eds. J.-M.~Colom, M.~Koutny.~---
Berlin--Heidelberg: Springer-Verlag, 2001. Vol.~2075. P.~242--262.

\bibitem{21-mir} %20
\Au{Schoone A.} Assertional verification in distributed computing.~---
Utrecht: Utrecht University, 1991. Ph.D. Thesis. 191~p.

\bibitem{20-mir} %21
\Au{Chkliaev D., Hooman~J., de~Vink~E.} Verification and
improvement of the sliding window protocol~// Tools and algorithms for the constriction
and analysis of system. {Lecture notes
in computer science ser.}~/
Eds. H.~Garavel, J.~Hatcliff.~--- Berlin--Heidelberg: Springer-Verlag, 2003.
Vol.~2619. P.~113--127.

\bibitem{22-mir} %22
\Au{Vaandrager F.} Verification of two communication protocols by
means of process algebra.~--- Amsterdam:
Centrum voor Wiskunde en Informatica, 1986.  Technical Report CS-R8608. 76~p.

\bibitem{24-mir} %23
\Au{Van Wamel J.} A~study of a one bit sliding window protocol in
ACP.~---  Amsterdam: University of Amsterdam,
1992. Technical Report P9212. 59~p.

\bibitem{25-mir} %24
\Au{Bezem M., Groote~J.} A~correctness proof of a one bit sliding
window protocol in $\mu$CRL~// {The Computer~J.}, 1994.
Vol.~37. No.\,4. P.~289--307.

\end{thebibliography}
} }

\end{multicols}

\vspace*{-6pt}

\hfill{\small\textit{Поступила в редакцию 4.02.14}}

\newpage


%\vspace*{12pt}

%\hrule

%\vspace*{2pt}

%\hrule


\def\tit{A METHOD OF PROVING THE~OBSERVATIONAL EQUIVALENCE
OF~PROCESSES WITH~MESSAGE PASSING}

\def\titkol{A method of proving the observational equivalence
of processes with message passing}

\def\aut{A.\,M.~Mironov}
\def\autkol{A.\,M.~Mironov}


\titel{\tit}{\aut}{\autkol}{\titkol}

\vspace*{-9pt}

\noindent
Institute of Informatics Problems, Russian Academy of Sciences,
Moscow 119333, 44-2 Vavilov Str., Russian Federation



\def\leftfootline{\small{\textbf{\thepage}
\hfill INFORMATIKA I EE PRIMENENIYA~--- INFORMATICS AND APPLICATIONS\ \ \ 2014\ \ \ volume~8\ \ \ issue\ 2}
}%
 \def\rightfootline{\small{INFORMATIKA I EE PRIMENENIYA~--- INFORMATICS AND APPLICATIONS\ \ \ 2014\ \ \ volume~8\ \ \ issue\ 2
\hfill \textbf{\thepage}}}

\vspace*{6pt}

\Abste{The article deals with the problem of proving observational
equivalence for the class of computational processes called the
processes with message passing.
These processes can execute actions of the following
forms: sending or receiving the messages,
checking the logical conditions, and updating the values of internal variables of 
the processes.
The main result is the theorem that reduces the problem of proving observational equivalence of a pair of  processes with message passing to the problem
of finding formulas associated with pairs of states of these processes, satisfying certain conditions that are associated with transitions of these processes.
This reduction is a generalization of Floyd's method of flowchart verification, which reduces the problem of
verification of flowcharts to the problem of finding formulas (called intermediate assertions)
associated with points in the flowcharts and satisfying conditions, corresponding to transitions in the flowcharts.
The method of proving the observational equivalence of processes with
message passing is illustrated by an example of sliding window protocol verification.}

\KWE{verification;
processes with message passing;
observational equivalence;
sliding window protocol}

\DOI{10.14357/19922264140206}

%\Ack
%\noindent

  \begin{multicols}{2}

\renewcommand{\bibname}{\protect\rmfamily References}
%\renewcommand{\bibname}{\large\protect\rm References}

{\small\frenchspacing
{%\baselineskip=10.8pt
\addcontentsline{toc}{section}{References}
\begin{thebibliography}{99}

\bibitem{1-mir-1}
\Aue{Milner, R.} 1980.
\textit{A~calculus of communicating systems.}
{Lecture notes in computer science ser.}
Berlin\,--\,Heidelberg\,--\,New York: Springer-Verlag. 92. 172~p.

\bibitem{larsen-1}
\Aue{Larsen, K.\,G.,  and  A.~Skou}.
1991.
Bisimulation through probabilistic testing.
\textit{Inform. Comput.} 94(1):1--28.

\bibitem{realtime-1}
\Aue{Larsen, K.\,G., and Y.~Wang.}
1997. Time-abstracted bisimulation:
Implicit specifications and decidability.
\textit{Inform. Comput.} 134(2):75--101.

\bibitem{2-mir-1}
\Aue{Milner, R.}
1999. \textit{Communicating and mobile systems:
The $\pi$-calculus.} Cambridge: Cambridge University Press. 162~p.

\bibitem{3-mir-1}
\Aue{Hoare, C.\,A.\,R.}
1985. \textit{Communicating sequential processes.} Prentice Hall. 256~p.

\bibitem{4-mir-1} %6
\Aue{Clarke, E.\,M., O.~Grumberg, and D.~Peled}.
1999. \textit{Model checking.} MIT Press. 314~p.

\bibitem{5-mir-1} %7
\Aue{Petri, C.\,A.}
1980. \textit{Introduction to general net theory.}
{Lecture notes in computer science ser.}
Ed. W.~Brauer. Berlin--Heidelberg:
Springer-Verlag.  84:1--19.

\bibitem{6-mir-1} %8
Bergstra, J.\,A., A.~Ponse, and S.\,A.~Smolka, eds.
2001. \textit{Handbook of process algebra.}
North-Holland, Amsterdam. 1357~p.

\bibitem{7-mir-1} %9
\Aue{Brand, D., and P.~Zafiropulo}.
1983. On communicating finite-state machines.
\textit{J.~ACM} 30(2):323--342.

\bibitem{8-mir-1} %10
\Aue{Floyd, R.\,W.}
1967. Assigning meanings to programs.
\textit{Mathematical Aspects of Computer Science:
Symposium on Applied Mathematics Proceedings}. Ed. J.\,T.~Schwartz.
American Mathematical Society. 19:19--32.

\bibitem{12-mir-1} %11
\Aue{Tanenbaum, A.} 2002.
\textit{Computer networks}. 4th ed.
Prentice Hall. 674~p.

\bibitem{9-mir-1} %12
\Aue{Badban, B., W.\,J.~Fokkink, and J.\,C.~van de~Pol}.
2008. Mechanical verification of a two-way sliding window protocol
(full version including proofs). Twente:
Centre for Telematics and
Information Technology, University of Twente. Internal Report TR-CTIT-08-45.
55~p.

\bibitem{13-mir-1} %13
\Au{Hailpern, B.}
1982. \textit{Verifying concurrent processes using temporal logic.}
{Lecture notes in computer science ser.}
Berlin--Heidelberg: Springer-Verlag. 129. 216~p.

\bibitem{14-mir-1} %14
\Aue{Holzmann, G.} 1991.
\textit{Design and validation of computer protocols.} Prentice Hall. 558~p.

\bibitem{15-mir-1} %15
\Aue{Holzmann, G.}
1991. The model checker Spin.
\textit{IEEE Trans. Software Eng.} 23(5):279--295.

\bibitem{16-mir-1} %16
\Aue{Kaivola, R.} 1997.
{Using compositional preorders in the verification of sliding window
protocol}. \textit{Computer aided verification}.
Lecture notes in computer science ser. Ed.\ O.~Grumberg.
Berlin--Heidelberg: Springer-Verlag.
1254:48--59.

\bibitem{17-mir-1} %17
\Aue{Godefroid, P., and D.~Long.}
1999. Symbolic protocol verification with Queue BDDs.
\textit{Formal Methods Syst. Design} 14(3):257--271.

\bibitem{18-mir-1} %18
\Aue{Stahl, K., K.~Baukus, Y.~Lakhnech, and M.~Steffen}.
1999. Divide, abstract, and model-check.
\textit{Theoretical and practical aspects of SPIN model checking.}
{Lecture notes in computer science ser.}
Eds. D.~Dams, R.~Gerth, S.~Leue, and M.~Massink. Berlin--Heidelberg:
Springer-Verlag. 1680:57--76.

\bibitem{19-mir-1} %19
\Aue{Latvala, T.}
2001. Model checking LTL properties of
high-level Petri nets with fairness
constraints. \textit{Applications and theory of Petri nets.}
{Lecture notes in computer science ser.} Eds.\
J.-M.~Colom and M.~Koutny. Berlin--Heidelberg: Springer-Verlag. 2075:242--262.

\bibitem{21-mir-1} %20
\Aue{Schoone, A.}
1991. Assertional verification in distributed computing.
 Utrecht University. Ph.D. Thesis. 191~p.

 \pagebreak

\bibitem{20-mir-1} %21
\Aue{Chkliaev, D., J.~Hooman, and E.~de~Vink.}
2003. Verification and improvement
of the sliding window protocol. \textit{Tools and algorithms for
the constriction and analysis of systems.}
{Lecture notes in computer science ser.}
Eds. H.~Garavel and J.~Hatcliff.~--- Berlin--Heidelberg: Springer-Verlag.
2619:113--127.

\bibitem{22-mir-1} %22
\Aue{Vaandrager, F.}
1986. Verification of two communication protocols by means of process algebra.
 Amsterdam: Centrum voor Wiskunde en Informatica.  Technical Report CS-R8608.
 76~p.

\bibitem{24-mir-1} %23
\Aue{Van Wamel,~J.}
1992. A~study of a one bit sliding window protocol in ACP.
Amsterdam: University of Amsterdam.  Technical Report P9212. 59~p.

\bibitem{25-mir-1}
\Aue{Bezem, M., and J.~Groote.}
1994. A~correctness proof of a one bit sliding window
protocol in $\mu$CRL. \textit{The Computer~J.}
37(4):289--307.

\end{thebibliography}
} }


\end{multicols}

\vspace*{-6pt}

\hfill{\small\textit{Received February 4, 2014}}

\vspace*{-18pt}


\Contrl

\noindent
\textbf{Mironov Andrew M.} (b.\ 1966)~---
 Candidate of Science (PhD) in physics and mathematics, senior scientist,
 Institute of Informatics Problems, Russian Academy of Sciences,
 44-2 Vavilova Str., Moscow 119333, Russian Federation; amironov66@gmail.com

  \label{end\stat}

\renewcommand{\bibname}{\protect\rm Литература}

