\def\stat{basok}

\def\tit{ИСПОЛЬЗОВАНИЕ ВЕРОЯТНОСТНОЙ МОДЕЛИ ВЫЧИСЛЕНИЙ 
ДЛЯ~ТЕСТИРОВАНИЯ ОДНОГО КЛАССА ГОТОВЫХ К~ИСПОЛЬЗОВАНИЮ 
ПРОГРАММНЫХ КОМПОНЕНТОВ ЛОКАЛЬНЫХ И~СЕТЕВЫХ СИСТЕМ$^*$}

\def\titkol{Использование вероятностной модели вычислений 
для~тестирования одного класса %готовых к~использованию 
программных компонентов} % локальных и~сетевых систем}

\def\aut{Б.\,М.~Басок$^1$, В.\,Н.~Захаров$^2$, С.\,Л.~Френкель$^3$}

\def\autkol{Б.\,М.~Басок, В.\,Н.~Захаров, С.\,Л.~Френкель}

\titel{\tit}{\aut}{\autkol}{\titkol}

\index{Басок Б.\,М.}
\index{Захаров В.\,Н.}
\index{Френкель С.\,Л.}
\index{Basok B.\,M.}
\index{Zakharov V.\,N.}
\index{Frenkel S.\,L.}




{\renewcommand{\thefootnote}{\fnsymbol{footnote}} \footnotetext[1]
{Работа выполнена при частичной финансовой поддержке 
РФФИ (проекты 18-07-00669, 18-29-03100).}}


\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{МИРЭА~--- Российский технологический университет, VM\_E@mail.ru}
  \footnotetext[2]{Федеральный исследовательский центр <<Информатика и~управ\-ле\-ние>>
Российской академии наук,  \mbox{VZakharov@ipiran.ru}}
\footnotetext[3]{Институт проблем информатики Федерального исследовательского центра <<Информатика 
  и~управ\-ле\-ние>> Российской академии наук, \mbox{fsergei51@gmail.com}}

\vspace*{-8pt}

    
      
    
     
     \Abst{Обсуждается и~анализируется возможность обеспечения эффективного 
тестирования готовых к~использованию программных продуктов (ГИПП), решающих 
задачи вычисления функций, в~условиях отсутствия полной информации, необходимой 
для традиционного тестирования. Под эффективностью понимается возможность 
обеспечения сколь угодно высокой вероятности обнаружения возможных ошибок 
вычислений, не выявленных при выходном контроле, по мере роста чис\-ла проверок. 
В~качестве концептуальной модели предлагается использовать свойства функций со 
случайной самоприводимостью (random self-reducible function~--- RSR), т.\,е.\ функций, 
вычисление которых на конкретном входном наборе можно свести к~вы\-чис\-ле\-нию на 
нескольких случайно выбранных входных наборах.
     Обосновывается рациональность обеспечения свойств са\-мо\-тес\-ти\-ру\-емости 
в~коммерческих вычислительных ГИПП.}
     
     \KW{тестирование программ; самотестирование}
     
\DOI{10.14357/19922264180407}
  
\vspace*{-4pt}


\vskip 10pt plus 9pt minus 6pt

\thispagestyle{headings}

\begin{multicols}{2}

\label{st\stat}
     
\section{Введение}

    При приобретении ГИПП перед пользователем стоит задача убедиться в~его полной 
исправности, в~его способности без ошибок выполнять те функции, которые 
указаны в~прилагаемой к~нему документации. Для этого непосредственно 
перед эксплуатацией программный продукт (ПП) должен быть тщательно 
протестирован пользователями или передан для этого фирме, 
специализирующейся на тестировании~ПП.
    
    Данные действия должны осуществляться независимо от того, 
прилагаются к~ГИПП тесты разработчика или они отсутствуют. В~первом 
случае\linebreak следует убедиться, что ПП работает и~с другими данными, выполнить 
проверку наиболее сложных и~труднореализуемых функций, особенно тех, 
ошибки в~которых могут привести к~непредсказуемым последствиям. Во 
втором случае тестирование, безусловно, необходимо, поскольку только 
в~этом случае можно убедиться в~ра\-бо\-то\-спо\-соб\-ности ГИПП и~его 
возможностях.
    
        Технология тестирования ГИПП отличается от технологии 
тестирования ПП на этапе его разработки и~имеет свои особенности. Эти 
особенности подробно были разобраны в~работе~[1]. Среди данных 
особенностей можно в~первую очередь выделить следующие:
    \begin{itemize}
    \item доступ к~коду ГИПП для пользователей и~тестеров в~подавляющем 
большинстве случаев исключен. Также отсутствует возможность 
непосредственного контакта с~разработчиками ПП. Поэтому при 
тестировании используется метод <<черного ящика>> (BB~--- Black Box), 
основанный на системном функциональном или поведенческом 
тестировании. Кроме того, отсутствуют возможности создания 
и~эксплуатации модульных тестов и~тестов проверки межмодульных связей 
(интеграционных тестов);    
    \item ошибок в~программе существенно меньше, чем было на этапе ее 
разработки. По данным, приводимым в~[2], это число составляет примерно 
0,1--0,3~ошибки на~1000~строк кода;
    \item  оставшиеся в~ГИПП ошибки труднее выявляются, поскольку 
большинство ошибок было уже найдено при тестировании программы на 
этапе ее разработки и~естественно предположение о~том, что оставшиеся 
ошибки <<труд\-но\-тес\-ти\-ру\-емые>> (hard to test~[3]). Цена указанных ошибок 
достаточно велика, существенно выше цены найденных ранее ошибок 
примерно на~1--2~порядка. Поэтому от тестеров требуется повышенное 
внимание к~организации тестирования ГИПП перед началом его 
эксплуатации.
    \end{itemize}
    
    Обычно тесты~--- это последовательность шагов, каждый из которых 
содержит описание действий, предпринимаемых тестером, и~описание 
ожи\-да\-емых результатов, используемых при тестировании в~качестве 
эталонов. Разработка тестов ведется тестером на основе изучения работы 
ГИПП и~эксплуатационной документации.
    
    В связи с~тем что тестер может смоделировать лишь небольшую часть 
функций программы (так называемое остаточное моделирование)~\cite{7-bf}, 
возможны ошибки при задании как входных данных, так и~ожидаемых 
результатов (эталонных значений), получаемых вручную. Эти ошибки 
проявляются при реализации процедур сравнения полученных результатов 
тестирования и~эталонных данных и~принятия на их основе решений 
о~наличии ошибок в~ПП, называемых в~специальной литературе 
оракулами~\cite{4-bf}. При этом основную часть этих ошибок составляют 
ошибки, связанные с~заданием эталонов, поскольку их получение 
осуществляется тестером, как правило, вручную~\cite{2-bf}.
    
    Кроме того, в~связи с~тем что входные данные тестов ПП, как правило, 
представляют собой искусственно подобранные наборы данных, нет 
гарантии, что они достаточно полно проверяют все особенности ПП. В~то же 
время при выполнении реальных задач с~произвольными данными можно 
обнаружить некоторые отказы в~программе, поскольку при их выполнении 
осуществляется максимальный охват программного кода. Например, при 
тестировании текстового редактора реальные\linebreak
 тексты могут быть не менее 
полезными, чем специально подобранные буквосочетания. Однако 
определение ожидаемых результатов при обработке\linebreak
 программой реальных 
данных, особенно при реализации сложных вычислительных процессов, 
оказывается достаточно трудоемкой процедурой и,~как следствие этого, 
с~возможными ошибками.
    
    Таким образом, задача получения правильных эталонных данных при 
тестировании ГИПП является достаточно сложной и~актуальной.
    
    В предлагаемой статье рассматривается ряд принципиальных 
трудностей практики тестирования, связанных с~отсутствием полной 
спецификации программы и~информации о тестах разработчика, об 
эталонных значениях в~частности.
    
    Будет показано, что для программ, реа\-ли\-зу\-ющих функции, обладающие 
свойствами случайной самоприводимости 
(RSR~\cite{5-bf}), т.\,е.\ функций, вычисление которых на конкретном 
входном наборе можно свести к~вы\-чис\-ле\-нию на случайно выбранных 
входных наборах, часть трудностей, связанных с~отсутствием эталонов, 
можно преодолеть.
    
    Заметим, что вопрос использования свойств RSR далеко не новый, он 
широко обсуждался в~начале 1990-х~гг.\ в~рамках задач  
са\-мо\-тес\-ти\-ро\-ва\-ния/са\-мо\-про\-ве\-ря\-емости  
(self-testing/self-checking) программ~\cite{6-bf}. Принимая во внимание опыт 
по практическому тестированию программ~[1, 2], авторы считают полезным 
рассмотреть применение данной модели к~проблеме тестирования готовых 
к~использованию программ, особенно в~связи с~отмеченной проблемой 
обеспечения тестера информацией об эталонных значениях вычисляемых 
функций.

\vspace*{-6pt}
    
\section{Основные подходы к~тестированию готового к~использованию программного~продукта}

\vspace*{-2pt}
    
    Подходы к~тестированию ГИПП зависят в~основном от того, для 
решения каких задач они используются. Возможны следующие ситуации:
    \begin{enumerate}[(1)]
    \item ГИПП используется как продукт, предназначенный для 
самостоятельного решения конкретной прикладной задачи. В~этом случае 
тестирование состоит в~проверке правильности (согласно некоторому 
протоколу) его функционирования в~конкретной операционной среде 
и~в~проверке правильности решения задачи на рабочих данных;
    \item ГИПП представляет собой некоторый пакет программ, 
используемый для решения различных задач в~связанных прикладных 
областях (например, САПР (система автоматизированного
проектирования) для стро\-и\-тель\-но-мон\-таж\-ных работ);
    \item ГИПП должен использоваться как компонент некоторой сложной 
разрабатываемой программной или программно-аппаратной системы, 
в~частности в~виде сервисов в~сер\-вис-ори\-ен\-ти\-ро\-ван\-ных 
архитектурах.
    \end{enumerate}
    
    Основные современные подходы к~разработке тестов для различных 
вариантов данного списка задач можно разделить на методы <<черного 
ящика>>  и~инжекции ошибок (который может включать в~себя и~метод 
<<мутаций>> кодов и~входных данных~\cite{8-bf}).

\vspace*{-3pt}
    
    \subsection{Метод <<черного ящика>>}
    
    \vspace*{-1pt}
    
    Для тестирования методом BB~\cite{9-bf} требуется исполняемый 
компонент, входные данные и~<<оракул>>, представляющий собой 
спецификацию поведения компонента при разных входных данных, 
в~частности эталонные значения выходов (результатов работы) программы.
    
    Поскольку исходный код ГИПП, как правило, у~пользователя 
отсутствует, единственный источник информации для тестирования~--- это 
записи (<<журналы>>, <<лог-фай\-лы>>) различных активностей при 
выполнении программы на целевой платформе на некоторых тестовых 
входах, на которых значения вычисляемых функций должны играть роль 
эталонных значений при обнаружении ошибок рассматриваемым тестом.
 %   
    Однако при этом часто возникают указанные выше трудности, 
связанные с~отсутствием информации об истинных эталонных выходных 
значениях и~их связи с~конкретным операционным профилем, который может 
меняться в~зависимости от модификации операционной среды или от 
специфики работы рассматриваемой программы в~составе конкретной  
сер\-вис-ори\-ен\-ти\-ро\-ван\-ной архитектуры.
    
    Возможным выходом из этой ситуации считают использование 
исполняемой версии приложения с~аналогичной функциональностью, часть 
результатов которой можно принять за эталонные для новой  
ГИПП~\cite{2-bf, 11-bf}. Это соответствует ситуации, когда существуют 
прежние версии новой ГИПП или приложения, которые можно 
рассматривать как подобные рассматриваемой новой ГИПП (с точки зрения 
результатов вычислений). Часто, однако, такие версии не доступны 
приобретателю ГИПП.

\vspace*{-3pt}
    
    \subsection{Инжекция возможных программных ошибок 
и~системных сбоев}

\vspace*{-1pt}
    
    Под инжекцией ошибок понимают введение в~код программы на том 
или ином уровне представления (от исходного до исполнимого кода) 
искажений, которые могут приводить к~тем или иным видам некорректного 
поведения~\cite{8-bf}.
    
    Существует множество типов инжекций, которые могут отражать либо 
некоторые гипотетические сбои в~операционной системе (включая 
вызванные сбоями в~аппаратной части системы), либо списки возможных 
ошибок в~исходном коде программы.
    
    Очевидно, что ввиду отсутствия у пользователя ГИПП исходного кода 
второй способ инжекций интереса не представляет. Реальным приложением 
инжекций может быть имитация режимов отказа системы, таких как 
искажение данных операционной среды, повреждение данных, проходящих 
между вызовами компонент.
    
    В~\cite{10-bf} описана система инжекции ошибок при выполнении 
программы (runtime binary injection tool).
    %
    Этот инструмент имитирует ошибки в~запросах в~вызываемых функциях 
и~возвращает значения выполняемых при этом функций. Общий принцип 
использования таких инструментов основан на предположении, что тесты, 
обнаруживающие инжектированные ошибки во время выполнения 
программы, с~высокой вероятностью обнаружат также и~ошибки 
в~операторах исходного кода~\cite{11-bf}, результатом которых может быть, 
например, неправильная обработка того или иного системного сбоя. 
Следовательно, входные данные, определенные с~использованием 
инструмента инжекции как тестовые (т.\,е.\ обнаруживающие по результатам 
выполнения программы возможные ошибки), могут использоваться для 
тестирования ГИПП в~эксплуатационных условиях (например, при 
проведении регламентных работ).
    
    Трудности использования данного подхода связаны прежде всего 
с~высокой стоимостью систем инжекции, а также высокими требованиями 
к~квалификации тестера.
   % 
    При этом, разумеется, остается проблема определения правильных 
выходов выполняемых функций и~программы в~целом, используемых 
в~качестве эталонов при оценке результатов тестирования на специфических 
тестах.

\vspace*{-6pt}
    
\section{О~возможности тестирования программ с~неизвестной 
структурой и~не~полностью специфицированными функциями}

\vspace*{-2pt}
    
    Существенной трудностью тестирования ГИПП является отсутствие 
точных значений выходов программы при конкретных условиях ее 
выполнения (<<оракулов>>, в~терминах современной практики тес\-ти\-ро\-ва\-ния 
программ~\cite{4-bf}). Интересно было бы рассмотреть вопрос 
о~принципиальной воз\-мож\-ности решения этой проблемы.
    
    Представляется, что в~качестве теоретической и~концептуальной основы 
тестирования при неполной спецификации программы можно было бы\linebreak
 взять 
концепцию тестирования случайных самопри\-во\-ди\-мых функций, 
применяемую в~тео\-рии самотестируемых программ. Поскольку 
самотестируемость означает, что программа сама может определить отличие 
правильного результата от неправильного, естественно использовать 
правильное значение как эталон в~задаче внешнего (т.\,е.\ с~выбором 
исходных данных самим пользователем программы) тестирования.
    
    Функция является случайной самоприводимой на некотором множестве, 
если ее значение в~данной точке может быть эффективно реконструировано 
из ее оценки в~случайных точках~\cite{5-bf, 13-bf}.
    
    \smallskip
    
    \noindent
    \textbf{Определение.}\ Функция $f(x)$, определенная над 
множеством~$D$, называется случайной самоприводимой функцией, если 
существует функция~$\varphi$ и~множество функций $\sigma_1, \ldots , 
\sigma_n$ таких, что
    \begin{equation}
    f(x)=\varphi\left(x, r, f\left( \sigma_1\left(x,r\right)\right),\ldots , 
f\left(\sigma_k\left( x,r\right)\right)\right)\,,
    \label{e1-bs}
    \end{equation}
   где случайные переменные $r\hm=\{r_1, \ldots , r_m\}$ имеют известные 
распределения, а~функция~$\varphi$ и~множество функций $\sigma_1,\ldots , 
\sigma_k$ могут быть вычислены за полиномиальное время.

    Иными словами, если для функции $f(x)$ оценку ее значения на любом 
входе~$x$ можно свести за полиномиальное время к~оценке ее значения на 
одном или более случайных экземплярах входных переменных, то такая 
функция является самоприводимой.
    
    По сути, можно говорить о~\textit{восстановлении} значения функции 
$f(x)$ по случайно выбранным входным переменным $\{r\}$, так как это 
свойство позволяет восстановить значение функции, используя конечное 
число элементов, взятых из ее области определения, без ка\-ких-ли\-бо 
знаний о~реализации программы, которая выполняет вычисление.
    
    Например, пусть программа~$A$ должна вы\-чис\-лять линейную функцию 
$f(x) \hm= wx$, где $w$~--- любое действительное число (кроме~0), 
и~вы\-чис\-ле\-ни\-ям функций $\sigma_1,\ldots ,\sigma_4$ соответствуют вызовы 
программы:
    $A\left(w-r_1, x-r_2\right)$, 
    $A\left(w-r_1, r_2\right)$, $A\left(r_1, x-r_2\right)$ и~$A\left(r_1, 
r_2\right)$,
где $r_1$ и~$r_2$~--- равномерно распределенные в~области задания 
переменных~$w$ и~$x$ случайные величины.

    Если программа правильно вычисляет функцию с~указанными 
аргументами, то из приведенного ниже очевидного тождества следует:

\vspace*{-5pt}

\noindent
    \begin{multline}
    y_c = A\left(w-r_1, x-r_2\right) + A\left(w-r_1, r_2\right) + {}\\
    {}+A\left(r_1, x-r_2\right) + 
A\left(r_1, r_2\right) = \left(w-r_1\right)\left(x-r_2\right) + {}\\
{}+ \left(w-r_1\right)r_2 + r_1\left(x-r_2\right) + 
r_1r_2 = wx\,,
    \label{e2-bf}
    \end{multline}
    что демонстрирует выполнение условий определения RSR при любых 
случайных~$r_1$ и~$r_2$.

    В данном примере функции~$\varphi$ в~(1) соответствует сумма 
функций $\sigma_1, \ldots, \sigma_4$ с~соответствующими аргументами.
    
    Если каждый вызов программы выполняется с~небольшой вероятностью 
ошибки $\leq\alpha$ (скажем,~0,01), где $\alpha$~--- это доля входных 
наборов, на которых возможны ошибки вычисления (гарантированные, 
например, разработчиком программы), то вероятность ошибки вычисления 
суммы будет $\leq 4\alpha$ и,~соответственно, большинство значений~$y_c$ 
при достаточном большом числе случайно выбранных~$r_1$ и~$r_2$ будут 
равны истинному значению~$wx$, что означает возможность определения 
правильного значения выхода программы (эталона) как значения, которое 
получается на большинстве входных наборов программы, вычисляющей 
данную функцию.
    
    Таким образом, для реализации данного подхода необходимо выбрать 
статистически обоснованное число пар~$r_1, r_2$, чтобы обеспечить 
требуемую вероятность правильного вычисления с~достаточным уровнем 
доверия (величиной доверительного интервала~\cite{13-bf}).
 %   
    Для этого, предполагая, что последовательность правильных 
результатов образует последовательность Бернулли (поскольку случайные 
переменные~$r_1$ и~$r_2$~--- независимые, равномерно распределенные числа), 
получим вероятность того, что значение функции, получаемое на 
большинстве из~$n$~входных наборов переменных (т.\,е.\ $\geq [n/2]\hm+1$), 
есть точное значение функции:

\noindent
    \begin{equation}
    \mathrm{Pr} \left( k\geq L+1\right)=1-\sum\limits^L_{k=0} C_n^k p^k 
q^{n-k}\,,
    \label{e3-bf}
    \end{equation}
где $p>1/2$~--- вероятность успеха (правильного вычисления функции, 
$1\hm- 4\alpha$ в~рассматриваемом примере); $q\hm = 1 \hm- p$; $k$~--- 
число правильных ответов в~данной последовательности~$n$ испытаний, 
$L\hm= \lfloor n/2\rfloor\hm+1$.

    Границы этой вероятности определяются различными формами 
неравенства Чернова (Chernoff inequality), например:

\noindent
    \begin{equation}
    \mathrm{Pr}\left( k>\fr{n}{2}\right) \geq 1-\exp \left( -2n\left( p-
\fr{1}{2}\right)^2\right)\,,
    \label{e4-bf}
    \end{equation}
где~$k$, как и~выше,~--- число успешных исходов в~$n$~испытаниях Бернулли.

    Очевидно, что с~ростом числа испытаний~$n$ растет вероятность того, 
что большинство (больше половины всех исходов) будут успешными (т.\,е.\ 
функция будет вычислена правильно).
    
    Задавая требуемый статистический уровень доверия $1\hm-
\beta$~\cite{13-bf} (например,~0,99, что означает, что вероятность $\mathrm{Pr}\,(k\hm> 
n/2)$ на конечной выборке испытаний длиной~$n$ в~рассматриваемом 
примере будет оценена с~вероятностью ошибки не более~0,01), получают 
число испытаний Бернулли (т.\,е.\ число тестовых прогонов для вычисления 
функции), необходимых для определения вероятности большинства 
правильных ответов при данном уровне~$\beta$~\cite{12-bf, 19-bf}:

\noindent
    \begin{equation}
    n\geq  \fr{\ln(1/\beta)}{(p-1/2)^2}\,.
    \label{e5-bf}
    \end{equation}
    
    Иными словами, $n$~--- это число случайных наборов, которые дают 
достаточную вероятность того, что большая часть результатов вычислений 
тестируемой функции $f(x)$ будет правильной и~можно определить этот 
результат просто по большинству ответов при данной вероятности~$\alpha$ 
ошибки выполнения программы~$A$.
    
    Формула~(\ref{e5-bf}) применима для оценки необходимого числа 
запусков программы, вычисляющей любые функции, представимые как~(1).
    
    В настоящее время доказано~\cite{14-bf, 15-bf}, что значительный класс 
вычислительных задач может быть представлен как вычисление функций со 
свойствами RSR. Сюда, например, относятся:
    \begin{itemize}
  \item  преобразование Фурье;
  \item матричные вычисления (например, перемножение матриц, 
построение обратной матрицы, вычисление определителей, вычисление 
перманента матрицы);
  \item вычисление тригонометрических, степенных, логарифмических 
функций;
  \item операции (умножение-деление) с~полиномами нескольких 
переменных;
  \item значительное число теоретико-числовых функций, используемых 
в~поисковых алгоритмах и~криптографии~\cite{15-bf}.
  \end{itemize}
  
  Оставляя вопрос об автоматизированном построении функций~$\varphi$ 
и~$\sigma_i$ ($i\hm = 1, \ldots, k$) в~формуле~(1), отметим, что в~настоящее 
время в~литературе приведены различные примеры~$\varphi$ и~$\{\sigma_1, 
\ldots , \sigma_k\}$ для всех перечисленных выше RSR-функ\-ций, т.\,е.\ 
с~практической точки зрения можно говорить о~возможности использования 
<<биб\-лио\-те\-ки>> таких функций~\cite{6-bf}.
  
    Например, в~\cite{14-bf} доказана следующая
    
    \smallskip
    
    \noindent
    \textbf{Теорема.}\ \textit{Для каждого набора$\{a_1, \ldots , a_{d+1}\}$ 
попарно различных элементов конечного поля~$F$ с~числом элементов $\vert 
F\vert \hm> d\hm+1$ существует конечное число чисел $\{c_1, \ldots , 
c_{d+1})$, таких что для каждого полинома $P(x)$ степени~$d$, 
определенного на~$F$, справедливо}
    \begin{equation*}
    \forall x, r\in F,\ P(x)=\sum\limits_{i=1}^{d+1} c_i P\left( x+a_i r\right)\,.
   % \label{e6-bf}
    \end{equation*}
    
    {В этом случае функции $\sigma_i\hm = x\hm+ a_ir$, где~$r$, как 
и~выше,~--- случайное число. Если $(a_1, \ldots, a_{d+1}) \hm= (1, 2, \ldots, 
d+1)$, то $c_i\hm = (-1)^{i+1}C^i_{d+1}$, где $C^i_{d+1}$~--- биномиальные 
коэффициенты.}
    
    %\smallskip
    
    Существенно, что единственное, что надо знать в~данном случае 
о~вычисляемой функции,~--- это то, что она полином степени~$d$.
    
    Учитывая, что большинство непрерывных функций вычисляется через 
их полиномиальное представление, можно говорить о широких 
возможностях использования RSR в~задачах тестирования.
    
    Заметим, что, поскольку формально вычисления в~любых аппаратных 
средах являются при\-ближенными (конечность разрядной сетки про\-цессоров), 
в~теории RSR-функ\-ций введено также\linebreak
 понятие <<приближенной случайной 
самоприводимости>> (approximate-random self-reducible)~\cite{12-bf} для 
функции, значение в~некоторой точке~$x$ которой может быть представлено 
по формуле~(1) лишь с~некоторой точностью~$\varepsilon$. С~формальной 
точки зрения это вполне естественно для вычислений с~фиксированной 
и~плавающей точкой.

    В~\cite{12-bf} приведены примеры выполнения~(1) при вычислении 
показательной и~логарифмической функций для $k$-бит\-ных чисел  
с~$l_m$-бит\-ной мантиссой и~$l_{\mathrm{exp}}$-бит\-ной экспонентой.
    
    Соответственно, все сказанное выше о~вы\-чис\-ле\-нии значений функций 
тестируемыми программами может быть переформулировано в~терминах 
вычисления приближенных значений.
    
    Итак, если поставщик ГИПП (функциональное назначение которой 
состоит в~вычислении тех или иных функций) гарантирует достаточно 
высокую вероятность правильной работы программы, вычисляющей 
требуемую функцию, то, организовав вычисление функции 
на~$n$~случайных наборах из области определения тестируемой функции, где~$n$ 
определяется согласно~(\ref{e5-bf}), с~высокой вероятностью можно 
определить неизвестный из спецификации правильный результат вычисления 
функции.
    
    Очевидно, что при необходимости многократ\-ного тестирования ГИПП, 
например для оценки\linebreak не\-об\-хо\-ди\-мости дальнейшей модификации программы, 
или при тестировании в~процессе регла\-мент\-ной проверки оборудования нет 
не\-об\-хо\-ди\-мости прогона на указанных случайных наборах, поскольку 
достаточно использовать полученные ранее значения выхода программ как 
эталонные.

\vspace*{-9pt}
    
\section{О самотестировании готового к~использованию программного продукта}

\vspace*{-3pt}

    Как отмечалось во введении, подход, основанный на теории  
RSR-функ\-ций, был первоначально предложен для задач самотестирования 
и~самокоррекции программ. Соответственно, он может быть использован 
при решении задач самотестирования и~ГИПП~\cite{12-bf}, поскольку для 
самопроверки нужен лишь перебор достаточного числа входных значений 
без использования эталонных значений работы программы. Иными словами, 
можно использовать известные в~теории и~практике самокоррекции 
программ методы выбора правильного решения по большинству результатов 
(например, N-version programming). Более того, ввиду роста вероятности 
правильного вычисления по мере роста числа~$n$~случайных входных 
наборов $\{r_1,\ldots , r_k\}$ (формулы~(\ref{e2-bf})--(\ref{e5-bf})), можно 
говорить о повышении надежности программы (этот эффект называют 
<<усилением>> (amplification)~\cite{16-bf}).
    
    Обычно используют два вида процедур са\-мо\-тес\-ти\-ро\-ва\-ния программ: 
следящее и~активное~\cite{4-bf, 17-bf}. При реализации первого вида 
самотестирования осуществляется проверка результатов обработки данных 
в~процессе эксплуатации. Примерами следящего самотестирования могут 
служить подстановка найденных корней в~уравнение и~оценка разности 
между левой и~правой частью, проверка правильности сортировки путем 
анализа выходного массива, вычисление и~сравнение контрольных\linebreak
 сумм 
и~т.\,д. Главным недостатком данного вида\linebreak самотестирования ПП является 
невозможность хранения эталонных данных работы программы, 
необходимых для анализа результатов ее работы и~диагностирования отказов 
программы.
    
    При активном самотестировании осуществляется проверка результатов 
обработки специальных тестовых наборов входных данных путем сравнения 
полученных результатов с~хранимыми в~программе эталонными данными.
    
    Активное самотестирование может быть полезно при оценке работы ПП 
с~различной аппаратурой или в~различных операционных средах, при 
использовании различных браузеров, при проверке правильности работы 
программы после обновления некоторых ее функций. Недостатком данного 
вида самотестирования является то, что работа с~ограниченным объемом 
фиксированных входных данных тестирования не позволяет оценить полноту 
тестирования.
    
    Самотестирование на основе предлагаемого в~статье подхода включает 
в~себя ряд достоинств как первого, так и~второго вида самотестирования 
и~в~то же время свободно от присущих им недостатков. Прежде всего это 
обусловлено отсутствием необходимости заранее вычислять ожидаемые 
выходы, и~тем самым исключаются ошибки разработчиков тестов при 
подготовке эталонных данных для самотестирования.

\vspace*{-9pt}
    
\section{Заключение}

\vspace*{-3pt}

    Специфика тестирования приобретенных у~производителя ПП
     (ГИПП) широко обсуждается в~современных публикациях по 
программному обеспечению (именуемая в~англоязычной литературе как 
проблема тестирования ПП Ready to Use Software 
Product (RUSP)~\cite{7-bf} или как Commercial off-the-shelf  
(COTS)~\cite{18-bf}).
    
    Одна из основных проблем при этом состоит в~отсутствии достаточно 
подробных спецификаций продаваемых программ, что создает трудности 
покупателю в~тестировании этих программ, которое он, например, обязан 
выполнить перед включением их как компонентов в~более сложные системы с~повышенными требованиями к~надежности (авиационные, медицинские 
и~т.\,п.).
    
    В данной статье рассмотрена возможность преодоления проблемы 
отсутствия надежных данных о вычисляемых приобретаемыми программами 
функциях, используя при этом свойства случайной самоприводимости 
значительной части функций и~дополняя тем самым функциональное 
тестирование техникой случайного перебора входных наборов, что позволяет 
вычислять эталонные значения программ с~высокой достоверностью.
    
    Данный подход может быть использован для значительного числа 
вычислительных задач, таких\linebreak
 как преобразование Фурье, матричные 
вы\-чис\-ления, операции с~полиномами нескольких пе\-ре\-менных, вычисление 
различных полиномов над\linebreak
 конечными полями, широко используемых при 
вычислении хеш-функ\-ций в~задачах поиска и~хранения  
информации~\cite{15-bf} и~функций шифрования, используемых 
в~компьютерных сетях для обеспечения кибербезопасности. 
%
Существенно, 
что свойства случайной самоприводимости обеспечивают так-\linebreak же
самотестирование и~самокоррекцию со\-от\-вет\-ст\-ву\-ющих программ, поскольку 
вычисление правильных значений функций (определяемых по\linebreak
 большинству 
используемых наборов) можно интерпретировать и~как под\-тверж\-де\-ние 
появления правильных результатов вычисления (тестирование), и~как 
ис\-прав\-ле\-ние (за счет использования <<правила большинства>>). А~если 
в~со\-ста\-ве предлагаемой на рынок программы будет преду\-смот\-рен генератор 
случайных чисел и~указанный механизм принятия решения, это может 
существенно снизить за\-тра\-ты на тес\-ти\-ро\-ва\-ние после приобретения 
(например, перед интегрированием в~более слож\-ные сис\-те\-мы) 
и,~соответственно, повысить их привлекательность для потенциального 
покупателя.

\vspace*{-8pt}
    
  {\small\frenchspacing
 {%\baselineskip=10.8pt
 \addcontentsline{toc}{section}{References}
 \begin{thebibliography}{99}
 
 \vspace*{-1pt}
 
     \bibitem{1-bf}
     \Au{Басок Б.\,М., Головин~С.\,А., Захаров~В.\,Н., Френкель~С.\,Л.} Тестирование 
готового к~использованию про\-грам\-много продукта~// ИТ-Стан\-дарт: Электронный 
научный журнал, 2018. №\,1. 7~с.
{\sf  
http://journal.tc22.ru/\linebreak wp-content/uploads/2018/05/testirovanie\_gotovogo\_k\_\linebreak 
ispolzovaniyu\_programmnogo\_produkta.pdf}
     \bibitem{2-bf}
     \Au{Липаев В.\,В.} Тестирование компонентов и~комплексов программ.~---  
Москва--Берлин: Директ-Медиа, 2015. 528~с.
     \bibitem{3-bf}
     7~Types of software errors, that every tester should know~// Software Testing Help, 2018. 
{\sf www.softwaretestinghelp.\linebreak com/types-of-software-errors}.

\bibitem{7-bf} %4
     ГОСТ Р ИСО/МЭК 25051-2017. Информационные технологии. Системная 
и~программная инженерия. Требования и~оценка качества систем и~программно\-го 
обеспечения (SQuaRE). Требования к~качеству готового к~использованию программного 
продукта (RUSP) и~инструкции по тестированию.~--- М.: Стандартинформ, 2017. 32~с.
     \bibitem{4-bf} %5
     \Au{Barr E.\,T., Harman~M., McMinn~P., Shahbaz~M., Yoo~S.} The oracle problem in 
software testing: A~survey~// IEEE T.~Software Eng., 2015. Vol.~41. No.\,5.  
P.~507--525.
     \bibitem{5-bf} %6
     \Au{Lipton R.} New directions in testing~// 
      Distributed computing and cryptography~/
      Eds.\ J.~Feigenbaum, M.\,J.~Merritt.~---
      DIMACS ser. in discrete mathematics and 
theoretical computer science.~--- AMS, 1991. 
  Vol.~2. P.~191--202.
     \bibitem{6-bf} %7
     \Au{Blum M., Luby M., Rubinfeld~R.} Self-testing/correcting with applications to 
numerical problems~// 22nd ACM Symposium on Theory of Computing Proceedings.~--- New 
York, NY, USA: ACM Press, 1990. P.~73--83.
     
     \bibitem{8-bf} %8
     \Au{Natella R., Cotroneo D., Duraes~J.\,A., Madeira~H.} On fault representativeness of 
software fault injection~// IEEE T.~Software Eng., 2013. Vol.~39. No.\,1. P.~80--96.
     \bibitem{9-bf} %9
     \Au{Canfora G., Di Penta~M.} Testing services and service-centric systems: Challenges 
and opportunities~// IT Prof., 2006. Vol.~8. No.\,2. P.~10--17.

\bibitem{11-bf} %10
     \Au{Buck D., Hollingsworth~J.} An API for runtime code patching~// Int. 
J.~High Perform. C., 2000. Vol.~14. No.\,4. P.~317--329.
     \bibitem{10-bf} %11
     \Au{Barrantes E.\,G., Ackley~D.\,H., Forrest~S., Palmer~T.\,S., Stefanovic~D., 
Zovi~D.\,D.} Randomized instruction set emulation to disrupt binary code injection attacks~// 
10th ACM Conference on Computer and Communications Security Proceedings.~--- New York, 
NY, USA: ACM Press, 2003. P.~281--289.

 \bibitem{13-bf} %12
     \Au{Смирнов Н.\,В., Дунин-Барковский~И.\,В.} Курс теории вероятностей 
и~математической статистики для технических приложений.~--- Л.: Наука, 1969. 512~с.
     
     \bibitem{12-bf} %13
     \Au{Gemmell P., Lipton R., Rubinfeld~R., Sudan~M., Wigderson~A.}  
Self-testing/correcting for polynomials and for approximate functions~// 23rd ACM Symposium 
on the Theory of Computing Proceedings.~--- New York, NY, USA: ACM Press, 1991.  
P.~32--43.

\bibitem{19-bf} %14
     \Au{Bhattacharyya A., Dey~P.} Sample complexity for winner prediction in elections~// 
arXiv.org, 2016. \mbox{arXiv}:\linebreak 1502.04354 [cs.DS]. 
    
    
     \bibitem{15-bf} %15
     \Au{Carter L., Wegman~M.} Universal hash functions~// J.~Comput. Syst. Sci., 1979. 
Vol.~18. P.~143--154.

 \bibitem{14-bf} %16
     \Au{Nouber G., Nussbauer~H.} Self-correcting polynomial programs~// Reliab. 
Comput., 1996. Vol.~2. No.\,2. P.~139--145.
     \bibitem{16-bf} %17
     \Au{Dolev Sh., Frenkel~S.} Extending the scope of self-correcting~// 13th Conference 
(International) on Applied Stochastic Models and Data Analysis Proceedings. P.~458--462.
     \bibitem{17-bf} %18
     \Au{Басок Б.\,М., Красовский~В.\,Е.} Тестирование про\-грам\-мно\-го обеспечения.~--- 
М.: МИРЭА, 2010. 120~с.
     \bibitem{18-bf} %19
     \Au{Voas J., Charron F., Miller~K.} Robust software interfaces: Can COTS-based 
systems be trusted without them?~// 15th Conference (International) on Computer Safety, 
Reliability and Security Proceedings.~--- Vienna: Springer Verlag, 1996. P.~126--135.
     
 \end{thebibliography}

 }
 }

\end{multicols}

\vspace*{-3pt}

\hfill{\small\textit{Поступила в~редакцию 10.06.18}}

\vspace*{8pt}

%\pagebreak

%\newpage

%\vspace*{-28pt}

\hrule

\vspace*{2pt}

\hrule

%\vspace*{-2pt}

\def\tit{USING A PROBABILISTIC CALCULATION MODEL TO~TEST\\ ONE CLASS 
OF~READY-TO-USE SOFTWARE COMPONENTS\\ OF~LOCAL AND~NETWORK SYSTEMS}

\def\titkol{Using a probabilistic calculation model to test one class of 
ready-to-use software components of local and network systems}

\def\aut{B.\,M.~Basok$^1$, V.\,N.~Zakharov$^2$, and~S.\,L.~Frenkel$^3$}

\def\autkol{B.\,M.~Basok, V.\,N.~Zakharov, and~S.\,L.~Frenkel}

\titel{\tit}{\aut}{\autkol}{\titkol}

\vspace*{-11pt}


\noindent
$^1$MIREA~--- Russian Technological University, 78~Vernadskogo Ave., Moscow 119454, Russian 
Federation

\noindent
$^2$Federal Research Center ``Computer Science and Control'' of the Russian Academy of Sciences, 
44-2~Vavilov\linebreak
$\hphantom{^1}$Str., Moscow 119333, Russian Federation

\noindent
$^3$Institute of Informatics Problems, Federal Research Center ``Computer Sciences and Control'' of the 
Russian\linebreak
$\hphantom{^1}$Academy of Sciences, 44-2~Vavilov Str., Moscow 119333, Russian Federation


\def\leftfootline{\small{\textbf{\thepage}
\hfill INFORMATIKA I EE PRIMENENIYA~--- INFORMATICS AND
APPLICATIONS\ \ \ 2018\ \ \ volume~12\ \ \ issue\ 4}
}%
 \def\rightfootline{\small{INFORMATIKA I EE PRIMENENIYA~---
INFORMATICS AND APPLICATIONS\ \ \ 2018\ \ \ volume~12\ \ \ issue\ 4
\hfill \textbf{\thepage}}}

\vspace*{6pt}
    
    


\Abste{The paper discusses and analyzes the possibility of 
providing effective testing of ready-to-use software products that solve 
the task of calculating functions, in the absence of complete information 
necessary for traditional testing. Efficiency means the possibility of 
providing an arbitrarily high probability of detecting possible computational 
errors that were not detected by the output control as the number of 
inspections increases. As a~conceptual model of the proposed approach, 
the properties of functions with the random self-reducible function  
are used, that is, functions whose calculation on a~particular input set can 
be reduced to calculation on several randomly selected input sets.
The rationality of providing self-testability properties in ready-to-use 
software is substantiated.}

\KWE{software testing; self-testing}
    
\DOI{10.14357/19922264180407}

%\vspace*{-18pt}

\Ack
\noindent
The work was partly supported by
the Russian Foundation for Basic Research (projects 18-07-00669 and 18-29-03100).



%\vspace*{-3pt}

  \begin{multicols}{2}

\renewcommand{\bibname}{\protect\rmfamily References}
%\renewcommand{\bibname}{\large\protect\rm References}

{\small\frenchspacing
 {%\baselineskip=10.8pt
 \addcontentsline{toc}{section}{References}
 \begin{thebibliography}{99}
 


\bibitem{1-bf-1}
\Aue{Basok, B.\,M., S.\,A.~Golovin, V.\,N.~Zakharov, and S.\,L.~Frenkel.} 2018. 
Testirovanie gotovogo k ispol'zovaniyu programmnogo produkta [Testing of 
ready-to-use software product]. \textit{It-standart: Elektronnyy nauchnyy zh.} 
 [IT-Standart: Electronic Scientific~J.]  1. 7~p. Available at: {\sf  
http://journal.tc22.ru/wp-content/uploads/2018/05/\linebreak 
testirovanie\_gotovogo\_k\_ispolzovaniyu\_programmnogo\_\linebreak produkta.pdf} (accessed 
October~30, 2018).
\bibitem{2-bf-1}
\Aue{Lipaev, V.\,V.} 2015. \textit{Testirovanie komponentov i~kompleksov program} 
[Testing of components and software packages].  Moscow--Berlin: Direkt-Media. 
528~p.
\bibitem{3-bf-1}
\Aue{7~Types of software errors, that every tester should know}. \textit{Software 
Testing Help}. Available at: {\sf  
www.\linebreak softwaretestinghelp.com/types-of-software-errors} (accessed October~30, 
2018).

\bibitem{7-bf-1} %4
GOST R~ISO/MEK 25051-2017. Informatsionnyye tekhnologii. Sistemnaya 
i~programmnaya inzheneriya. Trebovaniya i~otsenka kachestva sistem 
i~programmnogo obespecheniya (SQuaRE). Trebovaniya k~kachestvu gotovogo 
k~ispol'zovaniyu programmnogo produkta (RUSP) i~instruktsii po testirovaniyu 
[Information technology. System and software engineering. Requirements and 
quality assessment of systems and software (SQuaRE). Requirements for the 
quality of ready-to-use software product (RUSP) and instructions for testing]. 
Moscow: Standardinform Publs. 32~p.

\bibitem{4-bf-1} %5
\Aue{Barr, E.\,T., M.~Harman, P.~McMinn, M.~Shahbaz, and S.~Yoo.} 2015. 
The oracle problem in software testing: A~survey. \textit{IEEE T.~Software Eng.} 
41(5):507--525. 
\bibitem{5-bf-1} %6
\Aue{Lipton, R.} 1991. New directions in testing.  \textit{Distributed 
computing and cryptography}. Eds.\ J.~Feigenbaum and M.\,J.~Merritt.
DIMACS ser. in 
discrete mathematics and theoretical computer science.  AMS. 2:191--202.
\bibitem{6-bf-1} %7
\Aue{Blum, M., M.~Luby, and R.~Rubinfeld.} 1990. Self-testing/correcting with 
applications to numerical problems. \textit{22nd ACM Symposium on Theory of 
Computing Proceedings}. New York, NY: ACM Press. 73--83.

\columnbreak

\bibitem{8-bf-1}
\Aue{Natella, R., D.~Cotroneo, J.\,A.~Duraes, and H.~Madeira.} 2013. On fault 
representativeness of software fault injection. \textit{IEEE T.~Software Eng.} 
39(1):80--96.
\bibitem{9-bf-1}
\Aue{Canfora, G. and V.~Di~Penta.} 2006. Testing services and servi ce-centric 
systems: Challenges and opportunities. \textit{IT Prof.} 8(2):10--17.

\bibitem{11-bf-1} %10
\Aue{Buck, D., and J.~Hollingsworth.} 2000.  An API for runtime code patching.   
\textit{Int. J.~High Perform. C.} 14(4):317--329.

\bibitem{10-bf-1} %11
\Aue{Barrantes, E.\,G., D.\,Y.~Ackley, T.\,S.~Palmer, D.~Stefanovic, and 
D.~Zovi.} 2003. Randomized instruction set emulation to disrupt binary code 
injection attacks. \textit{10th ACM Conference on Computer and Communications 
Security Proceedings.} New York, NY: ACM Press. 281--289.

\bibitem{13-bf-1} %12
\Aue{Smirnov, N.\,V., and I.\,V.~Dunin-Barkovskiy.} 1969. \textit{Kurs teorii 
veroyatnostey i~matematicheskoy statistiki dlya tekhnicheskikh prilozheniy} 
[Course in the probabilities theory and mathematical statistics for technical 
applications]. Leningrad: Nauka. 512~p.
\bibitem{12-bf-1} %13
\Aue{Gemmell, P., R.~Lipton, R.~Rubinfeld, M.~Sudan, and A.~Wigderson.} 
1991. Self-testing/correcting for polynomials and for approximate functions. 
\textit{23rd ACM Symposium on the Theory of Computing Proceedings}. New 
York, NY: ACM Press. 32--43.
\bibitem{19-bf-1} %14
\Aue{Bhattacharyya, A., and P.~Dey.} 2016. Sample complexity for winner 
prediction in elections. \mbox{\textit{arXiv.org}}.  arXiv:\linebreak 1502.04354 [cs.DS].


\bibitem{15-bf-1}
\Aue{Carter, L., and M.~Wegman.} 1979. Universal hash functions. 
\textit{J.~Comput. Syst. Sci.} 18:143--154.

\bibitem{14-bf-1} %16
\Aue{Nouber, G., and H.~Nussbauer.} 1996. Self-correcting polynomial programs. 
\textit{Reliab. Comput.} 2(2):139--145.
\bibitem{16-bf-1} %17
\Aue{Dolev, Sh., and S.~Frenkel.} 2009. Extending the scope of self-correcting. 
\textit{13th Conference (International) on Applied Stochastic Models and Data 
Analysis Proceedings}. 458--462.
\bibitem{17-bf-1} %18
\Aue{Basok, B.\,M., and V.\,E.~Krasovskiy.} 2010. Testirovanie programmnogo 
obespecheniya [Software testing].  Moscow: MIREA. 120~p.
\bibitem{18-bf-1} %19
\Aue{Voas J., F.~Charron, and K.~Miller.} 1996.  Robust software interfaces: Can 
COTS-based systems be trusted without them? \textit{15th Conference 
(International) on Computer Safety, Reliability and Security Proceedings}. Vienna: 
Springer Verlag. 126--135.
  
\end{thebibliography}

 }
 }

\end{multicols}

\vspace*{-6pt}

\hfill{\small\textit{Received September 20, 2018}}

%\pagebreak

\vspace*{-24pt}
      
    
    \Contr
    
\noindent
\textbf{Basok Boris M.} (b.\ 1948)~--- Candidate of Science (PhD) in technology, associate professor, 
MIREA~--- Russian Technological University, 78~Vernadskogo Ave., Moscow 119454, Russian Federation; 
\mbox{VM\_E@mail.ru} 

%\vspace*{3pt}

\noindent
\textbf{Zakharov Victor N.} (b.\ 1948)~--- Doctor of Science in technology, associate professor; Scientific 
Secretary, Federal Research Center ``Computer Science and Control'' of the Russian Academy of Sciences, 
44-2~Vavilov Str., Moscow 119333, Russian Federation; \mbox{vzakharov@ipiran.ru}


%\vspace*{3pt}

\noindent
\textbf{Frenkel Sergey L.} (b.\ 1951)~--- Candidate of Science (PhD) in technology, associate professor, 
senior scientist, Institute of Informatics Problems, Federal Research Center ``Computer Sciences and Control'' 
of the Russian Academy of Sciences, 44-2~Vavilov Str., Moscow 119333, Russian Federation; 
fsergei51@gmail.com 

    
\label{end\stat}

\renewcommand{\bibname}{\protect\rm Литература}  