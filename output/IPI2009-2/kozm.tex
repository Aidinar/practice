\def\stat{kozm}

\def\tit{РЕЗЕРВНОЕ КОПИРОВАНИЕ, ИСПОЛЬЗУЮЩЕЕ СНИМКИ}
\def\titkol{Резервное копирование, использующее снимки} 

\def\autkol{В.\,А.~Козмидиади}
\def\aut{В.\,А.~Козмидиади$^1$}

\titel{\tit}{\aut}{\autkol}{\titkol}

%{\renewcommand{\thefootnote}{\fnsymbol{footnote}}\footnotetext[1]
%{Работа выполнена при поддержке РФФИ, проекты 08--07--00152 и 08--01--00567.}}

\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{Институт проблем
информатики Российской академии наук, v.kozmidiady@gmail.com}


\Abst{Рассмотрена сложность резервного копирования (backup), 
использующего различия  между двумя последовательными снимками (snapshots). 
Предложены формальная модель, в которой можно точно поставить проблему, а также 
алгоритм, который решает эту проблему за почти линейное время от 
объема различий.}

\KW{резервное копирование (backup); снимки (snapshots); восстановление файловой 
системы; журнал файловой системы}

  \vskip 24pt plus 9pt minus 6pt

      \thispagestyle{headings}

      \begin{multicols}{2}

      \label{st\stat}

\section{Введение}

      Под \textit{резервным копированием} (\textit{backup})~[1--4] понимается 
создание копии данных, предназначенной для их восстановления в 
оригинальном месте при повреждении или разрушении. Резервное копирование 
выполняется периодически,  поэтому в случае нарушения данных содержимое 
сохраненной копии может отставать от оригинальных данных.  Резервное 
копирование предполагает наличие оригинала, который выступает 
передатчиком, и копии, играющей роль приемника. 
      
      Далее будет рассматриваться только резервное копирование файловой 
системы.  Резервное копирование обычно занимает значительное время, 
поэтому на это время нельзя запретить доступ пользователей к файловой 
системе. Но тогда при копировании может происходить создание, изменение, 
удаление файлов и директорий, а это может привести к тому, что созданная 
копия будет неконсистентной, т.\,е.\ данные могут оказаться не 
согласованными друг с другом. Чтобы избежать этого создают \textit{снимок} 
(\textit{snapshot}) файловой системы~[5, 6]. Снимок можно рассматривать как 
доступную только для чтения файловую систему, данные которой есть 
замороженные в определенный момент времени данные исходной системы. 
Изготовление снимка состоит из двух этапов. Перед изготовлением 
завершаются все выполняющиеся запросы к файловой системе. Далее на очень 
небольшой промежуток времени~$T$ задерживаются все новые запросы и 
делается сам снимок. Промежуток времени $T$ для многих файловых сис\-тем является константой и 
имеет очень небольшое значение. Предполагается, что снимок содержит 
консистентные данные, поэтому при резервном копировании целесообразно 
использовать снимок. Таким образом, резервирование данных обеспечивается 
следующим образом. Периодически из\-го\-тав\-ли\-ва\-ют\-ся снимки файловой 
сис\-те\-мы, после чего выполняется резервное копирование, т.\,е.\ происходит 
синхронизация, замена старого снимка на новый. Если на оригинальной 
сис\-те\-ме происходит отказ, приведший к искажению или потере данных, 
осуществляется восстановление файловой системы по последнему 
сохраненному ее снимку.
      
      Передача всего снимка фактически означает передачу всех данных 
файловой системы. Делать это, пусть даже с низкой частотой, недопустимо при 
сколь-нибудь значительных объемах файловой сис\-те\-мы. Если частота  
синхронизации не слишком низка, объем сделанных изменений обычно 
невелик: он на много порядков меньше объема всей файловой сис\-те\-мы. 
Поэтому хотелось бы \mbox{найти} способ передавать только изменения, которые 
отличают предыдущую копию от текущего оригинала. При этом будем 
предполагать, что созданная копия не изменяется до следующего резервного 
копирования. Обычно сис\-те\-мы порождения снимков дают возможность 
сохранять несколько снимков, сделанных в разные моменты времени. Поэтому 
можно считать, что в распоряжении имеется два снимка. Первый снимок 
соответствует копии, хранящейся на приемнике и сделанной в предыдущем 
цикле резервного копирования. Второй снимок соответствует копии, которая 
должна быть создана в следующем цикле. Для передачи изменений нужно 
определить, в чем эти снимки различаются.  Некоторые изменения могут 
касаться структуры файловой сис\-те\-мы, например добавление и удаление 
файлов и директорий. Такие изменения приводят к необходимости передачи 
информации о произведенных изменениях структуры и, если это надо, 
передачи данных файлов.  Другие изменения сводятся к модификации данных 
файлов. Это приводит к передаче информации о сделанных модификациях. В 
данной работе не будет рассматриваться вопрос об экономной передаче данных 
или модификации этих данных. Это совершенно отдельная тема; сошлемся 
здесь на работы по сжатию данных~[7] и  алгоритмы передачи, которые 
учитывают наличие на приемнике более старой версии данных~[8]. В статье 
рассматривается только проблема поиска различий между снимками. Понятно, 
что при отсутствии дополнительной информации для этого нужно рассмотреть 
оба снимка. Если число файлов и директорий в первом снимке равно~$N_1$, а 
во втором снимке~--- $N_2$, для выяснения различий потребуется никак не 
меньшая сложность, чем $O(N_1+N_2)$. Цель настоящей работы~--- привлечь 
дополнительную информацию (ниже она названа журналом работы файловой 
сис\-те\-мы), чтобы получить сложность~$O(\Delta)$. Здесь $\Delta$~--- 
количество измененных, созданных или удаленных файлов либо директорий 
между двумя снимками. Сложность этой задачи подчеркнута в~[9].
      
      При рассмотрении будем ориентироваться на UNIX-подобные файловые 
системы, например такие, как~[10].

\vspace*{-5pt}

\section{Определения и формулировка задачи}

\vspace*{-2pt}

      Приведенные ниже определения дают возможность точно 
сформулировать решаемую в работе задачу.

\vspace*{-5pt}

\subsection{$G$~--- класс DAG}

      Пусть $G$~--- класс непустых направленных ацик\-ли\-че\-ских графов 
(directed acyclic graphs, DAG), которые удовлетворяют следующим 
ограничениям:
      \begin{itemize}
\item в графе выделена вершина~$R$ (корень), из которой доступны все 
остальные вершины;
\item каждой вершине~$V$ приписан номер (натуральное число), причем 
разным вершинам приписаны разные номера. Вершины мы будем 
отож\-де\-ст\-влять с их номерами;
\item каждой вершине приписаны данные;
\item только листья могут иметь несколько входящих дуг;
\item каждая вершина имеет тип $t\in \{D, F\}$. Тип удовлетворяет следующим 
свойствам:
\begin{enumerate}[(1)]
\item тип $D$ могут иметь только вершины, име\-ющие не более одной 
входящей дуги;\\[-13pt]
\item тип $F$ могут иметь только листья;\\[-13pt]
\item вершина-корень имеет тип~$D$;\\[-13pt] 
\end{enumerate}
\item каждая дуга $V_1\rightarrow V_2$ имеет имя. Из вершины не могут 
исходить две дуги с одинаковыми именами.
\end{itemize}

\vspace*{-4pt}

\subsection{Семантика}

\vspace*{-2pt}

      Каждый член $g\in G$~--- это некоторый граф файловой системы. 
Вершинами~$V$ этого графа являются директории и файлы. Дуги 
$V_1\rightarrow V_2$ соответствуют отношениям <<Директория~$V_1$ 
содержит~$V_2$~--- другую директорию или файл>>. 
\begin{enumerate}[1.]
\item Номер вершины~--- это номер ее индексного дескриптора (inode 
number). Индексный дескриптор является описателем отдельной директории 
или файла.\\[-14pt]
\item Тип вершины~--- указание на то, соответствует ли она директории 
($D$) или файлу~($F$).\\[-14pt]
\item Имя дуги $V_1\rightarrow V_2$~--- это имя директории или 
файла~$V_2$.\\[-14pt]
\item Если вершина имеет тип~$D$ (директория), то данные, приписанные 
вершине,~--- это метаданные директории\footnote{Метаданные директории 
включают права доступа владельца и других пользователей, время создания, последней 
модификации и~т.\,д. Метаданные файла дополнительно содержат размер файла и другие 
параметры.}. Если вершина имеет тип~$F$ (файл), то данные, приписанные 
вершине,~--- это метаданные файла и его содержание.
\end{enumerate}

      Граф файловой системы может не быть деревом из-за наличия жестких 
ссылок\footnote{Жесткая ссылка~--- это ссылка, содержащаяся в директории и 
указывающая на принадлежащий этой директории файл, точнее на его индексный 
дескриптор. Жесткая ссылка включает в себя имя файла. Использование жестких ссылок~--- 
стандартный способ организации файловой системы. На индексный дескриптор одного 
файла может ссылаться несколько жестких ссылок. Одно из применений~--- введение 
равноправных синонимичных имен файла. Жесткие ссылки на директории не допускаются.} 
(hard links) и символических ссылок\footnote{Символическая ссылка, как и жесткая 
ссылка, содержит имя файла и находится в директории, но, в отличие от жесткой ссылки, 
указывает не на индексный дескриптор, а на другую жесткую или символическую ссылку. 
Поэтому, если в файловой системе не предприняты специальные меры, возможно 
образование циклов из символических ссылок.} (symbolic links). Далее предполагается, 
что в файловой системе отсутствуют символические ссылки, поэтому, как 
нетрудно видеть, ее граф является DAG.

\vspace*{-4pt}
\subsection{Номера индексных дескрипторов и~их~свойства}

\vspace*{-2pt}

      Номер индексного дескриптора является уникальным идентификатором 
элемента файловой\linebreak
\vspace*{-12pt}
\pagebreak

\noindent
 сис\-те\-мы, т.\,е.\ индексного дескриптора, соответствующего 
файлу или директории.  Свойства номеров индексных дескрипторов:
      \begin{itemize}
\item номера индексных дескрипторов не используются повторно, т.\,е.\ если 
какой-либо элемент имел некоторый номер, а далее был удален, то этот 
номер никогда в дальнейшем не будет присвоен новому элементу;
\item номер индексного дескриптора элемента присваивается ему при 
создании и остается неизменным до тех пор, пока элемент не будет удален. 
Отсюда следует, что:
\begin{enumerate}[(1)]
\item изменение данных или метаданных элемента сохраняет номер 
элемента неизменным;
\item изменение состава директории сохраняет номер индексного 
дескриптора директории неизменным;
\item перемещение и переименование элемента с помощью функции 
rename($\ldots$) не изменяет номер элемента. Если перемещаемый 
элемент является директорией, при перемещении подчиненные 
элементы также не меняют своих номеров;
\end{enumerate}
\item если файл имеет несколько ссылок, номер индексного дескриптора 
файла не зависит от использованного пути к файлу. 
\end{itemize}

\subsection{Операции над $g\in G$}
     
     Обозначим через $V\in g$, $g\in G$, отношение <<$V$ является вершиной 
графа~$g$>>. Ниже рассматривается набор операций над графами $g\in G$. 
Операция~$O$ может быть применена к графу~$G$, если $O(g)\in G$.
     \begin{enumerate}
     \item $R(V_1, V_2)$~--- удаление дуги $V_1\rightarrow V_2$. 
Вершина~$V_1$ должна иметь тип~$D$, а вершина~$V_2$~--- тип~$F$ или~$D$. 
Это означает, что удаляемая дуга может начинаться только в директории. Если 
$V_2$ имеет тип~$F$ (в этом случае в~$V_2$ может вести несколько дуг), а 
удаляемая дуга~--- это единственная дуга, ведущая в~$V_2$, то вместе с дугой 
удаляется и вершина~$V_2$. Таким образом, вместе с удалением последней 
жесткой ссылки удаляется и сам файл. Если~$V_2$ имеет тип~$D$ (в этом 
случае в~$V_2$ может вести только одна дуга), то $V_2$ должна быть листом, 
т.\,е.\ несмотря на то, что ей соответствует директория, она должна быть пуста, 
в ней не может начинаться ни одна дуга. 
\item $A_E(V_1, V_2, n)$~--- добавление дуги $V_1\rightarrow V_2$. 
До\-бав\-ля\-емой дуге присваивается имя~$n$. Вершина~$V_1$ должна иметь 
тип~$D$, а вершина~$V_2$~--- тип~$F$. Это добавление жесткой ссылки.
\item $A_V(V_1, V_2, n)$~--- добавление дуги $V_1\rightarrow V_2$ и 
вершины~$V_2$, $V_2\notin g$. Вершина $V_2$ может иметь любой тип, а 
вершина~$V_1$ должна иметь тип~$D$. До\-бав\-ля\-емой дуге присваивается 
имя~$n$. Создание новой директории или файла.
\item $M(V_1, V_2, V_3, n)$~--- перемещение дуги. Создается дуга 
$V_3\rightarrow V_2$, ей присваивается имя~$n$. Дуга $V_1\rightarrow V_2$ 
удаляется. Вершины~$V_1$ и~$V_3$ должны иметь тип~$D$. Это 
переименование с перемещением. Файл (директория)~$V_2$, который 
раньше находился в директории~$V_1$, получает новое имя и теперь 
размещается в директории~$V_3$.
\item $C(V)$~--- изменение метаданных и/или содержания вершины. 
\end{enumerate}
      
      Операции имеют следующие свойства:
      \begin{itemize}
\item ни одна из операций не может изменить ни тип вершины, ни ее номер;
\item ни одна из операций не может удалить вер\-ши\-ну-корень. 
\end{itemize}

\subsection{Журнал работы файловой системы}

      Этот журнал представляет собой линейно упорядоченное (по 
возрастанию номеров) множество номеров индексных дескрипторов, 
со\-про\-вож\-да\-емых набором признаков и номеров (параметров). Набор признаков 
следующий:
      \begin{itemize}
\item Create, создание вершины;
\item Del, удаление вершины;
\item LCount, удаление дуги без удаления вершины (изменение числа 
жестких ссылок на файл без удаления файла);
\item Mod, изменение метаданных (для директории) либо метаданных или 
содержания (для файла);
\item Move, перемещение дуги.
\end{itemize}

      Таким образом, журнал представляет собой последовательность 
записей; запись содержит номер индексного дескриптора и набор признаков.
      
      Каждая из перечисленных выше операций добавляет в журнал 
определенный номер или номера, если их там не было, и устанавливает для них 
некоторые признаки, а некоторые устраняет. Если какой-то признак требуется 
установить, а он уже установлен, никаких действий не предпринимается. 
Аналогично~--- для устранения признаков. Например, если для вершины нужно 
установить признак Del, а для нее уже установлены признаки Create, Mod, их 
      \begin{table*}\small
      \begin{center}
      \Caption{Операции, добавляемые номера и признаки
       \label{t1koz}}
       \vspace*{2ex}
       
       \begin{tabular}{|l|c|c|}
       \hline
\multicolumn{1}{|c|}{Операция}&Добавляемый номер&Устанавливаемый 
признак \\
\hline
$R(V_1, V_2)$ без удаления вершины $V_2$&$V_2$&LCount\\
$R(V_1, V_2)$ с удалением вершины $V_2$&$V_2$&Del\\
$A_E(V_1, V_2, n)$&$V_2$&Create\\
$A_V(V_1, V_2, n)$&$V_2$&Create\\
$M(V_1, V_2, V_3, n)$&$V_2$&Move\\
$C(V)$&$V$&Mod\\
\hline
\end{tabular}
\end{center}
\end{table*}
следует устранить. Ниже перечислены допустимые комбинации установленных 
признаков:
\pagebreak

\noindent
      \begin{itemize}
\item Create;
\item Del;
\item $[$LCount$]$, $[$Mod$]$, $[$Move$]$.
\end{itemize}

      Таблица~\ref{t1koz} описывает эти добавляемые при выполнении 
операций номера и признаки.

      Рассмотрим $S_1$ и $S_2$~--- два последовательных снимка файловой 
сис\-те\-мы. Снимок $S_2$ получается из $S_1$ с помощью определенной 
по\-сле\-до\-ва\-тель\-ности операций $O_1, O_2, \ldots , O_n$, которые были 
перечислены выше. Вначале журнал файловой сис\-те\-мы пуст. Каж\-дая 
операция~$O_i$ ($1 \leq i \leq n$), возможно, добавляет в журнал один или 
несколько номеров. Для некоторых номеров устанавливаются признаки. 
В~итоге обработки всей последовательности операций достигается 
снимок~$S_2$ и образуется журнал, который описывает изменения, 
произошедшие за это время. Если $V(S)$~--- множество номеров, 
присутствующих в снимке~$S$, то множество номеров в журнале есть 
подмножество $V(S_1)\cup V(S_2)$. Журнал работы файловой сис\-те\-мы между 
двумя последовательными снимками будем обозначать через $J(S_1, S_2)$.
      
      \smallskip
\noindent
{\sf \textbf{Примечание.} Описанная структура журнала работы файловой 
системы  неестественна и очень неудобна для работы. Но эта структура 
определяется в основном соображениями производительности. Напри\-мер, был 
бы естественным журнал, пред\-став\-ля\-ющий собой последовательный файл. 
Хвост этого файла постоянно пополняется описаниями выполненных операций. 
Такое решение очень неэффективно. Файл может оказаться очень большим, 
если снимки делаются редко. Только операции чтения не требуют записи в этот 
файл. Кроме того, следует учиты\-вать, что обычно файловая система может 
одновременно выполнять несколько операций. Особенно это важно для 
распределенных файловых систем. Журнал с последовательной организацией 
оказывается <<узким местом>>, так как является совместно используемым 
ресурсом, требующим монопольного захвата. В то же время индексные 
дескрипторы файлов и директорий, находящиеся в работе, размещаются в 
памяти. Введение в них дополнительных полей не вызывает затруднений. 
Поэтому разработчику средств резервного копирования трудно предлагать 
удобную для него структуру журнала, ему приходится соглашаться с тем, что 
согласны сделать для него разработчики файловой системы.}

\subsection{Формулировка задачи}

      Пусть имеются $S_1$ и $S_2$~--- два последовательных снимка файловой 
системы~--- и журнал работы файловой системы~$J(S_1, S_2)$. Требуется 
построить такую последовательность операций\linebreak
(возможно, отличающуюся от 
исходной), которая $S_1$ переводит в~$S_2$. Эта работа выполняется на 
передатчике. Предполагается, что на приемнике есть файловая система, 
состояние которой совпадает со снимком~$S_1$. Тогда, передавая на приемник 
построенную последовательность операций и выполняя на приемнике эти 
операции, можно привести состояние файловой системы преемника в 
состояние, соответствующее~$S_2$.
      
      \smallskip
      Требуется оценить сложность построения нужной последовательности 
операций. Но чтобы оценить сложность, следует описать средства, которые 
можно применять. К этому описанию и перейдем. 
      
      \subsection{Инструментарий и оценка сложности}
      
      При построении требуемой по\-сле\-до\-ва\-тель\-ности операций допускается 
применение любых стандартных для UNIX функций, используемых для 
доступа к файловой системе. Набор таких функций содержится в~[10]. Кроме 
того, можно применять специальные функции доступа к снимкам и журналу. 
Примерный перечень этих функций приведен ниже. 

\begin{center}
\textit{Принятые при описании функций обозначения}
\end{center}

\noindent
{\tabcolsep=3pt
\begin{tabular}{lp{67.5mm}}
$S$ & снимок\\
$S_1$, $S_2$ &  два последовательных снимка\\
$V$ &  номер индексного дескриптора (здесь отож\-де\-ст\-вле\-ны индексные 
дескрипторы, их номера и вершины графа снимка)\\
$V(S)$ & множество номеров индексных дескрипторов, присутствующих в 
снимке~$S$
\end{tabular}
}

\noindent
{\tabcolsep=3pt
\begin{tabular}{lp{72.5mm}}
$n_J$ & количество упомянутых номеров индексных дескрипторов в журнале 
работы файловой сис\-те\-мы~$J(S_1, S_2)$\\
$N$ & количество номеров в $V(S_1)\cup V(S_2)$
\end{tabular}
}

\subsection{Описание функций}

\noindent
\begin{description}
\item[$\mathrm{get}\_\mathrm{j}(V)$.] Функция возвращает запись, 
сле\-ду\-ющую за записью с номером индексного дескриптора, т.\,е.\ с 
вершиной~$V$. $\mathrm{get}\_\mathrm{j}(-1)$ дает первую запись.
\item[$\mathrm{is}\_\mathrm{vertex}(V, S)$.] Функция-предикат; возвращает 
\textbf{true}, если $V\in V(S)$, \textbf{false}~--- в противном случае.
\item[$\mathrm{type}(V, S)$.] Функция возвращает тип вершины~$V$ в 
снимке~$S$. Если $V\in  V(S_1) \cap V(S_2)$, то $\mathrm{type}(V, S_1) = 
\mathrm{type}(V, S_2)$.
\item[$\mathrm{name}(V_1, V_2, S)$.] Функция возвращает имя дуги 
$V_1\rightarrow V_2$ в снимке~$S$.
\item[$\mathrm{path}(V, S)$.] Функция возвращает некоторый путь от 
вершины-корня до~$V$ в снимке~$S$.
\item[$\mathrm{pred}(V, S)$.] Функция возвращает множество вершин 
снимка~$S$, предшествующих вершине~$S$.
\item[$\mathrm{succ}(V, S)$.] Функция возвращает множество вершин 
снимка~$S$, которые являются непосредственными потомками вершины~$V$ 
в~$S$. Эта функция напоминает библиотечную функцию readdir($\ldots$).
\end{description}
      
      Выполнение всех этих функций, кроме первой, 
$\mathrm{get}\_\mathrm{j}(V)$, есть $O(V(S))$. Функция 
$\mathrm{get}\_\mathrm{j}(V)$ выполняется на константное время.
      
      \smallskip

      \noindent
{\sf \textbf{Примечание.}\
 Функции pred(\,) и succ(\,) следовало бы заменить 
парами функций. Первая функция возвращает первый элемент списка, а 
вторая~--- следующий по указанию предыдущего.}
      
\subsection{Оценки сложности }

      Мерой сложности, используемой для оценки построения 
последовательности операций, будем считать число вызовов стандартных и 
специальных функций.

\section{Граф операций}

      Граф операций строится на передатчике по снимкам $S_1$, $S_2$ и 
журналу работы файловой сис\-те\-мы~$J(S_1, S_2)$. Далее этот граф используется 
для того, чтобы привести файловую систему приемника в состояние, 
идентичное снимку~$S_2$ передатчика. Граф операций является DAG, как это 
будет ясно из дальнейшего.

\vspace*{-3pt}
\subsection{Вершины графа операций}
\vspace*{-1pt}

      Граф операций состоит из вершин, которым сопоставлены номера 
индексных дескрипторов. Множество его вершин включает:
      \begin{itemize}
\item все вершины из~$S_1$, которые упомянуты в журнале~$J(S_1, S_2)$. 
Эти вершины соответствуют элементам~$S_1$ (файлам и директориям), 
которые были изменены, созданы или удалены в промежутке времени от 
изготовления~$S_1$ до изготовления~$S_2$;\\[-15pt]
\item вершины из~$S_1$, которые не упомянуты в журнале~$J(S_1, S_2)$, но 
находятся на путях, ведущих от корневой вершины~$R$ к вершинам, уже 
включенным в граф операций. 
\end{itemize}

      Последнее нужно для того, чтобы можно было построить полный путь 
от~$R$ к каждой вершине графа операций. Полное имя  состоит из (прос\-тых) 
имен, разделенных символами <</>> (UNIX-по\-доб\-ные системы)  или 
<<$\backslash$>> (Windows).  Если взять полный путь от корневой 
вершины~$R$ к некоторой вершине, принадлежащей $S_1$ или $S_2$, то полное 
имя образуется из имен, приписанных дугам, составляющим этот путь.  Даже 
если файловые системы приемника и передатчика идентичны, номера 
индексных де\-скрип\-то\-ров их соответствующих элементов могут быть различны, 
в отличие от имен. Поэтому, когда передатчик (оригинал) требует, чтобы 
приемник выполнил какие-либо действия над своей файловой системой, 
указания должны формулироваться с использованием имен, а не номеров 
индексных де\-скрип\-то\-ров. 

\vspace*{-3pt}
\subsection{Дуги графа операций}
\vspace*{-1pt}

      Эти дуги соответствуют отношению <<родитель\,--\,непосредственный 
потомок>> либо в~$S_1$, либо в~$S_2$. Каждой дуге приписано имя дуги и 
вектор операций, возможно пустой. Элементы вектора операции описаны в 
разд.~2.4. Некоторые операции со\-про\-вож\-да\-ют\-ся дополнительными 
параметрами. 
      
      Граф операций является DAG, так как таковыми являются~$S_1$ 
и~$S_2$.

\vspace*{-3pt}
\subsection{Конфликтные ситуации}
\vspace*{-1pt}

      Конфликт, который приводит к необходимости введения временного 
имени, заключается в том, что в какой-либо директории нужно создать элемент 
(директорию или файл) с некоторым именем, а в этой директории уже 
содержится элемент с тем же именем. Поскольку в снимке~$S_2$ создаваемый 
элемент существует, то конфликт имеет временный характер~--- мешающий 
элемент должен быть переименован, удален или перенесен. Поэтому 
создаваемому элементу можно присвоить временное имя, а после завершения 
операций над ме\-ша\-ющим элементом заменить временное имя настоящим. 
Заметим, что контекст конфликта~--- всегда директория.

\vspace*{-2pt}
\subsection{Синхронизация приемника и~передатчика}
\vspace*{-1pt}

      Предположим, что на приемнике находится файловая система в 
состоянии, соответствующем снимку~$S_1$. Для того чтобы привести ее в 
состояние, идентичное снимку~$S_2$ передатчика (их синхронизацию), 
требуется обойти вершины графа операций в определенном порядке, 
перемещаясь по дугам и выполняя операции, приписанные дугам.

\vspace*{-3pt}
\section{Построение графа операций}
\vspace*{-1pt}

      Следующие предположения обычно выполняются для многих файловых 
систем, кроме того, они нужны, чтобы сделать оценки сложности:  
      \begin{itemize}
\item содержимое журнала работы файловой системы~$J(S_1, S_2)$ 
находится в оперативной памяти;\\[-15pt]
\item все промежуточные деревья и сам граф операций также размещаются в 
оперативной памяти;\\[-15pt]
\item при оценках сложности алгоритмов предполагается, что для всех 
номеров-вершин графа операций строится $B$-дерево. Ключом этого 
$B$-дерева является номер, а значением~--- указатель размещения 
экземпляра структуры, описывающей вершину. В связи с этим появляются 
логарифмические оценки;\\[-15pt]
\item при отказе приемника после его восстановления выполняется возврат к 
содержимому его файловой системы в соответствии со снимком~$S_1$. Это 
занимает очень мало времени. В файловой системе ZFS (Zettabyte File System)
это достигается с 
помощью команды `zfs rollback~$S$'~[11]. Поэтому изменения можно 
делать непосредственно в файловой системе, не используя временные файлы 
и их последующее переименование.
\end{itemize}

\subsection{Фазы построения}

      Построение разбивается на следующие фазы:
      \begin{description}
\item[Фаза~1.] Построение дерева номеров индексных дескрипторов 
($I$-дерева).
\item[Фаза~2.] Построение промежуточного дерева~$M$.
\item[Фаза~3.] Построение окончательного графа (графа операций).
\end{description}

\smallskip

\noindent
{\sf \textbf{Примечание.} 
Разбиение на приведенные фазы сделано для 
упрощения изложения. Выполнение некоторых фаз можно совместить 
(возможно, что все их можно уложить в одну фазу).}

\vspace*{-3pt}
\subsubsection{Фаза~1 (построение $I$-дерева)} %4.1.1 

      На этой фазе строится дерево, вершины которого~--- только номера 
из~$S_1$, находящиеся в журнале~$J(S_1, S_2)$, т.\,е.\ из $V(S_1)\cap V(J(S_1, 
S_2))$. Это дерево имеет в качестве корневой вершину~$R$ и является 
минимальным поддеревом~$S_1$, содержащим указанные вершины из 
$V(S_1)\cap V(J(S_1, S_2))$. При построении для каждой вершины из $V(S_1)\cap 
V(J(S_1, S_2))$ вычисляется полный путь к ней от~$R$ и этот путь укладывается 
в дерево. В $I$-дереве каждой дуге приписано имя, взятое из~$S_1$. Дугам, 
ведущим в вершины, присутствующие в журнале, приписывается вектор 
операций из журнала для этих вершин, а остальным~--- пустой вектор 
операций.

      \smallskip
      
      \noindent
      \textbf{Алгоритм построения.} Последовательно анализируются 
номера из журнала. Обрабатываются только те из них, которые 
принадлежат~$S_1$. Для каждого такого номера выполняются следующие 
действия:
вычисляется полный путь в~$S_1$ от вершины~$R$ до вершины с этим 
номером. Этот путь состоит из номеров, причем первый номер~--- номер 
корневой вершины~$R$, а все номера на пути принадлежат~$S_1$. 
Анализируется $I$-дерево, уже построенное к этому моменту. Возможны 
два случая, описанные ниже:
\begin{enumerate}[(1)]
\item обрабатываемый номер еще отсутствует в $I$-де\-ре\-ве. В~$I$-дерево 
включается та часть пути, которая в дереве отсутствует. Каждой 
до\-бав\-лен\-ной дуге, ведущей в промежуточную вершину, приписывается имя 
в вычисленном полном пути и пустой вектор операций. Дуге, ведущей в 
добавленную вершину, приписывается имя в вычисленном полном пути и 
вектор операций из журнала;\\[-15pt]
\item обрабатываемый номер уже присутствует в $I$-де\-ре\-ве (в этом случае 
дуге, ведущей в эту вершину, обязательно приписан пустой вектор 
операций). Этой дуге приписывается вектор операций из журнала.
\end{enumerate}

Векторы операций, которые присвоены дугам в $I$-дереве, содержат только 
операции, при\-сут\-ст\-ву\-ющие в журнале, а именно:
\begin{itemize}
\item Mod (изменение содержимого или метаданных файла);\\[-15pt]
\item  LCount (изменение числа ссылок на файл без удаления файла);\\[-15pt]
\item  Move (перемещение файла);\\[-15pt]
\item  Del (удаление файла);\\[-15pt]
\item  Create (создание файла);\\[-15pt]
\item  Mod (изменение метаданных директории);\\[-15pt]
\item  Move (перемещение директории);\\[-15pt]
\item  Del (удаление директории);\\[-15pt]
\item  Create (создание директории).
\end{itemize}

      \smallskip

      \noindent
      \textbf{Сложность алгоритма.} $O(n_J \log (N))$.

\subsubsection{Фаза~2 (построение дерева~$M$)} %4.1.2 

      На этой фазе $I$-дерево расширяется до $M$-дерева за счет включения 
дополнительных дуг, связанных с перемещением файлов и директорий. 
      В~$I$-дереве\linebreak
      обрабатываются дуги с операциями Move <<Перемещение 
файла>> или Move <<Перемещение директории>>. Если перемещение 
происходит в пределах~$S_1$, ($V_3\in V(S_1))$, дуга <<до перемещения>>\linebreak 
удаляется, а вместо нее создается дуга <<после перемещения>>. Если 
перемещение происходит в пределах $V(S_2)\backslash V(S_1)$, делается то же 
самое, однако предварительно в дерево включается путь от~$R$ до 
вершины~$V_3$, из которой должна исходить новая дуга. Если перемещение 
выводит за пределы~$S_2$, операция дуги заменяется операцией Del 
<<Удаление файла>> или Del <<Удаление директории>>. Последнее может 
быть только в случае, когда имеем дело не со всей файловой системой, а лишь с 
ее фрагментом, т.\,е.\ подграфом файловой системы.
      
            \smallskip
            
            \noindent
      \textbf{Алгоритм построения.} Последовательно анализируются 
номера из журнала. Обрабатываются только номера~$i$, которые 
принадлежат~$S_1$. В $I$-дереве рассматриваются  дуги, которые ведут в 
вершину~$i$ и у которых векторы операций имеют операцию Move 
<<Перемещение файла>> или Move <<Перемещение директории>>. Если  
$i\notin V(S_2)$, то операция заменяется операцией Del <<Удаление файла>> 
или Del <<Удаление директории>>. Если  $i\in V(S_2)$, то вычисляется полный 
путь от~$R$ до этого номера~$i$ в~$S_2$. Этот путь состоит из номеров, 
причем первый номер~--- вершина подграфа~$S_1$, а все номера в пути 
принадлежат~$S_1$ или~$S_2$. В~$M$-дерево включается та часть пути, которая 
в $M$-дереве отсутствует. Для образующих эти части пути вершин~$j$ 
возможны два случая:
      \begin{itemize}
\item вершина~$j$ отсутствует в~$S_1$. Дуге приписывается операция Create 
<<Создание директории>>;
\item вершина~$j$ присутствует в~$S_1$, в частности это вершина~$i$. 
Вершина~$k$, предшествующая в вычисленном полном пути вершине~$j$, 
может как принадлежать, так и не принадлежать~$S_1$, однако дуга 
$k\rightarrow j$ отсутствует в уже построенном к этому моменту 
$M$-дереве. Поэтому имеется еще одна и только одна дуга, ведущая в 
вершину~$j$ ($l\rightarrow j$), причем в векторе операций этой дуги должны 
быть операции Move <<Перемещение файла>> или Move <<Перемещение 
директории>>.  Эта дуга удаляется и создается новая дуга $k\rightarrow j$. 
Новой дуге приписывается вектор операций удаленной дуги. В этом векторе 
операция Move <<Перемещение файла>> или Move <<Перемещение 
директории>> заменяется операцией Move <<Перемещение дуги>>. 
В~качестве параметров этой операции указываются~$l$ и имя дуги 
$l\rightarrow j$. Таким образом, у вершины~$j$ заменяется родитель~$l$, им 
становится~$k$. 
\end{itemize}

      Если родитель~$k$ вершины~$j$ отсутствует в~$S_1$, то дуге 
$k\rightarrow j$ приписывается имя в вычисленном полном пути. Если же $j$ 
присутствует в~$S_1$, анализируется наличие у~$k$ исходящей дуги с именем в 
вычисленном полном пути. Если такой дуги нет, то дуге $k\rightarrow j$ 
приписывается то же простое имя, что и в предыдущем случае. Если же такая 
дуга есть, то дуге $k\rightarrow j$ приписывается временное уникальное для 
родителя имя. Кроме того, в вектор операций добавляется вспомогательная 
операция Rename <<Переименование временного имени>> с параметром~---  
имя из пути. 
      
      \smallskip

\noindent
{\sf \textbf{Примечание.} 
$M$-граф по-прежнему представляет собой 
дерево, потому что любая вершина, кроме корня, имеет только одну входящую 
дугу, а связность потеряться не может.}


      \smallskip
      
      \noindent
      \textbf{Сложность алгоритма.} $O(n_J \log (N))$.

\subsubsection{Фаза~3 (построение графа операций)}  %4.1.3 

      На этой фазе $M$-дерево расширяется до графа операций  за счет 
включения дуг, соответствующих удаленным и добавленным ссылкам. Каж\-дый 
номер из журнала, если он принадлежит $V(S_1)\cap V(S_2)$ и соответствует 
файлу, может иметь операцию LCount <<Изменение числа ссылок на файл без 
удаления файла>>. Для каждого такого номера по спискам ссылок в~$S_1$ 
и~$S_2$ вычисляется набор удаленных или добавленных ссылок. В $M$-дерево 
добавляются дуги, которые отвечают удаленным и добавленным ссылкам. В 
результате образуется граф операций. 
      
            \smallskip
            
      \noindent
      \textbf{Алгоритм построения.} Последовательно анализируются 
номера из журнала. Обрабатываются только такие номера~$l$, что $l\in  
V(S_1)\cap V(S_2)$ с операцией LCount <<Изменение числа ссылок на файл без 
удаления файла>> или $l\in V(S_1)\backslash V(S_2)$  с операцией Del 
<<Удаление файла>>. 
\begin{itemize}
\item Операция LCount <<Изменение числа ссылок на файл без удаления 
файла>>. Строится два \mbox{списка:} 
\begin{enumerate}[(1)]
\item $L_1$~--- список ссылок на файл~$l$ в~$S_1$. Каждый элемент 
списка состоит из номера родителя~$p_i$ и имени ссылки;
\item $L_2$~--- аналогичный список ссылок на файл~$l$, но в~$S_2$.
\end{enumerate}
Далее эти два списка сравниваются. Возможны три ситуации, 
рассмотренные ниже. В любой из них если оказывается, что 
родитель~$p_i$ не принадлежит построенному к этому моменту графу 
операций, то он сам и полный путь до него включаются в граф операций.
\begin{enumerate}[1.]
\item Номер $i \in L_1\backslash L_2$. Добавляется дуга $p_i\rightarrow l$,\linebreak 
которой приписывается вспомогательная операция <<Удаление 
ссылки>>. Если дуга $p_i\rightarrow l$ уже имеется, из нее удаляется 
операция LCount <<Изменение числа ссылок на файл без удаления 
файла>> и добавляется операция <<Удаление ссылки>>.
\item Номер $i \in L_2\backslash L_1$. Добавляется дуга $p_i\rightarrow l$, 
которой приписывается операция <<Создание ссылки>>. Если дуга 
$p_i\rightarrow l$ уже имеется, из нее удаляется операция LCount 
<<Изменение числа ссылок на файл без удаления файла>> и 
добавляется операция <<Создание ссылки>>. Дуге приписывается имя 
способом, описанным в фазе~2. 
\item Номер $i\in L_1\cap L_2$. Если дуга $p_i\rightarrow l$ уже имеется, из 
нее удаляется операция LCount <<Изменение числа ссылок на файл 
без удаления файла>>. Если в итоге образуется пустой вектор 
операций, дуга удаляется. В противном случае дуга сохраняется.
\end{enumerate}
\item Операция Del <<Удаление файла>>. Строится $L$~--- список ссылок 
на файл~$l$ в~$S_1$. Дуга с операцией Del <<Удаление файла>> удаляется. 
Для каждого номера $i\in L$ добавляется дуга $p_i \rightarrow l$, которой 
приписывается операция <<Удаление ссылки>>.
\end{itemize}

      Граф операций представляет собой DAG, а не дерево из-за наличия дуг, 
соответствующих до\-бав\-лен\-ным или удаленным ссылкам. Поскольку эти дуги 
могут вести только в листья, циклы не\-воз\-можны.

      \smallskip
      
      \noindent
      \textbf{Сложность алгоритма.} $O(n_J \log (N))$.

\section{Выполнение синхронизации}

\subsection{Свойства графа операций}

\noindent
\begin{enumerate}[1.]
\item Граф операций описывает только различия между снимками~$S_1$ 
и~$S_2$ и операции, которые нужно выполнить, чтобы перейти от~$S_1$ 
к~$S_2$.\\[-15pt]
\item Граф операций полностью описывает структуру тех директорий и 
файлов~$S_2$, которые отсутствуют в~$S_1$.\\[-15pt]
\item Граф операций не полностью описывает структуру директорий и 
файлов~$S_1$. В нем присутствуют только те директории, файлы и пути к 
ним, которые необходимы для адресации поддиректорий и файлов, которые 
имелись в~$S_1$ и были изменены, удалены или перенесены в другие 
директории.\\[-15pt]
\item Операции, приписанные дугам, соответствуют действиям, которые 
нужно производить при синхронизации. 
\end{enumerate}

\vspace*{-3pt}
\subsection{Векторы операций, приписанные дугам в графе операций}
      
      Эти векторы могут содержать следующие операции:
      \begin{itemize}
\item изменение содержимого или метаданных \mbox{файла;}\\[-15pt]
\item создание ссылки;\\[-15pt]
\item удаление ссылки;\\[-15pt]
\item создание файла;\\[-15pt]
\item изменение метаданных директории;\\[-15pt]
\item перемещение дуги. Параметры: 
\begin{itemize}
\item номер индексного дескриптора директории, из которой удаляется 
дуга;\\[-14pt]
\item имя удаляемой дуги;
\end{itemize}
\item создание директории;\\[-15pt]
\item удаление директории;\\[-15pt]
\item переименование временного имени. Параметр~--- присваиваемое имя.
\end{itemize}

\vspace*{-6pt}

\subsection{Синхронизация}

      Выполнение синхронизации состоит из двух фаз:
      \begin{enumerate}[(1)]
\item фазы создания и модификации;\\[-14pt]
\item фазы удаления и устранения временных имен.
\end{enumerate}

При выполнении обеих фаз происходит обход графа операций в порядке <<от 
родителей к потомкам>>, т.\,е.\ для некоторой вершины~$l$ сначала 
обрабатываются все ее исходящие дуги, ведущие к файлам, а потом делается 
рекурсивный спуск по исходящим дугам, ведущим к директориям.

\vspace*{-3pt}
\subsubsection{Фаза создания и модификации} %5.3.1
\vspace*{-1pt}
      
      На этой фазе выполняются только следующие операции:
      \pagebreak
      
      \noindent
\begin{itemize}
\item изменение содержимого или метаданных \mbox{файла;}
\item создание ссылки;
\item создание файла;
\item изменение метаданных директории;
\item перемещение дуги;
\item создание директории.
\end{itemize}

      Сначала происходит обработка текущей директории <<в ширину>> с 
выполнением всех перечисленных выше операций. Все дуги, которые 
соответствуют созданию файла из~$S_2$ или созданию ссылки на него, имеют 
одну и ту же операцию <<Создание файла>>. На приемнике по этой операции 
выполняется функция open($\ldots$, O\_CREAT $\vert$ O\_EXCL, \ldots). Если 
ошибка не возникает, файл создан и выполняется его копирование из~$S_2$ 
передатчика. При ошибке EEXIST вместо создания файла создается ссылка на 
уже существующий файл. Если файл уже существовал в~$S_1$, то операции для 
него~--- <<Создание ссылки>> и <<Удаление ссылки>>. Первая операция 
делается на данной фазе, а вторая~--- на следующей. Далее происходит 
рекурсивный спуск по каждой из дуг, ведущих к директориям.

\smallskip
\noindent
\textbf{Примечания.}

\noindent
{\sf 
\begin{enumerate}[1.] 
\item В процессе обхода из векторов операций дуг, ведущих к файлам, 
можно удалять все выполненные операции (в векторе могут остаться только 
операции <<Удаление ссылки>> и <<Переименование временного 
имени>>). Если дуга после удаления имеет пустой вектор операций, то дугу 
также можно удалить. Это позволяет уменьшить обход на следующей фазе. 
Удалять дуги, ведущие к директориям, во время обхода в первой фазе не 
удается, хотя и они могут быть не нужны. Однако после первой фазы можно 
выполнить такое удаление. \textit{Критерий удаления}: дуга, ведущая к 
директории, может быть удалена, если и она, и все дуги подграфа имеют 
пустые векторы операций.
\item Для одного элемента все операции, вы\-пол\-ня\-емые на этой фазе, кроме 
операции <<Перемещение дуги>>,  можно осуществлять в любом порядке. 
Операция <<Перемещение дуги>>, если она присутствует в векторе, должна 
выполняться первой. Нужный порядок выполнения операций может быть 
достигнут за счет соответствующего упорядочения вектора операций при 
построении графа операций.
\end{enumerate}}

\subsubsection{Фаза удаления и устранения временных имен} %5.3.2\ 
      
      На этой фазе выполняются только следующие операции:
      \begin{itemize}
\item удаление ссылки;
\item удаление директории;
\item переименование временного имени.
\end{itemize}

      Сначала происходит обработка текущей директории <<в ширину>> с 
выполнением операций <<Удаление ссылки>> (это может быть удаление 
ссылки или файла) или <<Удаление директории>>. Отметим, что создание 
файлов и ссылок на них выполнены на предыдущей фазе, поэтому удаление 
ссылок не может привести к удалению файлов, если это не требуется. После 
этих действий все конфликтные ситуации в директории, если они имели место, 
разрешены~---  мешающих элементов больше нет. Поэтому только после 
выполнения операций удаления для директории возможно выполнение 
операций <<Переименование временного имени>>. Наконец, происходит 
рекурсивный спуск по каждой из дуг, ведущих к директориям.
      
      \smallskip
      
      \noindent
{\sf      \textbf{Примечание.} 
Порядок~--- сначала выполнение операций 
<<Удаление ссылки>> и <<Удаление директории>>, далее <<Переименование 
временного имени>>, а потом рекурсивный спуск~--- может быть достигнут за 
счет\linebreak соответствующего порядка дуг, исходящих из вершины (они, конечно, 
образуют двунаправленный список). Нужный порядок можно обеспечить при 
построении графа операций.}

\subsection{Особенности выполнения фаз}

\subsubsection{Трансляция и удаление директорий} %5.4.1\ 
      
      Трансляция номера индексного дескриптора передатчика в номер 
приемника требуется в двух \mbox{местах:}
      \begin{enumerate}[(1)]
\item перемещении файла или директории, которые существовали в~$S_1$;
\item создании ссылки на файл, который существовал в~$S_1$.
\end{enumerate}

      <<Удаление директории>> не всегда удаляет пустую директорию. Это 
может быть по двум причинам:
      \begin{enumerate}[(1)]
\item существовавшая в~$S_1$ директория перемещена за пределы снимка;
\item на файл, принадлежащий удаляемой директории, сделана ссылка.   
\end{enumerate}

\begin{table*}\small
\begin{center}
\Caption{Возможности параллельного выполнения операций
\label{t2koz}}
\vspace*{2ex}

%\tabcolsep=3pt
\begin{tabular}{|rl|c|c|c|c|c|c|c|c|c|}
\hline
&&\multicolumn{9}{c|}{Операция}\\
\cline{3-11}
&\multicolumn{1}{c|}{\raisebox{6pt}[0pt][0pt]{Операция}}&1&2&3&4&5&6&7&8&9\\
\hline
1&Изменение содержимого или метаданных файла&u&y&u&u&y&n&n&u&u\\
2&Создание ссылки&y&y&u&u&y&n&n&u&u\\
3&Удаление ссылки&u&u&y&u&u&n&u&y&n\\
4&Создание файла    &u&u&u&y&y&n&n&u&u\\
5&Изменение метаданных директории&y&y&u&y&u&n&u&u&u\\
6&Перемещение дуги&n&n&n&n&n&u&n&u&u\\
7&Создание директории&n&n&u&n&u&n&u&u&u\\
8&Удаление директории&u&u&y&u&u&u&u&u&n\\
9&Переименование временного имени&u&u&n&u&u&u&u&n&u\\
\hline
\multicolumn{11}{p{128mm}}{\footnotesize{\textbf{Обозначения:}\newline
y~--- параллельное выполнение возможно;\newline
n~--- параллельное выполнение невозможно; \newline
u~--- ситуация невозможна (операции несовместимы или выполняются в разных фазах).}}
\end{tabular}
\end{center}
\vspace*{-6pt}
\end{table*} 

      Должна быть удалена только ссылка из удаля\-емой директории. Для того 
чтобы удаляемая директория была пуста, нужно сделать следующее:
      \begin{itemize}
\item дополнить граф операций, включив в него все удаляемые вершины и 
дуги, ведущие к ним;
\item на фазе удаления и устранения временных имен изменить порядок 
обхода графа операций: не <<от родителей к потомкам>>, а <<от потомков к 
родителю>> (DFO). 
\end{itemize}

      Изменение порядка обхода приводит к значительной модификации кода 
процессов приемника. В частности, появляется необходимость иметь таб\-ли\-цу 
трансляции <<номер индексного дескриптора передатчика\;$\rightarrow$\;номер 
приемника>>.

\vspace*{-6pt}

\subsubsection{Возможности параллельного выполнения операций} %5.4.2\ 

      Таблица~\ref{t2koz} показывает, какие операции можно выполнять 
параллельно. В случае файла параллельность означает возможность 
одновременного выполнения для него нескольких операций. В случае 
директории~--- возможность одновременного выполнения операций над 
директорией и файлами, которые находятся в подграфе этой директории. 
      

\vspace*{-6pt}
\section{Заключение}
\vspace*{1pt}

В итоге не было получено результата, которого добивались: $O(\Delta )$. 
Однако сама эта постановка вопроса недостаточно точна.   Достигнутый 
результат~--- $O(n_J \log(N))$.  Можно считать, что $n_J$~--- это действительно~$\Delta$. 
Но $\log (N)$ обусловлен не описанным алгоритмом, а временем выполнения 
специальных функций, предоставленных разработчиками файловой системы. 
Можно ли выбрать другой набор функций,  достаточных для поставленных 
целей, но выполняющихся быстрее? Можно ли разработать такую структуру 
журнала, которая удовлетворяет разработчиков, но более удобна и позволяет 
реализовать более простые алгоритмы? Подобные вопросы по-прежнему 
остаются открытыми.


%\vspace*{-6pt}

{\small\frenchspacing
{ %\baselineskip=10.5pt
\addcontentsline{toc}{section}{Литература}
\begin{thebibliography}{99}    
\vspace*{-4pt}

\bibitem{3koz} %1
\Au{Batten C., Barr~K., Saraf~A., Treptin~S.}
Abstract pStore: A secure peer-to-peer backup system. MIT Laboratory for 
Computer Science. Technical Report MIT-LCS-TM-632, December 2001.  12~p.

\bibitem{4koz} %2
\Au{Suparna~B., Mohan~C., Brannon~K.\,W., Inderpal~N., \mbox{Hui-I~H.\,I.}, Mahadevan S.} 
Coordinating backup/recovery and data consistency between database and file 
systems~// 2002 ACM SIGMOD  Conference (International) on Management of Data 
Proceedings. Madison, June 2002. P.~500--511.

\bibitem{2koz} %3
\Au{Killijian, M.-O., Court\`{e}s~L., Powell~D.}
A survey of cooperative backup mechanisms. Universit\`{e}s de Toulouse. 
Laboratoire d'Analyse et d'Architecture des Syst\`{e}mes. LAAS Technical Report 
06472. April 2007. 23~p.

\bibitem{1koz} %4
\Au{Preston W.\,C.}
Inexpensive backup solutions for open systems.~--- C.A.: O'REILLY, 2007. 760~p.

\bibitem{5koz}
\Au{Neeta G.} 
Understanding and exploiting snapshot technology for data protection. Part~1: 
Snapshot technology overview. April 2006. 
{\sf http://www-128.ibm.com/ developerworks/tivoli/library/t-snaptsm1}.

\bibitem{6koz}
\Au{Brinkmann~A., Effert~S.}
Snapshots and continuous data replication in cluster storage environments~// 4th 
Workshop (International) on Storage Network Architecture and Parallel I/Os 
Proceedings. San Diego, 2007. P.~3--10.

\bibitem{7koz}
\Au{Salomon D.}
Data compression.~---  N. Y.: Springer, 1998. 448~p.

\bibitem{8koz}
\Au{Tridgell A.}
Efficient algorithms for sorting and synchronization. A thesis submitted for the 
degree of Doctor of Philosophy at The Australian National University. February 
1999. 115~p.

\bibitem{9koz}
Want `zfs diff' to list files that have changed between snapshots, July 2008.   {\sf 
http://bugs.opensolaris.org/\linebreak bugdatabase/printableBug.do?bug\_id=6425091}.

\label{end\stat}

\bibitem{10koz}
Solaris ZFS Administration guide, 2008. {\sf 
http:// dlc.sun.com/pdf/817-2271/817-2271.pdf}.



\bibitem{11koz}
IEEE Std 1003.1,2004 Edition. {\sf http://www.unix.org/ version3/ieee\_std.html}.

\end{thebibliography}
}
}
\end{multicols}
   
 
 
 
 