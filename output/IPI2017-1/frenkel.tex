 \def\stat{frenkel}

\def\tit{ВЕРОЯТНОСТНЫЕ МОДЕЛИ ОЦЕНКИ УСТОЙЧИВОСТИ ПРОГРАММ 
К~КРАТКОВРЕМЕННЫМ АППАРАТНЫМ СБОЯМ$^*$}

\def\titkol{Вероятностные модели оценки устойчивости программ 
к~кратковременным аппаратным сбоям}

\def\aut{С.\,Л. Френкель$^1$, В.\,Н.~Захаров$^2$, Б.\,М.~Басок$^3$}

\def\autkol{С.\,Л. Френкель, В.\,Н.~Захаров, Б.\,М.~Басок}

\titel{\tit}{\aut}{\autkol}{\titkol}

\index{Френкель С.\,Л.}
\index{Захаров В.\,Н.}
\index{Басок Б.\,М.}
\index{Frenkel S.\,L.}
\index{Zakharov V.\,N.}
\index{Basok B.\,M.}


{\renewcommand{\thefootnote}{\fnsymbol{footnote}} \footnotetext[1]
{Работа выполнена при частичной финансовой поддержке РФФИ  
(проекты 16-07-01028 и~15-07-05316).}}


\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{Институт проблем информатики Федерального исследовательского центра 
  <<Информатика и~управ\-ле\-ние>> 
Российской академии наук, \mbox{fsergei51@gmail.com}}
\footnotetext[2]{Федеральный исследовательский центр <<Информатика и~управ\-ле\-ние>> 
 Российской академии наук, 
\mbox{VZakharov@ipiran.ru}}
\footnotetext[3]{Московский технологический университет (МИРЭА), \mbox{VM\_E@mail.ru}}
     
  
  \Abst{Показана возможность использования двумерной марковской модели 
поведения конечного автомата при сбое на одном такте, предложенной ранее для 
вероятностной верификации аппаратных систем, для оценки устойчивости программ, 
представленных блок-схе\-ма\-ми реализуемых алгоритмов, к~кратковременным сбоям. 
Модель представляет собой произведение цепей Маркова (ЦМ), соответствующих  
ко\-неч\-но-ав\-то\-мат\-ной модели программы, работающей в~нормальных условиях, 
и~автомата, в~котором в~некоторый момент времени произошел кратковременный 
(например, в~пределах времени выполнения одной операции или одного машинного цикла) 
сбой. Устойчивость к~сбоям оценивается вероятностью возвращения автомата после 
прекращения действия помехи на траекторию переходов исходного автомата. При этом 
считается, что изменения траектории при сбое в~низкоуровневой (instruction-by-instruction) 
модели программы будут существенными только в~том случае, если они соответствуют 
изменению ветвления в~указанной блок-схеме. Модель подробно анализируется на примере 
конкретной блок-схе\-мы программы.} 
  
  \KW{самовосстановление программ; сбои; марковские модели; тестирование}
  
  \DOI{10.14357/19922264170104}  


\vskip 10pt plus 9pt minus 6pt

\thispagestyle{headings}

%\vspace*{1pt}

\begin{multicols}{2}

\label{st\stat}


        
       
\section{Введение}

     Проблема учета влияния сбоев на работу вычислительных систем  
(ВС)~--- как аппаратных, так и~программных подсистем~--- остается одной из 
наиболее актуальных для теории и~практики проектирования ВС.
 %    
     Сбои могут возникать как в~той или иной части области памяти 
программы, так и~вне ее. Они могут исказить как данные, так и~содержимое 
программы (значения переменных, констант, кодов операций и~т.\,д.).
     
     Поскольку основным источником оценки правильности работы сложных 
ВС, в~том числе и~в~условиях сбоев, является тестирование на тех или иных 
множествах программ и~данных (бенчмарках, например, как в~[1], или 
функциональных тестах), было бы очень полезно, чтобы последствия этих 
сбоев могли оцениваться и~верифицироваться в~процессе разработки ВС. 
     
     В настоящее время одной из основных техник оценки чувствительности 
ВС к~сбоям является так назывемое инжекционное введение неисправностей 
(fault injection~--- FI)~[2], используемое для оценки надежности тестирования 
влияния аппаратных или системных сбоев на работу прикладных программ.
     
     Обычно в~технике FI прикладная программа эмулируется пошагово 
(instruction-by-instruction), при этом опе\-ран\-ды-ис\-точ\-ни\-ки случайным 
образом модифицируются до выполнения инструкции, а результат выполнения 
инструкции также случайным образом искажается, имитируя тем самым 
действие ошибки. Программный счетчик также случайно модифицируется 
в~случае, если это инструкция условного перехода (branch instruction). 
Результирующая последовательность таких модификаций инструкций 
и~счетчика прослеживается для определения уровня защищенности данной 
программы к~указанным сбоям (soft error rate~--- SER).
     
     Данный подход требует наличия у разработчиков достаточно 
дорогостоящего программного обеспечения, которое при этом не используется 
для решения других многочисленных задач проектирования, в~част\-ности 
верификации и~функционального тестирования~[2]. 
     
     В статье показывается возможность использования двумерной 
марковской модели поведения конечного автомата при сбое на одном такте, 
предложенной ранее для вероятностной верификации аппаратных  
сис\-тем~[3, 4], для оценки устойчивости программ к~кратковременным сбоям.
     
     Модель представляет собой произведение ЦМ, 
соответствующих конечно-автоматной модели программы, работающей 
в~нормальных условиях, и~автомата, в~котором в~некоторый момент времени 
произошел кратковременный (например, в~пределах времени выполнения 
одной операции, или одного машинного цикла) сбой. Устойчивость к~сбоям 
оценивается вероятностью возвращения указанной це\-пи-про\-из\-ве\-де\-ния 
на траекторию, соответствующую нормальному функционированию автомата. 
   %  
     При этом предлагается рассматривать программу на алгоритмическом 
языке высокого уровня и~соответствующую блок-схему. 

Авторы считают, что 
указанные выше модификации в~низкоуровневой (instruction-by-instruction) 
модели программы будут существенными только в~том случае, если изменяют 
ветвления в~указанной блок-схеме. 
     
     Применение указанного подхода иллюстрируется на примере конкретной 
программы. 

\section{Проблема анализа сбоев в~прикладных программах}

     В последнее время в~связи со все более широким распространением 
нанотехнологий актуальной задачей становится учет на разных этапах 
проектирования возможных последствий случайных сбоев, вызываемых 
воздействием одиночных частиц (протонов, нейтронов, тяжелых заряженных 
час\-тиц)~[2], а также отказов, связанных с взаимовлиянием отдельных 
элементов СБИС (сверхбольших интегральных схем)
 при работе на высоких частотах. При этом, очевидно, 
непосредственно сбои приводят к~неправильному поведению аппаратных 
элементов ВС, которые в~свою очередь могут влиять на работу системных 
и~прикладных программ. Однако в~то время как анализу влияния сбоев 
в~аппаратуре уделяется довольно много внимания в~литературе, оценка 
влияния сбоев на выполнение программ, особенно на прикладном уровне, как 
самостоятельных объектов сбоев, рассматривается крайне редко~\cite{5-fr}. 
Это связано с предположением, что, устранив влияние аппаратных сбоев (за 
счет дублирования, обеспечения свойств помехоустойчивого кодирования 
состояний (коды Хэмминга, Ри\-да--Со\-ло\-мо\-на), самовосстановления 
и~т.\,д.), можно исключить влияние сбоев на прикладные программы. Однако 
эти мероприятия могут быть связаны с введением столь существенной 
аппаратурной избыточности, что нарушаются требования к~допус\-тимым 
уровням потребления энергии и~задержкам в~обработке и~передаче 
информации. Вместе с тем далеко не все кратковременные изменения 
в~поведении аппаратных элементов ВС будут приводить 
к~неправильному поведению тех или иных выполняемых программ. Поэтому 
при оценке необходимости повышения устойчивости аппаратуры к~сбоям было 
бы желательно учесть их возможное влияние на свойства программ, причем 
как в~рабочем, так и~в~тестовых режимах.
     

\section{Краткое описание модели программы и~программных 
сбоев}

     Определим прежде всего модель программы.
     
     В основе рассматриваемой в~настоящей статье модели прикладной 
программы лежит конечный автомат Мили, соответствующий алгоритму, 
реализуемому данной программой. В~данной статье не будут рассматриваться 
формальные аспекты использования данной модели~--- отошлем читателя 
к~\cite{6-fr} и~статье авторов~\cite{7-fr}, а дадим лишь пояснения, 
необходимые для понимания дальнейшего. 
     
     В терминах указанной автоматной модели выполнение программы 
моделируется как переходы между состояниями соответствующего 
автомата~\cite{6-fr}. Направленная дуга в~диаграмме (графе) автомата 
представляет последовательность выполнения программы от состояния 
к~состоянию. Входами моделей Мили могут быть флаги событий или условий. 
Выходы~--- вычисляемые переменные.
     
     На основе ко\-неч\-но-ав\-то\-мат\-ной модели программы определим 
понятие сбоя. Неформально под сбоем при работе программы будем понимать 
ошибки вычислений, вызываемые случайными изменениями любого из битов 
некоторого машинного слова из двоичного образа программы (binaries, binary 
image), т.\,е.\ заменой~<<0>> на~<<1>> или~<<1>> на~<<0>>. В дальнейшем 
будем считать, что такое изменение приводит к~изменению того или иного 
состояния автоматного представления программы, однако не приводит 
к~появлению новых состояний, отличных от состояний, представленных 
в~указанном автоматном представлении.

\section{Марковская модель оценки чувствительности к~сбоям}

     Будем называть событие $\mathrm{HS}(t)$ \textit{са\-мо\-вос\-ста\-нов\-ле\-ни\-ем} автомата 
после сбоя, произошедшего на такте~$t_0$, если $t\hm>t_0$~--- первый 
следующий за сбоем такт, на котором выполняется $A_f(t)\hm=A(t)$ 
и~$Y_f(t)\hm=Y(t)$, где $A(t)$ и~$A_f(t)$~--- состояния ЦМ исправного 
$A(t)$ и~сбойного $A_f(t)$ автоматов на такте~$t$, а~$Y(t)$ и~$Y_f(t)$~--- 
соответствующие векторы значений выходов.
     
     Вероятностная оценка того, повлияет ли тот или иной сбой, описываемый 
данной моделью, на корректность работы программы (произойдет ли 
самовосстановление), может быть получена в~терминах вероятности попадания 
двумерной ЦМ, состояния которой представляют собой пары 
состояний из цепи, не подверженной действию помехи, и~цепи, в~которой 
произошел указанный сбой, в~поглощающее состояние, соответствующее 
возвращению на траекторию, образуемую только правильными переходами 
цепи. 
  %   
     При этом цепь имеет еще одно поглощающее состояние, которое может 
быть определено одним из двух следующих способов:
     \begin{enumerate}[(1)]
     \item оно соответствует искажению хотя бы одной выходной переменной 
до возвращения траектории переходов автомата в~состояние, соответствующее 
исправному;
     \item оно соответствует искажению выходов при совпадении состояний 
исправного и~сбойного автоматов.
     \end{enumerate}
     
     Матрица переходных вероятностей вычисляется по заданной таблице 
переходов автоматов и~вероятностям булевых единиц входных двоичных 
переменных автомата (поскольку переход в~данное состояние определяется той 
или иной операцией над текущим значением входной переменной и~текущим 
состоянием). При этом можно определить\linebreak чис\-ло временн$\acute{\mbox{ы}}$х тактов до 
возможного возвращения к~правильному функционированию путем\linebreak 
вы\-чис\-ле\-ния вектора вероятностей состояний, в~которые попадает двумерная 
ЦМ из-за помехи за~$t$~переходов автомата: 
     \begin{equation}
     \vec{p}(t) =\vec{p}(t-1)P^*=\vec{p}(0)\left( P^*\right)^t\,,
     \label{e1-fr}
     \end{equation}
где начальное распределение~$\vec{p}(0)$ определяется начальными 
состояниями исправного и~неисправного автоматов, а~$P^*$~--- матрица 
переходов указанной двумерной ЦМ.

     Если исправный автомат в~начальный момент~0 находится 
в~состоянии~$i_0$, а~неисправный~--- в~состоянии $j_0\not= i_0$, то 
$p_{i_0,j_0}(0)\hm=1$, а~остальные координаты вектора~$\vec{p}(0)$ равны 
нулю.
     
     Компоненты вектора $p(t)$ представляют собой вероятности~$p_0(t)$ 
попадания в~поглощающее состояние~$A_0$, соответствующее 
восстановлению правильного функционирования после прекращения действия 
помехи, вероятности~$p_1(t)$ поглощающего состояния~$A_1$ 
(определенного одним из указанных выше способов), и~вероятности переходов в~остальные (переходные) состояния ЦМ, в~сумме равные $1\hm- p_0(t)\hm- 
p_1(t)$.
     
     Подробный математический анализ модели выполнен в~\cite{3-fr}. Здесь 
приводится лишь по\-ясня\-ющий пример, помогающий лучше понять 
описываемый ниже анализ чувствительности конкретной программы.


     
     Рассмотрим автомат, заданный табл.~1, где $a_t$ и~$a_s$~--- текущие 
и~следующие состояния автомата, $X\hm=(x_1,\,x_2,\,x_3)$, 
$Y\hm=(y_1,\,y_2,\,y_3,\,y_4)$~--- двоичные входные и~выходные переменные, 
причем отсутствие того или иного компонента вектора~$X$ во входных 
переменных означает его произвольное значение, а вектора~$Y$~--- нулевое, 
т.\,е.\ входной вектор $(0,\,1,\,1)$, а~также входные векторы $(0,\,0,\,0)$, 
$(0,\,0,\,1)$ и~$(0,\,1,\,0)$, соответствующие ячейке таблицы с~$\overline{x}_1$, 
примененные к~состоянию~$a_1$, приводят автомат в~состояние~$a_2$ 
и~формируют на выходе вектор $(0,\,1,\,0,\,1)$, и~т.\,д.

{\small   %tabl1
\begin{center}
{{\tablename~1}\ \ \small{Автомат с двумя состояниями}}
\vspace*{2ex}


\tabcolsep=14pt
\begin{tabular}{|c|c|c|c|}
\hline
$a_t$ & $a_s$ & $X$ & Y\\
\hline
$a_1$ & $a_2$ & $\overline{x}_1$ & $y_2y_4$\\
%\hline
$a_1$& $a_2$& $x_1\overline{x}_2$ & $y_2y_3$\\
%\hline
$a_1$& $a_1$ & $x_1x_2$ & $y_2y_4$\\
%\hline
$a_2$ & $a_1$ & $\overline{x}_2$ & $y_2y_4$\\
%\hline
$a_2$& $a_1$ & $x_2\overline{x}_3$ & $y_1y_4$\\
%\hline
$a_2$& $a_2$ & $x_2x_3$& $y_2y_4$\\
\hline
\end{tabular}
\end{center}
\vspace*{12pt}
}



\addtocounter{table}{1}
     
     Напомним, что если исправный автомат в~начальный момент~0 
находится в~состоянии~$i_0$, а~неисправный~--- в~состоянии $j_0\not= i_0$, 
то $p_{i_0,j_0}(0)\hm=1$, а~остальные координаты вектора~$\vec{p}(0)$ равны 
нулю.



    Для данного автомата матрица переходных вероятностей вычисляется по 
заданной таблице переходов автоматов и~вероятностям булевых единиц 
входных двоичных переменных автомата.
%
     При этом в~зависимости от выбора условий, определяющих попадание 
рассматриваемой двумерной ЦМ в~поглощающее состояние~$A_1$, можно 
рассмотреть разные модели формирования матрицы переходных 
вероятностей~$P$. Рассмотрим на примере данного автомата две указанные 
модели.
     
     \smallskip
     
     \noindent
     \textbf{Модель~4.1.}\ Попадание ЦМ в~поглощающее состояние~$A_1$ 
во всех случаях несовпадения выходов исправного и~сбойного автоматов. 
     
     \smallskip
     
     Матрица вероятностей переходов указанной двумерной ЦМ представлена в~виде табл.~2, где $p_i\hm=\mathrm{Prob}\left(x_i\hm=1\right)$, $i\hm= 1$, 2, 3, 
$q_i\hm=1\hm- p_i$.
        
      
  
     Состояния~$A_0$ и~$A_1$ (см.\ табл.~2) соответствуют указанным выше 
поглощающим состояниям двумерной ЦМ. Состояния указанной ЦМ $(1,2)$, 
$(2,1)$\linebreak\vspace*{-12pt}

\setcounter{table}{2}

\begin{table*}[b]\small %tabl3
\vspace*{-12pt}
     \begin{center}
     \Caption{Описание возможных переходов пар состояний исправного и~сбойного 
автоматов}
      \vspace*{2ex}
      
      \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
      \hline
      \multicolumn{1}{|c|}{\raisebox{-6pt}[0pt][0pt]{$a_t$}} & \multicolumn{8}{c|}{$X$}\\
      \cline{2-9}
&$x_1x_2x_3$&$x_1x_2 \overline{x}_3$ &$x_1\overline{x}_2 
x_3$&$x_1\overline{x}_2\overline{x}_3$ &$\overline{x}_1 
x_2x_3$&$\overline{x}_1x_2\overline{x}_3$&$\overline{x}_1\overline{x}_2x_3$&
$\overline{x}_1\overline{x}_2\overline{x}_3$\\
\hline
$a_1$&$a_1/y_2y_4$&$a_1/y_2y_4$&$a_2/y_2y_3$&$a_2/y_2y_3$&$a_2/y_2y_4$&$a_2/y_2y_4$&$a
_2/y_2y_4$&$a_2/y_2y_4$\\
%\hline
$a_2$&$a_2/y_2y_4$&$a_1/y_1y_4$&$a_1/y_2y_4$&$a_1/y_2y_4$&$a_2/y_2y_4$&$a_1/y_1y_4$&$a_1/y_2y_4$&$a_1/y_2y_4$\\
%\hline
$(1,2)$&$(1,2)$&$A_1$&$A_1$&$A_1$&$A_0$&$A_1$&$(2,1)$&$(2,1)$\\
%\hline
$(2,1)$&$(2,1)$&$A_1$&$A_1$&$A_1$&$A_0$&$A_1$&$(1,2)$&$(1,2)$\\
\hline
\end{tabular}
\end{center}
\end{table*}

\pagebreak

{\small   %tabl2
\begin{center}
{{\tablename~2}\ \ \small{Матрица вероятностей переходов автомата}}
\vspace*{2ex}


 \tabcolsep=7.6pt
      \begin{tabular}{|c|c|c|c|c|}
      \hline
      & $A_0$ & $(1,2)$ & $(2,1)$ & $A_1$\\
      \hline
      $A_0$ & 1& 0&0&0\\
      $(1,2)$ & $q_1p_2p_3$ & $p_1p_2p_3$ & $q_1q_2$ & $p_1q_2+p_2q_3$\\
      $(2,1)$ & $q_1p_2p_3$ & $q_1q_2$ & $p_1p_2p_3$ & $p_1q_2+p_2q_3$\\
      $A_1$ & 0&0&0&1\\
      \hline
      \end{tabular}
\end{center}
\vspace*{12pt}
}



%\addtocounter{table}{1}
     

 
\noindent
 означают, что в~начальном состоянии автомат должен быть в~состоянии 
$a_1 (a_2)$, но в~результате сбоя (ошибки, помехи) оказывается в~$a_2 (a_1)$. 
Очевидно, что если число состояний исходного автомата равно~$N$, то размер 
двумерной ЦМ составит $N(N\hm-1) \hm+ 2$ и~в~данном примере будет 
равен~4.
     
     Поясним подробно построение матрицы вероятностей переходов 
двумерной ЦМ для автомата табл.~1, представив для большей наглядности всю 
информацию о~возможном поведении пары исправного и~сбойного автоматов 
в~виде табл.~3.
               Здесь, в~отличие от табл.~1, указываются все компоненты~$x_1$, $x_2$ 
и~$x_3$ входного вектора, включая те, которые не влияют на данный переход.
    
    Пусть в~начальный момент времени из-за действия (необнаруженной) 
помехи автомат (см.\ табл.~1) вместо состояния~$a_1$ оказался в~состоянии~$a_2$. 
Общая ЦМ~$Z_t$, описывающая совместное функционирование исправного 
и~неисправного автоматов, имеет состояния: переходные $(1,2)$ и~$(2,1)$ 
и~поглощающие~$A_0$ и~$A_1$. Здесь $(1,2)$~--- исправный и~неисправный 
автоматы находятся соответственно в~состояниях~$a_1$ и~$a_2$; $(2,1)$~--- 
в~состояниях~$a_2$ и~$a_1$; $A_0$~--- событие <<к~данному моменту 
произошло восстановление траектории функционирования автомата (он 
оказался в~правильном состоянии) и~выходные данные не были искажены>>;\linebreak 
$A_1$~--- неправильное функционирование уже проявилось в~выходном 
сигнале. В~отличие от поглощающих состояний, для состояний $(1,2)$ 
и~$(2,1)$ возможны переходы.
    
    Вычислим переходные вероятности ЦМ~$Z_t$ (см.\ табл.~2).
    
    Состояния $A_0$ и~$A_1$ являются поглощающими, и~поэтому 
вероятность остаться в~каждом из этих состояний равна~1. 
    
    Из состояния $(1,2)$ в~состояние~$A_0$ можно попасть только в~том 
случае, когда поступит сигнал~$\overline{x}_1x_2x_3$  
(с~ве\-ро\-ят\-ностью~$q_1p_2p_3$). Тогда оба автомата (исправный 
и~неисправный) перейдут в~одно и~то же состояние~$a_2$, а~выходной сигнал 
у~обоих автоматов~--- $y_2y_4$.
    
    Из состояния $(1,2)$ в~состояние~$(1,2)$ можно попасть только в~том 
случае, когда поступит сигнал~$x_1x_2x_3$  
(с~ве\-ро\-ят\-ностью~$p_1p_2p_3$). Тогда исправный автомат остается  
в~со\-сто\-янии~$a_1$, неисправный~--- в~со\-сто\-янии~$a_2$, а~выходной 
сигнал у~обоих автоматов~--- $y_2y_4$. Аналогично вычисляется вероятность 
перехода из состояния~$(1,2)$ в~со\-сто\-яние~$(2,1)$. Из  
со\-сто\-яния~$(1,2)$ в~со\-сто\-яние~$A_1$ можно попасть при разных 
входных сигналах. Во-пер\-вых, если поступит сигнал~$x_1\overline{x}_2$ 
(с~ве\-ро\-ят\-ностью~$p_1q_2$, третий компонент входного сигнала может 
быть любым), тогда выходной сигнал у~исправного автомата~--- $y_2y_3$, 
у~неисправного~--- $y_2y_4$ (при этом исправный автомат переходит из  
со\-сто\-яния~$a_1$ в~со\-сто\-яние~$a_2$, неисправный~--- из  
со\-сто\-яния~$a_2$ в~со\-сто\-яние~$a_1$). Во-вто\-рых, если поступит 
сигнал~$x_1x_2\overline{x}_3$ (с~ве\-ро\-ят\-ностью~$p_1p_2q_3$), тогда 
выходной сигнал у~исправного автомата~--- $y_2y_4$, у~неисправного~--- 
$y_1y_4$ (при этом оба автомата попадают в~со\-сто\-яние~$a_1$).  
В-треть\-их, если поступит сигнал~$\overline{x}_1x_2\overline{x}_3$
    (с~ве\-ро\-ят\-ностью~$q_1p_2q_3$), тогда выходной сигнал у~исправного 
автомата~--- $y_2y_4$, у~неисправного~--- $y_1y_4$.
    
    Пусть $p_1=0{,}2;\ p_2=0{,}4;\ p_3=0{,}25.$
При векторе начальных состояний $\vec{p}^{\,*}(0)\hm= (0,\,1,\,0,\,0)$ после 
первого шага
$$
\vec{p}^{\,*}(1)= \vec{p}^{\,*}(0) P^*=\left( 0{,}08;\, 0{,}02;\, 0{,}48;\, 0{,}42\right)\,.
$$
     
     Соответственно, вероятность~$p_0(1)$ попадания в~поглощающее  
со\-сто\-яние~$A_0$, при котором автомат при снятии кратковременного 
возмущения, вызвавшего сбой, вернется на траекторию переходов исправного 
автомата до того, как произошло изменение хотя бы на одном выходе~$y_1$, 
$y_2$, $y_3$, $y_4$, равно~0,08, вероятность~$p_1(1)$ попасть в~по\-гло\-ща\-ющее  
со\-сто\-яние~$A_1$ (выход исказился до возвращения на правильную 
траекторию), равно~0,42 (произведение строки начальных со\-сто\-яний  
на~\mbox{4-й} стол\-бец мат\-ри\-цы переходных вероятностей, со\-от\-вет\-ст\-ву\-ющий 
попаданию в~$A_1$), и~ЦМ останется в~подмножестве эргодических 
состояний~$(1,2)$, $(2,1)$ с~вероятностью $p(1) \hm= 0{,}02\hm + 0{,}48\hm = 
0{,}5$.

\begin{table*}\small %tabl4
\begin{center}
\Caption{Вероятности достижения поглощающих и~эргодических состояний 
через~$t$~шагов}
\vspace*{2ex}

\tabcolsep=10pt
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
& $t=0$ & $t=1$ &  $t=2$ & $t=3$ & $t=4$ & $\cdots$ & $t=28$ \\
\hline
$p_{(0)}(t)$ & 0,000000 & 0,080000 & 0,120000 & 0,140000 & 0,150000 & $\cdots$ & 
0,160000\\
$p_{(1)}(t)$ & 0,000000 & 0,420000 & 0,630000 & 0,735000 & 0,787500 & $\cdots$ & 
0,840000\\
$\hat{p}(t)$ & 1,000000 & 0,500000 & 0,250000 & 0,125000 & 0,062500 & $\cdots$ & 
0,000000\\
\hline
\end{tabular}
\end{center}
\vspace*{9pt}
\end{table*}

\begin{table*}[b]\small %tabl5
%\vspace*{-12pt}
\begin{center}
\Caption{Описание возможных переходов пар состояний исправного и~сбойного автоматов
 (модель~4.2)}
\vspace*{2ex}

\tabcolsep=9pt
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
\multicolumn{1}{|c|}{\raisebox{-6pt}[0pt][0pt]{$a_t$}} &\multicolumn{8}{c|}{$X$}\\
\cline{2-9}
&$x_1x_2x_3$&$x_1x_2\overline{x}_3$ 
&$x_1\overline{x}_2x_3$&$x_1\overline{x}_2\overline{x}_3$ 
&$\overline{x}_1x_2x_3$&$\overline{x}_1x_2\overline{x}_3$&$\overline{x}_1\overline{x}_2x_3$&$\overline{x}_1\overline{x}_2\overline{x}_3$\\
\hline
$a_1$&$a_1/y_2y_4$&$a_1/y_2y_4$&$a_2/y_2y_3$&$a_2/y_2y_3$&$a_2/y_2y_4$&$a_2/y_2y_4$&$a_2/y_2y_4$&$a_2/y_2
y_4$\\
%\hline
$a_2$&$a_2/y_2y_4$&$a_1/y_1y_4$&$a_1/y_2y_4$&$a_1/y_2y_4$&$a_2/y_2y_4$&$a_1/y_1y_4$&$a_1/y_2y_4$&$a_1/y_2
y_4$\\
%\hline
$(1,2)$&$(1,2)$&$A_1$&$(2,1)$&$(2,1)$&$A_0$&$(2,1)$&$(2,1)$&$(2,1)$\\
%\hline
$(2,1)$&$(2,1)$&$A_1$&$(1,2)$&$(1,2)$ &$A_0$&$(1,2)$&$(1,2)$&$(1,2)$\\
\hline
\end{tabular}
\end{center}
%\vspace*{-3pt}
%\end{table*}
%\begin{table*}\small %tabl6
\begin{center}
\Caption{Матрица вероятностей переходов}
\vspace*{2ex}

\begin{tabular}{|c|c|c|c|c|}
\hline
&$A_0$ & (1,2) & (2,1) & $A_1$\\
\hline
$A_0$ & 1 & 0 & 0 &0\\
(1,2) & $q_1p_2p_3$ &  $p_1p_2p_3$ & $p_1q_2+q_1q_3+p_1p_2q_3$ & $p_1p_2q_3$\\
(2,1) &  $q_1p_2p_3$ & $p_1q_2+q_1q_3+p_1p_2q_3$ &  $p_1p_2p_3$ & $p_1p_2q_3$\\
$A_1$ & 0&0&0&1\\
\hline
\end{tabular}
\end{center}
%\end{table*}
%\vspace*{-3pt}
%\begin{table*}\small %tabl7
\begin{center}
\parbox{340pt}{\Caption{Вероятности достижения поглощающих и~эргодических состояний 
через~$t$~шагов (модель~4.2)}

}

\vspace*{2ex}

\tabcolsep=10.5pt
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
&$t=0$ & $t=1$ & $t=2$ & $t=3$ &$ t=4$ &$\cdots$&$t=28$\\
\hline
$p_0(t)$ &0,000&0,08&0,1488&0,208&0,2589&$\cdots$&0,563\\
$p_1(t)$ &0,000&0,06&0,1116&0,156&0,1941&$\cdots$&0,423\\
$p^\prime(t)$ &1\hphantom{,000}&0,86&0,7396&0,636&0,547\hphantom{9}&$\cdots$&0,014\\
\hline
\end{tabular}
\end{center}
\end{table*}

     
     После второго шага
     $$
     \vec{p}^{\,*}(2) =\vec{p}^{\,*}(1) P^*= \left( 0{,}1200;\, 
0{,}2308;\,0{,}0192;\,0{,}6300\right)
     $$
и т.\,д. согласно табл.~4.



     
     \smallskip
     
     \noindent
     \textbf{Модель~4.2.}\ Попадание ЦМ в~поглощающее 
состояние~$A_1$ только в~случае несовпадения выходов исправного 
и~сбойного автоматов при попадании сбойного автомата в~состояние, 
совпа\-да\-ющее с состоянием исправного. 
     
     \smallskip
     
     Данная модель соответствует переходам в~табл.~5, в~которой 
поглощающее состояние~$A_1$ соответствует несовпадению выходов при 
нахождении двух автоматов в~одном и~том же состоянии\linebreak ($a_1$ в~данном 
примере).


В этом случае матрица вероятностей переходов может быть представлена 
в~виде табл.~6.
При этом вероятности достижения поглощающих и~эргодических состояний 
через~$t$~шагов (аналогично табл.~4) представлены в~табл.~7.



     В зависимости от назначения систем и~подходов к~их проектированию, та 
или иная из двух рассмотренных семантик поведения систем в~условиях сбоев 
может оказаться более предпочтительной. Более подробно этот вопрос 
обсуждается ниже на конкретном примере.

\section{Пример анализа устойчивости программы к~сбоям}

     Рассмотрим программу, которая должна удалять пробелы из символьных 
строк согласно следующим условиям:
     \begin{itemize}
     \item  подавляются ведущие (стоящие в~начале строки) пробелы;
\item если строка заканчивается пробелами, то они также удаляются;
\end{itemize}

\pagebreak

\end{multicols}

\begin{figure*} %fig1
        \vspace*{1pt}
\begin{center}
\mbox{%
\epsfxsize=134.554mm
\epsfbox{fre-1.eps}
}
\end{center}
\vspace*{-9pt}
\Caption{ASM-диаграмма программы}
\vspace*{6pt}
\end{figure*}

\begin{multicols}{2}

\begin{itemize}
\item внутри строки не может быть последова\-тель\-ности, содержащей подряд 
более одного пробела, лишние пробелы удаляются. 
\end{itemize}



Для упрощения анализа будем рассматривать блок-схему 
программы для обработки только одной строки (S1), подразумевая, что 
программа включает средства перехода к~считыванию и~обработке следующей 
строки из всего множества строк обрабатываемого данной программой текста.
     
     Заметим, что данную программу можно рассматривать как модель 
различных программ, предназначенных для удаления некоторых служебных 
символов в~потоке передаваемой символьной информации, например 
признаков начала и~конца передачи блока данных в~телекоммуникационных 
приложениях.


     
     Согласно сформулированной во введении цели данной статьи 
рассмотрим задачу вычисления вероятностной оценки возможности 
самовосстановления работы рассматриваемого программного модуля после 
сбоя~--- в~данном случае вопрос стоит о восстанавливаемости работы при 
неправильном выполнении операции. Это, очевидно, зависит не только от 
структуры модуля, но также от вероятности выполнения тех или иных 
переходов, т.\,е.\ от входной информации.
     
     Представим алгоритм, реализующий указанную программу, как 
диаграмму <<Алгоритмической машины состояний>> (Algorithmic State 
Machine~--- ASM)~\cite{8-fr} (блок-схе\-ма на рис.~1). 



     На приведенной блок-схеме~$S_1$~--- массив, содержащий 
обрабатываемую строку, из которой удалены управляющие символы, не 
входящие в~алфавит~$A$, длина этого массива~--- $L_1$ (механизм 
считывания и~буферизации здесь не рассматриваем, считая весь процесс 
буферизации одной операцией, соответствующей прямоугольнику~$S_1$  
блок-схе\-мы). Если длина строки оказалось нулевой (например, содержатся 
только специальные управляющие символы (включая некоторый признак 
конца строки) и~нет ни одного символа из алфавита~$A$), то вводится 
следующая строка. $C_1$~--- индекс в~массиве~$S_1$, $C_2$~--- индекс 
в~массиве~$S_2$, в~который записываются символы строки без удаленных 
пробелов и~в~котором формируется результат работы программы 
(обозначаемый как Pr$S_2$). В~случае если строка состояла из одних пробелов, 
то пользователь получает сообщение Empty. 
     
     В данной блок-схе\-ме прямоугольники соответствуют выполнению 
некоторой операции, а~ромбы~--- условиям перехода. 

С~помощью программы 
Abelite~\cite{8-fr} можно получить ко\-неч\-но-ав\-то\-мат\-ное представление  
блок-схе\-мы в~виде автомата Мили, в~котором двоичные входные переменные 
соответствуют условиям выбора пути на блок-схе\-ме рисунка (из вершин 
ромба~<<0>> или~<<1>>), а~каждое выполнение операций связано 
с~переходом из состояния в~состояние (подробнее о программе Abelite 
и~методологии ее использования в~проектировании цифровых систем 
см.~\cite{7-fr, 8-fr}). Заметим, что программа Abelite сама определяет по  
ASM-диа\-грам\-ме состояния строящегося автомата. Следует, однако, учесть 
следующие обстоятельства:
     \begin{enumerate}[(1)]
\item поскольку изложенная в~предыдущем разделе модель двумерной 
ЦМ произведения автоматов предполагает независимость случайных 
входов автоматов, а~в~автоматах, получаемых по ASM-диа\-грам\-мам, 
входным переменным соответствуют условные переходы, необходимо, 
чтобы указанные переходы выполнялись по условиям, определяемым 
независимыми событиями;
\item поскольку в~данной модели сбоев рассматриваются синхронные 
автоматы, каждый результат изменения входных данных (выбор перехода 
в~ASM) должен фиксироваться в~том или ином состоянии автомата, что 
означает необходимость того, чтобы выход каждого ромба был связан с тем 
или иным прямоуголь-\linebreak ником.
\end{enumerate}

          

     Построенный программой Abelite автомат представлен на рис.~2.
Здесь первая колонка~--- предыду\-щее состояние, вторая~--- следующее 
состояние, третья~--- логические значения входов~$x_1$--$x_6$, вызывающие 
соответствующий переход, последняя~--- выходы автомата, формируемые при 
данном переходе. 

Соответствие выходов и~входов автомата блок-схе\-ме, 
пред\-став\-лен\-ной на рис.~1, описывает рис.~3. 
%  
     Здесь знак $<>$ замещает символ $\not=$, использование которого (как 
и~некоторых других знаков из таблицы символов MS Windows) запрещает 
интерфейс программы Abelite~\cite{8-fr}, используемой для по\-стро\-ения 
автомата.
     
     Состояния $a_1$--$a_{13}$ описывают состояния построенного автомата,  
$y_1$--$y_{16}$~--- выходные переменные, соответствующие 
выполнению операций в~прямоугольниках блок-схе\-мы, состоящих
или\linebreak\vspace*{-12pt}

{ \begin{center} %fig2
\begin{tabular}{cccc}
                            a1&a13&1&y16\\
                            a2&a11&1&y13\\
                            a3&a9&1&y12\\
                            a4&a2&x1&y3\\
                            a4&a3&$^\sim$x1&y2\\
                            a5&a2&x2&y1\\
                            a5&a4&$^\sim$x2&y4\\
                            a6&a2&1&y11\\
                            a7&a8&x3&y10\\
                            a7&a5&$^\sim$x3&y5\\
                            a8&a1&x1&y8\\
                            a8&a1&$^\sim$x1&y9\\
                            a9&a6&1&y6\\
                            a10&a7&x4&y7\\
                            a10&a9&$^\sim$x4&y12\\
                            a11&a10&x5&y12\\
                            a11&a8&$^\sim$x5&y10\\
                            a12&a2&x6&y14\\
                            a12&a12&$^\sim$x6&y15\\
                            a13&a12&1&y15
                            \end{tabular}
                            \end{center}
\vspace*{9pt}


\noindent
{{\figurename~2}\ \ \small{Автомат Мили, соответствующий диаграмме рис.~1}}


\vspace*{24pt}
                               \begin{center}
                               \begin{tabular}{ll}
                               \multicolumn{2}{l}{Выходные переменные (Micro Operations):}\\
                               y1:& S1[C1+1]=$^{\prime\prime}$\\ 
                               y2: & C2$<>$0 \\
                               y3:& C2=0 \\
                               y4: & S1[C1+1]$<>$$^{\prime\prime}$\\ 
                               y5: & $<$L1 \\
                               y6: & C2=C2+1, \\
                               y7: &$^{\prime\prime}$\\ 
                               y8: & Empty\\
                               y9: & PrS2 \\
                               y10: & C2\\ 
                               y11: & S2[C2]=S1[C1] \\
                               y12: & S1[C1] \\
                               y13: &C1=C1+1 \\
                               y14: &C1=0;C2=0 \\
                               y15: &L1\\
                               y16: &S1\\
                               \multicolumn{2}{c}{\ }\\
                               \multicolumn{2}{l}{Входные переменные (Logical Conditions):}\\
                               x1: & C2=0 \\
                               x2: & S1[C1+1]=$^{\prime\prime}$\\ 
                               x3: & C1=L1 \\
                               x4: &S1[C1]=$^{\prime\prime}$\\ 
                               x5: & C1=$<$L1 \\
                               x6: &L1$>$0 
                               \end{tabular}
                               \end{center}
                               
                               \vspace*{9pt}
                               
                               \noindent
{{\figurename~3}\ \ \small{Соответствие входных и~выходных переменных автомата операциям и~переходам 
в~ASM}}
}

%\vspace*{6pt}


\noindent
  в~присвоении значений одной переменной другой,
 или в~выполнении 
непосредственно указанных действий. Переменные S1[C1+1]=$^{\prime\prime}$, $^{\prime\prime}$, С2$<>$0 
представляют собой отмеченные <<синхронизи\-ру\-ющие>> операции, которые 
вставляются в~диаграмму для разделения моментов изменения входов 
автомата. Эти псевдооперации просто фиксируют состояние автомата, 
в~которое он перешел после выбора соответствующего перехода.
     
     Состояния автомата легко могут быть интерпретированы при сравнении 
рис.~2 и~3. Например, состояние~$a_4$~--- это состояние, когда в~слове 
обнаружен пробел, за которым идет не пробел. Если это происходит в~начале 
слова, то пробел не записывается в~формируемое слово~$S_2$, в~противном 
случае~--- записывается.
     
     Ввиду того что сбои рассматриваются как события, случайно 
происходящие во время обработки множества строк~$S$ в~некотором 
заданном алфавите, вероятности событий задаются на множестве всех 
возможных строк, содержавших символы алфавита, и~на множестве индексов 
символов внутри каждой из строк. 
     
     Для построения требуемой марковской модели (см.\ разд.~2) необходимо 
каждой входной переменной автомата $(x_1, \ldots, x_6)$ приписать вероятность 
булевой единицы, что соответствует вероятности активизации 
соответствующего пути в~блок-схе\-ме рис.~1 по единичной ветви. Эти 
вероятности оцениваются по наборам обрабатываемых текстов $S_T\subseteq 
S$, рассматриваемых как конечная выборка объемом~$N_T$ из 
множества~$S$.
     
     Например, вероятность того, что $x_6\hm=1$, оценивается как 
$\mathrm{Prob}\,(L_1\hm>0) \hm= N_{\mathrm{emp}}/N_T$, где $N_{\mathrm{emp}}$~--- число пустых 
строк; $N_T$~--- общее число строк в~тес\-то\-вом наборе. Это оценка 
вероятности отсутствия пустых строк в~потоке обрабатываемых строк, 
например, состоящих только из признаков начала и~конца и~не содержащих ни 
одного символа используемого алфавита (построение тестового набора 
рассматривалось в~\cite{4-fr}).
     
     Рассмотрим применение данной модели при анализе чувствительности 
теста и~устойчивости программы к~сбоям, а~именно: вычисляя значения 
вероятностей попадания двумерной ЦМ, построенной из пары 
автоматов с разными начальными условиями, одно из которых соответствует 
изменению вектора начального состояния в~результате сбоя, в~поглощающее 
состояние. 
     
     Для рассматриваемого примера общее число состояний двумерной 
ЦМ $\{(i, j)\}$, где~$i$ и~$j$~--- индексы состояний~$a_i$ и~$a_j$ 
исправного и~автомата, подвергнувшегося сбою (>>сбойного>> автомата), как 
указано в~предыдущем разделе, равно $N(N\hm-1)\hm+2$, где $N$~--- число 
состояний автомата на рис.~2, и~составляет~158. Состояния упорядочиваются 
следующим образом:
     \begin{multline*}
\left\{ 
A_0, (1,2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8),\right.\\
(1, 9), (1, 10), (1, 11), (1, 12), (1, 13), 
(2,1), (2, 3),\\
 \left. (2, 4), \ldots, (5, 6), \ldots, (13, 11), (13, 12), A_1\right\}\,.
\end{multline*}
     Вектор вероятностей начальных состояний $\{p_{i,j}\}_{158}$ имеет 
единственную единичную компоненту $(i_0, j_0)$: если исправный автомат 
в~начальный момент~0 находится в~состоянии~$i_0$, а~неисправный~--- 
в~состоянии $j_0\hm\not= i_0$, то $p_{i_0,j_0}(0)\hm=1$, а~остальные координаты 
вектора~$\vec{p}(0)$ равны нулю. Например, для сбоя вида~$(5,6)$, 
вектор~$\vec{p}(0)$ будет содержать единицу на позиции~$(5,6)$.
     
\section{Анализ чувствительности к~сбоям по~результатам 
тестирования}

     Пусть имеется некоторое множество строк~$S_1$, представляющее 
набор тестов для функционального тестирования программы. Пусть 
определены по данному тестовому множеству текстов (или более широкому 
множеству текстов, рассматриваемых как обучающая выборка) вероятности 
$\mathrm{Prob}\,(x_1\hm=1), \ldots, \mathrm{Prob}\,(x_6\hm=1)$.
     
     Как отмечалось в~разд.~4, для каждой автоматной модели программы 
можно построить две разные ЦМ, у~одной из которых поглощающее 
состояние~$A_1$ определяется подмножеством переходов цепи~$Z_t$, 
у~которых выходы исправного и~сбойного автоматов не совпадают 
(модель~4.1), а~у~другой ЦМ состояние~$A_1$ соответствует 
переходам, в~которых не совпадают выходы при совпадении состояний 
(модель~4.2). Использование той или иной модели зависит от того, какую 
конкретно задачу предстоит решать.
     
     Рассмотрим задачу определения вероятного интервала 
самовосстановления. В~этом случае, очевидно, адекватной является именно 
модель~4.2, посколь\-ку модель~4.1 означает проверку несовпадения выходов 
для каждого состояния, что в~ряде случаев может не позволять реализовывать 
эффект самовосстановления, поскольку работа программы может быть 
остановлена уже на первом такте после сбоя, тогда как многие алгоритмы 
самовосстановления и~самокоррекции как раз предполагают наличие 
некоторого времени на самовосстановление~\cite{9-fr}.
     
     Далее рассмотрим несколько примеров анализа автомата, заданного 
в~табл.~5, на чувствительность и~устойчивость к~сбоям.
     
     \smallskip
     
     \noindent
     \textbf{Пример~1.}\  Рассмотрим сбой~$(10,8)$: <<автомат вместо 
состояния~$a_{10}$, в~котором он должен находиться на данном такте после 
перехода на предыдущем такте, в~результате сбоя оказался в~
состоянии~$a_8$>>, что означает, согласно рис.~2, выполнение 
операции~$y_{10}$ вместо~$y_{12}$ и,~соответственно, формирование 
результирующей строки~$S_2$ может быть закончено до исчерпания символов 
во входной строке~$S_1$. При этом таблица вероятностей восстановления 
$p_0(t)$, появления сбоя на выходах~$p_1(t)$ и~нахождения на неправильной 
траектории переходов при неискаженных выходных переменных $\sim p(t)$ 
вычисляется по формуле~(\ref{e1-fr}) как произведение указанного выше 
вектора вероятности начальных состояний на $n$-ю степень матрицы 
вероятностей переходов двумерной ЦМ, вычисляемую по 
вероятностям переходов, как это показано на примере автомата табл.~\mbox{1--3}. Для 
данного примера аналогичные мат\-ри\-цы $158\times158$ строятся 
программой~\cite{10-fr}.
     
    Возьмем некоторый вектор вероятностей единичных значений входов 
$x_1,\ldots, x_6$ (не задаваясь пока вопросом связи их значений с семантикой 
программы), например~0,2, 0,7, 0,2, 0,7, 0,01, 0,2, и~вычислим значение 
вероятностей самовос\-ста\-нов\-ле\-ния на шагах (тактах) $t\hm=1, \ldots, 19$ по 
формуле~(\ref{e1-fr}), представив их вектором
\begin{multline*}
P_0(t) = [0,\, 0,\, 0,\, 0,\, 0,\, 0{,}3136,\, 0{,}3136,\, 0{,}31395,\\ 
0{,}45906,\, 
0{,}57226,\, 0{,}64495,\, 0{,}69991, 
\,0{,}75712,\\ 
0{,}78388,\, 
0{,}82202, \,0{,}85148,\, 0{,}87607,\, 0{,}89468,\\
 0{,}91082,\, 0{,}92396]\,,
\end{multline*}
где номер каждой позиции соответствует номеру такта минус~1 (первый 
элемент соответствует моменту сбоя и~считается нулевым индексом). 
     
     Как видно из вектора вероятностей самовосстановления~$P_0(t)$, уже 
к~12-му такту после сбоя вероятность восстановления достаточно высока\linebreak 
(0,757). 

Проанализируем связь вероятностей $x_1, \ldots, x_6$ с~семантикой 
рассматриваемой прикладной задачи рис.~1. Как отмечалось выше, 
вероятности входных переменных $x_1, \ldots, x_6$ определяются 
распределением пробелов в~текстах, образующих тестовое множество строк. 
Вероятность события $C_2\hm=0$\linebreak (представляемое переменной~$x_1$) означает 
вероятность того, что на случайно выбранном шаге алгорит\-ма (на всем 
множестве тестовых строк) окажется, что ни одного ведущего пробела пока не 
встречено. В~данном примере эта вероятность равна~0,2, что указывает на 
достаточно высокую плотность пробелов в~строках множества. О~том же 
говорит значение вероятности для переменных~$x_2$ и~$x_4$, соответствующих 
частоте пробелов в~тестовых строках. Значение вероятности для~$x_3$~--- 
вероятность встретить на случайном шаге конец строки, которая 
в~рассматриваемом случае небольшая. Очевидно, что переменные~$x_5$ 
и~$x_3$ (<<$C_1\hm=L_1$>>) логически связаны (чем больше вероятность 
встретить конец строки, тем меньше вероятность того, что строка столь 
(относительно) длинная, что в~случайно выбранный момент времени 
выполняется условие $C_1\hm<L_1$), что ставит вопрос о возможности 
считать их независимыми. 
     
     Отметим, что если, как отмечалось выше, рассматривать данную 
программу анализа наличия и~удаления пробелов как модель 
телекоммуникационной программы, для которой пробелам соответствуют те 
или иные служебные символы, то условие $L_1\hm=0$ означает отсутствие 
в~некоторой посылке информационных символов, а~малые значения 
вероятности $L_1\hm>0$ означают, что информационные посылки достаточно 
редки. 
     
     Приведем примеры вычисления вероятностей самовосстановления также 
для других сбоев и~для различных значений вероятностей $x_1, \ldots, x_6$.

\medskip

\noindent
\textbf{Пример~2.}\ Для сбоя $(10,8)$ и~вероятностей входов~0,05; 0,7; 0,1; 0,05; 
0,9; 0,1 
\begin{multline*}
P_0(t) = [0,\, 0,\, 0,\, 0,\, 0,\, 0{,}00405,\, 0{,}00405,\, 0{,}0040898,\, \\
0{,}062046,\, 0{,}062999, \,0{,}066632, \,0{,}068139,\ 0{,}069252,\,\\
 0{,}10226,\, 0{,}10411,\, 0{,}10778, \,0{,}11016,\,0{,}1119, \\
 0{,}13258,\, 0{,}13501]\,.
\end{multline*}

\noindent
\textbf{Пример~3.}\ Для сбоя~$(7,9)$ при тех же вероятностях входов 
вероятность восстановления крайне мала:
\begin{multline*}
P_0(t) = [0,\, 0,\, 0,\, 0,\, 0,\, 0,\, 0,\, 0{,}00729,\, 0{,}00741,\\
0{,}010307,\, 0{,}010507,\, 0{,}0124,\,  0{,}01847,\, 0{,}018905,\\
0{,}02131,\, 0{,}021632,\, 0{,}0242,\, 0{,}0295,\, 0{,}03004,\, 
0{,}03211].\hspace*{-6.59938pt}
\end{multline*}
     
\section{Обсуждение результатов и~направление дальнейших 
исследований}

     Благодаря предложенному подходу можно судить об устойчивости 
программ к~случайным сбоям и~в~случае необходимости использовать 
дополнительные средства и~методы восстановления программ. При этом 
построение марковской модели (матрица вероятностей переходов) может 
выполняться по раннее разработанным функциональным тестам и~не требует 
дополнительных затрат на построение новых тестов. 
     
    Вероятность самовосстановления для рас\-смат\-ри\-ва\-емой программы 
в~общем случае может быть мала, что ставит вопрос о~том, как информация, 
полученная при изложенном анализе самовосстановления, может быть 
использована проектировщиком для получения вариантов программ, 
устойчивых к~случайным сбоям.

     Рассмотрим основные факторы устойчивости к~сбоям, которые должен 
учитывать проектировщик про\-грам\-мно-ап\-па\-рат\-ной системы, ис\-сле\-ду\-емой 
с~по\-мощью данной модели программы. 
%
Преж\-де всего, как это видно из 
анализа рас\-смотренных примеров, существенным является прикладное 
назначение и~функциональные особенности проектируемой системы, 
отображаемые в~используемых тестовых множествах. Например, для 
рассмотренной программы, если исходя из исходной спецификации проекта 
некоторой системы, частью которой является данная программа, следует, что 
большая часть данных на входе программы (строка~$S_1$) не содержит 
символов заданного (используемого) алфавита, то вероятность 
самовосстановления весьма высока. 

Если же это не так и~вероятности 
самовосстановления на рассматриваемом тестовом множестве малы 
(см.\ пример~3), то проектировщик принимает решение о~тех или иных способах 
обеспечения защиты. 

В~зависимости от используемых критериев качества 
проекта (стоимость, потребление энергии, вес, габариты, надежность и~т.\,д.)\ 
он принимает решение о~том, что более эффективно~--- существенно 
сократить интенсивность сбоев и/или применить те или иные схемы 
самовосстановления. 

Упрощенно оценку влияния аппаратных сбоев можно 
представить следующим образом. Пусть~$L_{n}$~--- список сбоев ((10,8), (7,9) 
и~т.\,д.\ в~рассмотренных примерах). Тогда, оценив известными методами 
вероятности аппаратных сбоев~\cite{1-fr}~$p_i$, $i\hm=1, \ldots, \vert L_n\vert$, 
которые влияют, например, на соответствующие области программной памяти, 
ответственные за сбои из списка~$L_n$, вероятность сбоя на интервале 
тактов~$[1, t]$:    
     $$
     P_t=\sum\limits_{i=1,\ldots, \vert L_n\vert} p_i  P_0^i\,,
     $$
где $P_0^i$~--- компоненты векторов $P_0(t)$, соответствующие тактам $1, 
2,\ldots, t$ для каждого из сбоев~$i$ из списка~$L_n$, примеры вычислений 
которых даны в~предыдущем разделе и~которые в~данном случае 
интерпретируются как условные вероятности сбоя, при условии что произошел 
сбой~$i$, а~приведенная формула представляет собой формулу \textit{полной 
вероятности} события <<произошел сбой>>. Имея список сбоев 
и~вычисленные вероятности са\-мо\-вос\-ста\-нов\-ле\-ния, можно сформулировать 
требования к~аппаратуре для обеспечения допустимых~$p_i$. Далее 
разработчик использует те или иные подходы к~обеспечению устойчивости 
программного обеспечения к~сбоям, например N-version programming, при 
которой в~память записывается~$n$ (где $n$~--- нечетное число) копий 
(версий) программы с последующим сравнением результатов <<по 
большинству>>.
{\looseness=1

}

     Другой практически важной задачей является оценка чувствительности 
к~сбою в~тестовом наборе, когда при передаче некоторого блока символов 
случайно изменился один из символов. Эту ситуацию также желательно 
оценить при анализе проекта ВС, так как это говорит либо о~проявлении сбоя 
в~канале ввода данных (в~данном случае~--- символьных строк), либо, если 
рассматривается модульная система, о~сбое в~модуле (аппаратном или 
программном), являющемся источником данных для диагностируемого 
программного модуля.
     
     Формально именно эта задача может решаться при использовании 
модели~4.1, и~если тесты чувствительны к~кратковременным сбоям, то есть 
основания надеяться, что эти тесты обладают высоким качеством (полнотой) 
также относительно других классов отказов, например ошибок при 
выполнении функций. Согласно общему принципу тестирования некоторое 
ошибочное изменение в~сис\-те\-ме проверяется, если хотя бы одна из 
наблюдаемых выходных переменных изменяет свое значение по сравнению 
с~исправной (эталонной) сис\-те\-мой при заданном множестве наблюдаемых (при 
тестировании) переменных. Если это произошло, система признается 
неисправной и~дальнейшее ее функционирование невозможно (срабатывают те 
или иные механизмы принудительной остановки). 
{\looseness=1

}

Однако вероятность 
обнаружения сбоя на выходах зависит от того, какое подмножество 
компонентов вектора~$Y$ рассматривается в~качестве выходов программы 
и~с~какой периодичностью\linebreak (каков интервал в~тактах между 
последовательными наблюдениями выходов). 
Например, для рассматриваемой 
программы контролировать было бы логично только компонент вектора 
выходов Pr$S_2$ (см.\ рис.~1). Это означает, что при задании поглощающего 
состояния~$A_1$ решения задачи оценки вероятности обнаружения 
(тестирования) сбоя необходимо учитывать используемые контролируемые 
выходы.
{ %\looseness=1

}
     
     Расширение предложенной модели на задачу оценки вероятности 
обнаружения случайного сбоя на заданном подмножестве контролируемых 
выходов представляется весьма актуальным и~является предметом дальнейших 
исследований. 

{\small\frenchspacing
 {%\baselineskip=10.8pt
 \addcontentsline{toc}{section}{References}
 \begin{thebibliography}{99}

\bibitem{1-fr}
\Au{Li X., Adve S.\,V., Bose~P., Rivers~J.\,A.} Softarch: An architecture level tool for modeling 
and analyzing soft errors~//  Conference (International) on Dependable Systems and Networks 
(DSN) Proceedings.~--- Yokohama, Japan, 2005. P.~496--505.
\bibitem{2-fr}
\Au{Darbar A., Al-Hashimi~B., Harrod~P., Bradley~D.} A~new approach for transient fault 
injection using symbolic simulation~// 14th IEEE On-Line Testing Symposium 
(International) Proceedings, 2008. P.~93--98.
\bibitem{3-fr}
\Au{Frenkel S., Pechinkin~A.} Estimation of self-healing time for digital systems under transient 
faults~// Информатика и~её применения, 2010. Т.~4. Вып.~3. С.~2--8. 
\bibitem{4-fr}
\Au{Френкель С.\,Л., Захаров~В.\,Н., Ушаков~В.\,Г.} Вероятностная верификация при 
проектировании вычислительных сис\-тем~// Инструменты и~методы анализа программ 
(TMPA-2014): Мат-лы междунар. науч.-практич. конф.~--- Кострома: КГТУ, 2014.  
С.~148--155.
\bibitem{5-fr}
\Au{Li X., Yeung D.} Application-level correctness and its impact on fault tolerance~//  16th 
Symposium (International) on High-Performance Computer Architecture.~--- Bangalore, India, 
2010. P.~220--225.
\bibitem{6-fr}
\Au{Шалыто А.\,А., Туккель~Н.\,И.} SWITCH-тех\-но\-ло\-гия~--- автоматный подход 
к~созданию программного обеспечения <<реактивных>> сис\-тем~// Программирование, 
2001. №\,5. С.~45--62.
\bibitem{7-fr}
\Au{Baranov S., Frenkel~S., Zakharov~V.} Semiformal verification for pipelined digital designs 
based on Algorithmic State Machines~// Информатика и~её применения, 2010. Т.~4. Вып.~3. 
C.~49--60.
\bibitem{8-fr}
\Au{Baranov S.} ASMs in high level synthesis of EDA tool Abelite~// DESDes'09 IFAC 
Workshop (International) Proceedings.~--- Valensia, Spain, 2009. P.~195--200.
\bibitem{9-fr}
\Au{Lala P.\,K., Kumar~B.\,K.} On self-healing digital system design~// J.~Microelectronics, 
2006. Vol.~37. P.~353--362.
\bibitem{10-fr}
\Au{Френкель C.\,Л., Либуркин~Д.\,Л.} Программа оценки времени самовосстановления 
цифровой системы после сбоя по ее высокоуровневой модели. Свидетельство 
о~государственной регистрации программы для ЭВМ №\,2013661815 от 16.12.2013.

 \end{thebibliography}

 }
 }

\end{multicols}

\vspace*{-3pt}

\hfill{\small\textit{Поступила в~редакцию 31.10.16}}

\vspace*{8pt}

%\newpage

%\vspace*{-24pt}

\hrule

\vspace*{2pt}

\hrule

%\vspace*{8pt}


\def\tit{A~PROBABILISTIC MODEL FOR~ESTIMATION OF~SOFTWARE ROBUSTNESS TO~SHORT-TERM 
HARDWARE FAILURES}

\def\titkol{A~probabilistic model for~estimation of~software robustness to~short-term 
hardware failures}

\def\aut{S.\,L.~Frenkel$^1$, V.\,N.~Zakharov$^2$, and B.\,M.~Basok$^3$}

\def\autkol{S.\,L.~Frenkel, V.\,N.~Zakharov, and B.\,M.~Basok}

\titel{\tit}{\aut}{\autkol}{\titkol}

\vspace*{-9pt}


\noindent
$^1$Institute of Informatics Problems, Federal Research Center ``Computer Sciences and Control'' of the 
Russian\linebreak
$\hphantom{^1}$Academy of Sciences, 44-2~Vavilov Str., Moscow 119333, Russian Federation 

\noindent
$^2$Federal Research Center ``Computer Science and Control" of the Russian Academy of Sciences, 
44-2~Vavilov\linebreak
$\hphantom{^1}$Str., Moscow 119333, Russian Federation 

\noindent
$^3$Moscow Technological University ``MIREA,'' 78~Vernadskogo Ave., Moscow 119454, Russian 
Federation



\def\leftfootline{\small{\textbf{\thepage}
\hfill INFORMATIKA I EE PRIMENENIYA~--- INFORMATICS AND
APPLICATIONS\ \ \ 2017\ \ \ volume~11\ \ \ issue\ 1}
}%
 \def\rightfootline{\small{INFORMATIKA I EE PRIMENENIYA~---
INFORMATICS AND APPLICATIONS\ \ \ 2017\ \ \ volume~11\ \ \ issue\ 1
\hfill \textbf{\thepage}}}

\vspace*{3pt}



\Abste{The paper shows the possibility of using a two-dimensional Markov model 
defined on direct product of state spaces of two finite-state machines (FSM), one of 
which is a program finite automaton model that is running under normal conditions 
and the other one is the same FSM in which at some point in time, there was 
a~short-term failure  (e.\,g., within the time of a single operation or one machine cycle), for 
estimation of software robustness to short-term hardware failures. 
Previously, this model  was proposed for probabilistic verification of hardware systems. The 
robustness of a program is estimated by probability of the faulty FSM  return  on the 
path of transitions of the source machine after termination of the failure. At the same 
time, the authors assume that a change in the FSM transitions trajectory in  
a~low-level (instruction-by-instruction) program model will be significant only if it 
corresponds to some corruption in the branching of said block-diagram. The model is 
analyzed in detail by the example of the block-diagram of a specific program.}

\KWE{self-repairing software; transient faults; Markovian models; testing}

  \DOI{10.14357/19922264170104}  

%\vspace*{-9pt}

\Ack
\noindent
The work was partly supported by the Russian Foundation for Basic
Research (projects 16-07-01028 and~15-07-05316).

\pagebreak

%\vspace*{3pt}

  \begin{multicols}{2}

\renewcommand{\bibname}{\protect\rmfamily References}
%\renewcommand{\bibname}{\large\protect\rm References}

{\small\frenchspacing
 {%\baselineskip=10.8pt
 \addcontentsline{toc}{section}{References}
 \begin{thebibliography}{99}

\bibitem{1-fr-1}
\Aue{Li, X., S.\,V.~Adve, P.~Bose, and J.\,A.~Rivers}. 2005. Softarch: An architecture level tool for modeling 
and analyzing soft errors. \textit{Conference (International) on Dependable Systems and Networks (DSN) 
Proceedings}. Yokohama, Japan. 496--505.

\bibitem{2-fr-1}
\Aue{Darbar,~A., B.~Al~Hashimi, P.~Harrod, and D.~Bradley}. 2008. A~new approach for transient fault 
injection using symbolic simulation. \textit{14th IEEE On-Line Testing Symposium 
(International) Proceedings}. 93--98.

\bibitem{3-fr-1}
\Aue{Frenkel, S., and A.~Pechinkin}. 2010. Estimation of self-healing time for digital systems under 
transient faults. \textit{Informatika i~ee Primeneniya~--- Inform. Appl.} 4(3):2--8. 

\bibitem{4-fr-1}
\Aue{Frenkel, S.\,L., V.\,N.~Zakharov, and V.\,G.~Ushakov}. 2014. Veroyatnostnaya verifikatsiya pri 
proektirovanii vychislitel'nykh sistem [Probabilistic verification of computer systems design]. 
\textit{Scientific-Practical Conference (International) ``Tools \& Methods of Program Analysis'' (TMPA 2014) 
Proceedings}. Kostroma: KGTU. 148--155.

\bibitem{5-fr-1}
\Aue{Li, X., and D.~Yeung}. 2010.  Application-level correctness and its impact on fault tolerance. 
\textit{16th Symposium (International) on High-Performance Computer Architecture}. Bangalore, India.  
220--225.

\bibitem{6-fr-1}
\Aue{Tukkel, N.\,N., and A.\,A.~Shalyto}. 2001. SWITCH-tekhnologiya~--- avtomatnyy podkhod k~sozdaniyu 
programmnogo obespecheniya ``reaktivnykh'' sistem [SWITCH-technology is an automatic approach to 
software design]. \textit{Programmirovanie} [Programming] 5:45--62.   

\bibitem{7-fr-1}
\Aue{Baranov, S., S.~Frenkel, and V.~Zakharov}. 2010. Semiformal verification for pipelined digital designs 
based on Algorithmic State Machines. \textit{Informatika i~ee Primeneniya~--- Inform. Appl.} 4(4):48--59.

\bibitem{8-fr-1}
\Aue{Baranov, S.} 2009. ASMs in high level synthesis of EDA tool Abelite. \textit{DESDes'09 IFAC Workshop 
(International) Proceedings}. Valensia, Spain. 195--200.

\bibitem{9-fr-1}
\Aue{Lala, P.\,K., and B.\,K.~Kumar}. 2007. On self-healing digital system design. 
\textit{J.~Microelectronics} 37:353--362.

\bibitem{10-fr-1}
\Aue{Frenkel, S.\,L., and D.~Liburkin}. December~16, 2013. Programma dlya otsenki vremeni 
samovosstanovleniya tsifrovoy sistemy posle sboya po ee vysokourovnevoy modeli [Program for 
estimation of a digital system self-repairing after a transient fault by a~high-level model of the system]. 
Svidetel'stvo o~gosudarstvennoy registratsii [Sertificate of state registration] No.\,2013661815.
\end{thebibliography}

 }
 }

\end{multicols}

\vspace*{-3pt}

\hfill{\small\textit{Received October 31, 2016}}

\Contr

\noindent
\textbf{Frenkel Sergey L.} (b.\ 1951)~--- Candidate of Science (PhD) in technology, senior scientist, 
Institute of Informatics Problems, Federal Research Center ``Computer Sciences and Control'' of the 
Russian Academy of Sciences, 44-2~Vavilov Str., Moscow 119333, Russian Federation; 
\mbox{fsergei51@gmail.com}

\vspace*{3pt}

\noindent
\textbf{Zakharov Victor N.} (b.\ 1948)~--- Doctor of Science in technology, associate professor; Scientific 
Secretary, Federal Research Center ``Computer Science and Control" of the Russian Academy of Sciences, 
44-2~Vavilov Str., Moscow 119333, Russian Federation; \mbox{vzakharov@ipiran.ru}

\vspace*{3pt}

\noindent
\textbf{Basok Boris M.} (b.\ 1948)~--- Candidate of Science (PhD) in technology, associate professor, 
Moscow Technological University ``MIREA,'' 78~Vernadskogo Ave., Moscow 119454, Russian Federation; 
\mbox{VM\_E@mail.ru} 

\label{end\stat}


\renewcommand{\bibname}{\protect\rm Литература} 