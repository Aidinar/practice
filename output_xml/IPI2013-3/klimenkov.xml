<?xml version="1.0" encoding="utf-8"?>
<papers>
  <paper>
    <metadata>
      <annotation value="\Abst{Обсуждаются вопросы анализа взаимодействия пользователя с веб-при ло же ни ем, методы проведения подобного анализа и их недостатки. Приведена реализация новостного рекомендательного сервиса с использованием существующих подходов. Описан новый подход к построению рекомендательных сис тем, работающих в режиме, близком к режиму реального времени, с использованием NoSQL (not only structured query language) сис те мы управ ле ния базами данных (СУБД).}"/>
      <keywords>
        <braces>
          <text value="\KW{рекомендательные системы; minhash; mapreduce; NoSQL}"/>
        </braces>
      </keywords>
    </metadata>
    <fulltext>
      <literature/>
      <text value="klimenkov"/>
      <text value="ПОСТРОЕНИЕ НОВОСТНОГО РЕКОМЕНДАТЕЛЬНОГО СЕРВИСА РЕАЛЬНОГО ВРЕМЕНИ С ИСПОЛЬЗОВАНИЕМ NoSQL СУБД$^*$"/>
      <text value="Построение новостного рекомендательного сервиса реального времени с использованием NoSQL СУБД"/>
      <text value="П."/>
      <text value="А. Клеменков"/>
      <text value="П."/>
      <text value="А. Клеменков$^1$"/>
      <command value="\titel">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\tit">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\aut">
                    <braces/>
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <command value="\autkol">
                          <braces/>
                          <braces>
                            <braces>
                              <text value="{}"/>
                              <command value="\titkol">
                                <braces/>
                                <braces>
                                  <braces>
                                    <text value="{}"/>
                                    <command value="\renewcommand">
                                      <braces>
                                        <braces>
                                          <text value="{}"/>
                                          <command value="\thefootnote">
                                            <braces/>
                                            <braces>
                                              <braces>
                                                <text value="{}"/>
                                                <command value="\fnsymbol">
                                                  <braces>
                                                    <braces>
                                                      <text value="{}"/>
                                                      <text value="footnote"/>
                                                    </braces>
                                                  </braces>
                                                  <braces/>
                                                  <braces/>
                                                </command>
                                              </braces>
                                            </braces>
                                          </command>
                                        </braces>
                                      </braces>
                                    </command>
                                  </braces>
                                </braces>
                              </command>
                            </braces>
                          </braces>
                        </command>
                      </braces>
                    </braces>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[1]{}"/>
        </braces>
      </command>
      <text value="Статья рекомендована к публикации в журнале Программным комитетом конференции &amp;lt;&amp;lt;Электронные библиотеки: перспективные методы и технологии, электронные коллекции&amp;gt;&amp;gt; (RCDL-2012)."/>
      <command value="\renewcommand">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\thefootnote">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\arabic">
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <text value="footnote"/>
                      </braces>
                    </braces>
                    <braces/>
                    <braces/>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[1]{}"/>
        </braces>
      </command>
      <text value="Московский государственный университет им."/>
      <text value="М."/>
      <text value="В. Ломоносова, parser@cs.msu.su"/>
      <command value="\vskip">
        <braces>
          <text value="14pt plus 9pt minus 6pt"/>
        </braces>
      </command>
      <command value="\thispagestyle">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="headings"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\begin">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="2"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\label">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="st"/>
            <command value="\stat">
              <braces/>
            </command>
          </braces>
        </braces>
      </command>
      <section id="id1">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Введение"/>
        <text value="Основным отличием приложений Веб 2.0 от их более старых аналогов является анализ взаимодействия пользователя с приложением и использование результатов этого анализа для модификации контента и его представления. Темпы развития сети Интернет диктуют создателям современных веб-приложений необходимость очень быстро адаптировать контент под предпочтения пользователей. Наиболее востребованным решением этой задачи стали рекомендательные системы, способные анализировать поведение пользователя, его склонности и предлагать наиболее интересное наполнение. Проблема с подобными системами заключается в том, что они недостаточно быстро реагируют на постоянно изменяющийся поток входных данных. Особенно подвержены этому новостные ресурсы. Такое поведение связано не столько с алгоритмами, применяемыми для выявления пользовательских предпочтений, сколько с архитектурными особенностями той инфраструктуры и библиотек, которые широко используются для подобного анализа. В данной статье представлен подход к организации новостного рекомендательного сервиса, призванного максимально устранить задержки в пересчете рекомендаций и обеспечить работу в режиме, близком к режиму реального времени."/>
      </section>
      <section id="id2">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Методы веб-анализа"/>
        <text value="Сегодня для анализа взаимодействия пользователя с веб-приложением применяются два основных подхода:"/>
        <enumerate/>
        <text value="У каждого из этих подходов есть преимущества и недостатки, на которых стоит остановиться подробнее."/>
        <subsection>
          <text value="Аналитика в реальном времени"/>
          <text value="Суть подхода заключается в том, что в ответ на взаимодействие пользователя с веб-приложением специально установленный фрагмент кода (счетчик) генерирует определенные события, обрабатываемые приложением-анализатором в реальном времени. Очевидно, что основным преимуществом подобной парадигмы является немедленное получение результатов и их обновление. Однако методы, применяемые при анализе данных в реальном времени, наиболее подходят для различных статистических расчетов (CTR, Churn Rate). При этом целые классы приложений не могут быть реализованы предложенными средствами."/>
          <figure id="id3" value="Token(TokenType.COMMAND&amp;quot;, &amp;quot;\begin{figure*}&#10;\vspace*{1pt}&#10;\begin{center}&#10; \mbox{%&#10; \epsfxsize=133.566mm&#10; \epsfbox{kle-1.eps}&#10; }&#10; \end}&#10; \vspace*{-6pt}&#10; \Caption{Схема работы Hadoop-реализации на первом~(\textit{а}) и на втором~(\textit{б}) этапах}&#10;\end{figure*}&amp;quot;, line=86, col=16)"/>
        </subsection>
        <subsection>
          <text value="Отложенная пакетная обработка логов доступа к веб-приложению"/>
          <text value="Этот подход строится на сборе логов доступа к веб-приложению и их последующей обработке большими частями. Имея срез данных о взаимодействии пользователей с приложением за определенный период, возможно строить сложные модели поведения и применять их, например, для выдачи рекомендаций. Современные фреймворки (например, Apache Hadoop) обеспечивают высокую производительность, реализуя потоковую обработку больших объемов данных с использованием метода параллельных вычислений MapReduce"/>
          <text value="1, 2"/>
          <text value="."/>
        </subsection>
      </section>
      <section id="id4">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Рекомендательный сервис проекта Рамблер-новости"/>
        <text value="Рекомендательный сервис проекта Рамблер-новости основывается на объединении пользователей в группы по схожести интересов и вычислении наиболее популярных среди групп новостей в заданном временном окне."/>
        <subsection>
          <text value="Реализация сервиса"/>
          <text value="Суть алгоритма заключается в том, что все пользователи идентифицируются уникальными идентификаторами. Эти идентификаторы связываются с каждым HTTP-запросом к новостным ресурсам (если, конечно, запрос содержал заголовок Cookie с корректным значением). Таким образом, поведение пользователя на сайте характеризуется подмножеством логов доступа к веб-серверам. Подсчитав схожесть каждого подмножества со всеми другими, можно объединить пользователей в группы с похожими предпочтениями. В качестве меры схожести множеств естественно использовать коэффициент Жаккарда. Однако проблема заключается в том, что время работы алгоритма подсчета этого коэффициента на нескольких миллионах множеств с сотнями и тысячами элементов являeтся неприемлемо большим. В качестве оптимизации широко применяется вероятностный"/>
          <command value="\linebreak">
            <braces>
              <text value="\linebreak"/>
            </braces>
          </command>
          <text value="алгоритм MinHash"/>
          <text value="3"/>
          <text value=". Основная идея этого алгоритма заключается в вычислении вероятности равенства минимальных значений хеш-функций элементов множеств. Очевидно, что чем больше одинаковых элементов в двух сравниваемых множествах, тем выше указанная вероятность. А так как вычисление сигнатуры множества (минимумов используемых хеш-функций) происходит только один раз, а размер сигнатуры фиксирован, то вычислительная сложность решаемой задачи резко снижается. Для вычисления новостных рекомендаций было принято решение производить обработку логов доступа веб-серверов Рамблер-новостей во временн"/>
          <formula id="id5" value="$\acute{\mbox{о}}$"/>
          <text value="м окне 5 дней. Средний объем логов за указанный период составляет примерно 7 ГБ. Для реализации алгоритма был выбран фреймворк Hadoop, являющийся де-факто стандартом для потоковой обработки больших объемов данных. Алгоритм вычисления рекомендаций был реализован в виде последовательности MapReduce-задач, разделенных на два этапа: подсчет групп пользователей во временн"/>
          <formula id="id6" value="$\acute{\mbox{о}}$"/>
          <text value="м окне 5 сут."/>
          <text value="и подсчет рекомендаций для групп во временн"/>
          <formula id="id7" value="$\acute{\mbox{о}}$"/>
          <text value="м окне 5 ч. Первый этап составляют следующие ступени (рис. 1,"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="а"/>
          </command>
          <text value=")."/>
          <enumerate/>
          <text value="Также необходимо отметить, что первоначальная реализация алгоритма имела еще один шаг, который позволял строго отсечь необходимое число групп, но ради сокращения вычислений им было решено пренебречь. Второй этап разделен на следующие ступени (рис. 1,"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="б"/>
          </command>
          <text value=")."/>
          <enumerate/>
          <text value="Получающиеся в результате отображения идентификаторов в группы и групп в популярные новости загружаются в хранилище Redis, позволяющее запрашивать список рекомендаций для данного пользователя в реальном времени."/>
        </subsection>
        <subsection>
          <text value="Производительность"/>
          <text value="Приведенная реализация алгоритма использовалась в продуктивном окружении проекта Рамблер-новости более полугода, показывая приемлемое время работы. На Hadoop-класте"/>
          <command value="\specialsymbol">
            <braces>
              <text value="~---"/>
            </braces>
          </command>
          <text value="3,5--4 мин при условии, что другие задачи не выполнялись параллельно. Необходимо отметить, что важным фактором производительности MapReduce-за"/>
          <command value="\specialsymbol">
            <braces>
              <text value="~---"/>
            </braces>
          </command>
          <text value="16."/>
        </subsection>
        <subsection>
          <text value="Проблемы"/>
          <text value="Внимательно изучив получившуюся архитектуру и приняв во внимание проблемы, возникшие при реализации рекомендательного сервиса, можно отметить следующие аспекты."/>
          <enumerate/>
          <text value="Отсюда возникает вопрос: можно ли решить все вышеперечисленные проблемы, воспользовавшись другим подходом? В следующей части статьи будет описана архитектура подобного решения с применением NoSQL-хранилищ данных."/>
        </subsection>
      </section>
      <section id="id8">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Введение в NoSQL"/>
        <text value="Термин NoSQL впервые был использован в 1998 г."/>
        <text value="для описания реляционной базы данных, не использовавшей SQL. Он был вновь подхвачен в 2009 г."/>
        <text value="и использован на конференциях приверженцами нереляционных баз данных. Основной движущей силой развития NoSQL-хранилищ стали веб-стартапы, для которых важнейшей задачей является поддержание постоянной высокой пропускной способности хранилища при неограниченном увеличении объема данных. Рассмотрим основные особенности NoSQL-подхода, делающие его таким привлекательным для высоконагруженных веб-проектов"/>
        <text value="4, 5"/>
        <text value="."/>
        <enumerate/>
      </section>
      <section id="id9">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Классификация NoSQL-хранилищ"/>
        <text value="На сегодняшний день создано большое число NoSQL-хранилищ. Все они основываются на четырех принципах из предыдущего раздела, но могут довольно сильно отличаться друг от друга. Многие теоретики и практики создавали свои собственные классификации, но наиболее простой и общеупотребительной можно считать систему, основанную на используемой модели данных, предложенную Риком Кейтелем (см."/>
        <text value="табл.)"/>
        <text value="7"/>
        <text value="."/>
        <center/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <enumerate/>
      </section>
      <section id="id10">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Построение рекомендательного сервиса Рамблер-новостей с помощью NoSQL"/>
        <text value="Вспоминая недостатки реализации рекомендательного сервиса на фреймворке Hadoop, можно отметить, что NoSQL-хранилища кажутся приемлемым вариантом их устранения. NoSQL-хранилища обеспечивают высокую пропускную способность данных как при чтении, так и при записи. Из этого следует, что логи доступа к веб-приложению можно записывать непосредственно в базу данных. Важно также отметить, что при использовании документно-ориентированных решений логам можно придавать произвольный вид, не создавая жесткую схему. Это позволяет решать довольно интересную задачу хранения и обработки структурированных логов. К тому же механизм выборки документов по значениям атрибутов позволяет решать множество аналитических задач. Большинство современных NoSQL-решений реализуют парадигму вычислений MapReduсe. Наряду с фундаментальным свойством горизонтального масштабирования это дает"/>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="возможность"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="переносить алгоритмы, предназначенные для фреймворков типа Hadoop, на хранилища NoSQL, получая все дополнительные преимущества. Учитывая высокую пропускную способность операций чтения, задачи подсчета рекомендаций и их использования можно не разделять. Следовательно, обновленные рекомендации будут тут же доступны потребителям, что приближает сервис к требованиям реального времени. Далее следовало определиться с конкретным продуктом, который можно было бы использовать для реализации сервиса. Среди документно-ориентированных баз данных первоначальный выбор пал на проект Apache CouchDB"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="8-kli"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". CouchDB работает с документами, представленными в формате JSON (JavaScript Object Notation). Для работы с документами предоставляется REST API (REpresentation State Transfer Application Programming Interface). Для построения запросов к документам CouchDB и их анализа применяются так называемые &amp;lt;&amp;lt;представления&amp;gt;&amp;gt;. По сути представление является обычной MapReduce-задачей, которая может сохранять результаты выполнения в базе. Интересной особенностью модели данных CouchDB является то, что для индексации документов и представлений используются модифицированные B-деревья. Сохраняя все особенности и преимущества стандартного B-дерева, B-деревья CouchDB реализуют режим &amp;lt;&amp;lt;только добавление&amp;gt;&amp;gt;. Это означает, что любые операции вставки, модификации и изменения записываются в конец файла, представляющего B-дерево на диске. Такая архитектура дает два основных преимущества: высокую скорость записи и возможность исполнять MapReduce-задачи только на изменившихся данных. Однако при всех своих преимуществах CouchDB не подходила для решения поставленной задачи. Во-первых, проект не поддерживает никакого языка запросов, что сильно затрудняет выборку документов по определенным критериям. Во-вторых, важным критерием выбора была поддержка ссылок на другие документы. Подобная возможность есть в CouchDB, но работает она только на этапе эмиссии документа из map-задачи. К тому же нет возможности создания ссылок на документы из других баз. В-третьих, неоптимизированное JSON-представление документов приводит к увеличению трафика между клиентом и хранилищем, чего хотелось избежать. Окончательный выбор пал на проект MongoDB"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="9-kli"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Обладая всеми преимуществами CouchDB, это хранилище устраняет перечисленные недостатки и предоставляет дополнительные удобные возможности. Они будут упомянуты в следующем разделе, описывающем реализацию рекомендательного сервиса."/>
          </braces>
        </command>
      </section>
      <section id="id11">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Реализация рекомендательного сервиса Рамблер-новости"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="это запись логов в базу данных MongoDB. Первым делом требовалось определить, какое число операций записи в секунду обеспечивала выбранная конфигурация. Стоит отметить, что тестовая конфигурация представляла собой кластер из двух узлов, на каждом их которых был запущен демон"/>
        <braces>
          <text value="{}"/>
          <command value="\sf">
            <braces>
              <text value="mongod"/>
            </braces>
            <braces/>
            <braces>
              <text value="без репликации. На одном их хостов запускался демон mongos, обеспечивавший шардинг документов. Для определения скорости записи был разработан простой скрипт, производивший загрузку суточных логов новостей в базу MongoDB. Лог состоял из 2"/>
            </braces>
          </command>
        </braces>
        <text value="770"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="2496 операций/с. Шардинг документов осуществлялся по атрибуту"/>
        <braces>
          <text value="{}"/>
          <command value="\sf">
            <braces>
              <text value="ruid"/>
            </braces>
            <braces/>
            <braces>
              <text value="(уникальный идентификатор пользователя). Подобный результат более чем достаточен для рассматриваемого сервиса, так как среднее количество запросов в секунду к веб-сайту Рамблер-новости существенно меньше. Однако загрузка логов из ротированных лог-файлов разработчика не устраивала. Для удовлетворения требования реального времени необходимо было обеспечить загрузку логов в базу сразу после обработки запроса веб-сервером. Для этого с помощью библиотеки ZeroMQ был разработан специализированный демон, агрегировавший логи с нескольких фронт-эндов новостей в хранилище MongoDB. Необходимо отметить, что загрузчик логов не только производил их фильтрацию, представление в формате BSON (Binary JavaScript Object Notation) и запись в базу, но и подсчет значений хеш-функций для каждого URL. Это было обусловлено двумя факторами: снижением времени вычислений и отсутствием приемлемых реализаций быстрого хеширования в языке JavaScript (на нем реализуются MapReduce задачи в MongoDB). После того как задача загрузки логов была решена, необходимо было перенести реализацию алгоритма подсчета рекомендаций с Hadoop на MongoDB. Возвращаясь к реализации первого этапа в подразд. 3.1, можно отметить, что задачи фильтрации логов и подсчета значений хеш-функций для них реализуются загрузчиком. Поэтому оставалось перенести только подсчет минимальных значений хешей и отсечение групп с заданной численностью (рис. 2). Стоит обратить внимание на то, что из новой реализации пропал этап отсечения групп по численности. В первоначальной реализации отсечение делалось главным образом для сокращения времени загрузки отображения"/>
            </braces>
          </command>
          <formula id="id12" value="$\langle$"/>
          <text value="идентификатор"/>
        </braces>
        <text value="пользователя"/>
        <formula id="id13" value="$\rightarrow$"/>
        <text value="группа"/>
        <formula id="id14" value="$\rangle$"/>
        <text value="в Redis. При использовании NoSQL-хранилища подобной проблемы не возникало. Возвращаясь к цифрам, отметим, что задача подсчета минимального хеша для суточных логов (2"/>
        <text value="770"/>
        <text value="695 записей) заняла примерно 3 мин 10 с. Это не сильно отличается от времени выполнения той же задачи на Hadoop-кластере, и почему это"/>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-12pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <center/>
        <braces>
          <text value="{\figurename~2}"/>
        </braces>
        <command value="\small">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="Схема работы NoSQL-реализации на первом ("/>
            </braces>
          </braces>
        </command>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="а"/>
        </command>
        <text value=") и на втором ("/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="б"/>
        </command>
        <text value=") этапах"/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="15pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\addtocounter">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="figure"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="1"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="происходит, вполне очевидно. Однако здесь на помощь приходит вся мощь MongoDB. Во-первых, результаты MapReduce-задач сохраняются в отдельной коллекции. Последующие вычисления можно производить только на добавленных с прошлого запуска логах, выполняя rereduce на получившихся результатах. Во-вторых, мощный язык запросов MongoDB позволяет осуществить выборку логов, добавленных с момента последнего запуска задачи. В предлагаемой архитектуре задача сохранения времени последнего выполнения и перезапуск вычислений возложена на загрузчик логов. Важно отметить, что высокая производительность библиотеки ZeroMQ позволила не масштабировать загрузчик логов, поэтому проблем с синхронизацией времени не возникало. В-третьих, MongoDB поддерживает создание и поддержание индексов на атрибутах документов, что существенно ускоряет выборки. На основании всего вышесказанного было принято решение перезапускать задачу подсчета минимального хеша после записи одной тысячи новых логов с выборкой по атрибуту"/>
        <braces>
          <text value="{}"/>
          <command value="\sf">
            <braces>
              <text value="timestamp"/>
            </braces>
            <braces/>
          </command>
        </braces>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="выработке рекомендаций (рис. 2,"/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="б"/>
        </command>
        <text value="). Здесь возникают три основные проблемы: выборка логов в заданном временн"/>
        <formula id="id15" value="$\acute{\mbox{о}}$"/>
        <text value="м окне, дополнительная фильтрация и ввод данных из нескольких источников. Выборку логов в заданном временном окне можно, как и на первом этапе, осуществлять запросом по атрибуту"/>
        <braces>
          <text value="{}"/>
          <command value="\sf">
            <braces>
              <text value="timestamp"/>
            </braces>
            <braces/>
            <braces>
              <text value=". Стоит отметить, что MongoDB реализует capped collections. Это коллекции с заранее определенным объемом. Если объем коллекции достиг заданного порога, то новые значения затирают старые. Это интересный подход к ротации, но для рассматриваемой задачи он не подходит, так как количество логов может меняться день ото дня. Дополнительная фильтрация осуществляется регулярными выражениями JavaScript, здесь нет никаких сложностей. Проблема ввода данных из нескольких источников решается с помощью механизма DBRef MongoDB. Он позволяет создавать ссылки на связанные документы в виде вложенных документов и получать к ним доступ при выполнении map-за"/>
            </braces>
          </command>
        </braces>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="ссылаться можно на несуществующие документы и коллекции. Этим фактом пользуется загрузчик логов, создавая ссылки на группы, которых еще нет. Таким образом, первые две ступени второго"/>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="этапа"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="удалось объединить в одну: map-задача фильтрует выборку логов во временн"/>
          </braces>
        </command>
        <formula id="id16" value="$\acute{\mbox{о}}$"/>
        <text value="м окне 5 ч и возвращает пару"/>
        <formula id="id17" value="$\langle\mathrm{group}\_\mathrm{id:url}, \mathrm{1}\rangle$"/>
        <text value=", а reduce-зада"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="350 мс на той же тысяче логов. Третья ступень была просто адаптирована для исполнения MongoDB. Надо, правда, отметить, что отсечение заданного количества популярных новостей не производится. Эту задачу с целью сокращения объема вычислений было решено возложить на потребителя. Также следует сказать, что на последней ступени используется функция"/>
        <braces>
          <text value="{}"/>
          <command value="\sf">
            <braces>
              <text value="finalize"/>
            </braces>
            <braces/>
            <braces>
              <text value=", позволяющая видоизменить результаты reduce-задачи. В данном случае функция"/>
            </braces>
            <braces>
              <braces>
                <text value="{}"/>
                <command value="\sf">
                  <braces>
                    <text value="finalize"/>
                  </braces>
                  <braces/>
                  <braces>
                    <text value="производит сортировку новостей в группах по числу кликов."/>
                  </braces>
                </command>
              </braces>
            </braces>
          </command>
        </braces>
      </section>
      <section id="id18">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Проблемы, возникшие при реализации сервиса рекомендаций"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="ротирование логов. Так как в MongoDB отсутствует механизм времени жизни ключей, задачу ротирования логов приходится решать периодическим запуском отдельной MapReduce-задачи. К тому же во всех документах, требующих удаления, приходится явно хранить метку времени жизни. Вторая трудность заключается в том, что формат возвращаемых map-задачей значений должен совпадать с форматом значений, возвращаемых reduce-задачей. Из-за этого приходится создавать довольно сложные структуры, чего хотелось бы избежать. Третья труд"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="это специфическое устройство шардинга в MongoDB. Ключи распределяются по узлам не равномерно, а группами. Из-за этого некоторые MapReduce-задачи на небольшом числе документов выполняются на одном узле, содержащем все ключи."/>
      </section>
      <section id="id19">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Заключение"/>
        <text value="В результате проведенного эксперимента удалось создать рекомендательный сервис, время пересчета рекомендаций в котором на каждую тысячу новых логов составляет 1,5--2 с. Для проекта Рамблер-новости подобный результат является удовлетворительным, так как 1000 новых запросов к сайту делается за чуть большее время. Стоит отметить, что алгоритм MinHash как таковой не предназначен для подсчета рекомендаций в режиме реального времени. Более того, эффективность новой реализации рекомендательного сервиса может оказаться ниже, чем предыдущая реализация с помощью фреймворка Hadoop. Однако целью данной работы было показать целесообразность применения NoSQL-подхода к построению систем анализа данных в режиме, близком к режиму реального времени. Сделанные выводы позволят реализовать на описанной платформе более подходящие рекомендательные алгоритмы, например Covisitation"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="5-kli"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Важным свойством приведенной реализации является то, что задачи хранения и анализа данных удалось объединить с задачей предоставления доступа к результатам в единой системе, избежав накладных расходов на перемещение данных из одного источника в другой и улучшив общую производительность сервиса. Кроме того, предложенный подход упрощает решение повседневных задач сбора статистики о взаимодействии пользователя с веб-приложением путем анализа структурированных логов мощным языком запросов СУБД MongoDB. Можно утверждать, что применение NoSQL-подхода к решению подобного класса задач весьма перспективно и может быть использовано в продуктивном окружении высоконагруженных веб-приложений."/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <command value="\small"/>
              <command value="\frenchspacing">
                <braces>
                  <braces>
                    <text value="{}"/>
                  </braces>
                </braces>
              </command>
            </braces>
          </braces>
        </command>
        <command value="\addcontentsline">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="toc"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="section"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="Литература"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\begin">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="9"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <item id="id20" value="\bibitem">
          <braces>
            <text value="\bibitem{1-kli}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Dean J., Ghemawat S."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="Berkeley, CA, USA: USENIX Association, 2004. P. 137--149."/>
        <item id="id21" value="\bibitem">
          <braces>
            <text value="\bibitem{2-kli}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Venner J."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="N.Y.: Apress, 2009."/>
        <item id="id22" value="\bibitem">
          <braces>
            <text value="\bibitem{3-kli}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Das A."/>
        <text value="S., Datar M., Garg A., Rajaram Sh."/>
        <text value="Google news personalization: Scalable online collaborative filtering // 16th Conference (International) on World Wide Web Proceedings, 2007. P. 271--280."/>
        <item id="id23" value="\bibitem">
          <braces>
            <text value="\bibitem{4-kli}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Pokorny J."/>
        <text value="NoSQL databases: A step to database scalability in web environment // 13th Conference (International) on Information Integration and Web-Based Applications and Services Proceedings, 2011. P. 278--283."/>
        <item id="id24" value="\bibitem">
          <braces>
            <text value="\bibitem{5-kli}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Strauch C."/>
        <text value="NoSQL databases."/>
        <braces>
          <text value="{}"/>
          <command value="\sf">
            <braces>
              <text value="http://www.christof-strauch.de/nosqldbs.pdf"/>
            </braces>
            <braces/>
            <braces>
              <text value="."/>
            </braces>
          </command>
        </braces>
        <item id="id25" value="\bibitem">
          <braces>
            <text value="\bibitem{6-kli}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Chang F., Dean J., Ghemawat S., Hsieh W."/>
        <text value="C., Wallach D."/>
        <text value="A., Burrows M., Chandra T., Fikes A., Gruber R."/>
        <text value="E."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="Berkeley, CA, USA: USENIX Association, 2006. Vol. 7. P. 205--218."/>
        <item id="id26" value="\bibitem">
          <braces>
            <text value="\bibitem{7-kli}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Cattel R."/>
        <text value="Scalable SQL and NoSQL data stores // ACM SIGMOD Record, 2010. Vol. 39. No."/>
        <text value="4. P. 12--27."/>
        <item id="id27" value="\bibitem">
          <braces>
            <text value="\bibitem{8-kli}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Anderson J."/>
        <text value="C., Lehnardt J., Slater N."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="Sebastopol: O&amp;apos;Reilly Media, 2010."/>
        <command value="\label">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="end"/>
              <command value="\stat">
                <braces/>
              </command>
            </braces>
          </braces>
        </command>
        <item id="id28" value="\bibitem">
          <braces>
            <text value="\bibitem{9-kli}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Chodorow K., Dirolf M."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="Sebastopol: O&amp;apos;Reilly Media, 2010."/>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="thebibliography"/>
            </braces>
          </braces>
          <braces/>
          <braces/>
          <braces/>
        </command>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="multicols"/>
            </braces>
          </braces>
          <braces/>
        </command>
      </section>
    </fulltext>
  </paper>
</papers>