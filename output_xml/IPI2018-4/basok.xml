<?xml version="1.0" encoding="utf-8"?>
<papers>
  <paper>
    <metadata>
      <author value="\index{}"/>
      <author value="\index{}"/>
      <author value="\index{}"/>
      <author value="\index{}"/>
      <author value="\index{}"/>
      <author value="\index{}"/>
      <annotation value="\Abst{Обсуждается и анализируется возможность обеспечения эффективного тестирования готовых к использованию программных продуктов (ГИПП), решающих задачи вычисления функций, в условиях отсутствия полной информации, необходимой для традиционного тестирования. Под эффективностью понимается возможность обеспечения сколь угодно высокой вероятности обнаружения возможных ошибок вычислений, не выявленных при выходном контроле, по мере роста чис RSR), т.е.функций, вычисление которых на конкретном входном наборе можно свести к вы чис ле нию на нескольких случайно выбранных входных наборах. Обосновывается рациональность обеспечения свойств са мо тес ти ру емости в коммерческих вычислительных ГИПП.}"/>
      <keywords>
        <braces>
          <text value="\KW{тестирование программ; самотестирование}"/>
        </braces>
      </keywords>
    </metadata>
    <fulltext>
      <literature/>
      <text value="basok"/>
      <text value="ИСПОЛЬЗОВАНИЕ ВЕРОЯТНОСТНОЙ МОДЕЛИ ВЫЧИСЛЕНИЙ ДЛЯ ТЕСТИРОВАНИЯ ОДНОГО КЛАССА ГОТОВЫХ К ИСПОЛЬЗОВАНИЮ ПРОГРАММНЫХ КОМПОНЕНТОВ ЛОКАЛЬНЫХ И СЕТЕВЫХ СИСТЕМ$^*$"/>
      <text value="Использование вероятностной модели вычислений для тестирования одного класса"/>
      <text value="программных компонентов"/>
      <text value="Б."/>
      <text value="М. Басок$^1$, В."/>
      <text value="Н. Захаров$^2$, С."/>
      <text value="Л. Френкель$^3$"/>
      <text value="Б."/>
      <text value="М. Басок, В."/>
      <text value="Н. Захаров, С."/>
      <text value="Л. Френкель"/>
      <command value="\titel">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\tit">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\aut">
                    <braces/>
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <command value="\autkol">
                          <braces/>
                          <braces>
                            <braces>
                              <text value="{}"/>
                              <command value="\titkol">
                                <braces/>
                              </command>
                            </braces>
                          </braces>
                        </command>
                      </braces>
                    </braces>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <text value="Басок Б."/>
      <text value="М."/>
      <text value="Захаров В."/>
      <text value="Н."/>
      <text value="Френкель С."/>
      <text value="Л."/>
      <text value="Basok B."/>
      <text value="M."/>
      <text value="Zakharov V."/>
      <text value="N."/>
      <text value="Frenkel S."/>
      <text value="L."/>
      <braces>
        <text value="{}"/>
        <command value="\renewcommand">
          <braces>
            <braces>
              <text value="{}"/>
              <command value="\thefootnote">
                <braces/>
                <braces>
                  <braces>
                    <text value="{}"/>
                    <command value="\fnsymbol">
                      <braces>
                        <braces>
                          <text value="{}"/>
                          <text value="footnote"/>
                        </braces>
                      </braces>
                      <braces/>
                      <braces/>
                    </command>
                  </braces>
                </braces>
              </command>
            </braces>
          </braces>
        </command>
      </braces>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[1]{}"/>
        </braces>
      </command>
      <text value="Работа выполнена при частичной финансовой поддержке РФФИ (проекты 18-07-00669, 18-29-03100)."/>
      <command value="\renewcommand">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\thefootnote">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\arabic">
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <text value="footnote"/>
                      </braces>
                    </braces>
                    <braces/>
                    <braces/>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[1]{}"/>
        </braces>
      </command>
      <command value="\specialsymbol">
        <braces>
          <text value="~---"/>
        </braces>
      </command>
      <text value="Российский технологический университет, VM"/>
      <command value="\_E">
        <braces>
          <text value="@mail.ru"/>
        </braces>
        <braces/>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[2]{}"/>
        </braces>
      </command>
      <text value="Федеральный исследовательский центр &amp;lt;&amp;lt;Информатика и управление&amp;gt;&amp;gt; Российской академии наук,"/>
      <command value="\mbox">
        <braces>
          <braces>
            <text value="{}"/>
            <affiliation>
              <braces>
                <text value="VZakharov@ipiran.ru"/>
              </braces>
            </affiliation>
          </braces>
        </braces>
        <braces/>
        <braces/>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[3]{}"/>
        </braces>
      </command>
      <text value="Институт проблем информатики Федерального исследовательского центра &amp;lt;&amp;lt;Информатика и управление&amp;gt;&amp;gt; Российской академии наук,"/>
      <command value="\mbox">
        <braces>
          <braces>
            <text value="{}"/>
            <affiliation>
              <braces>
                <text value="fsergei51@gmail.com"/>
              </braces>
            </affiliation>
          </braces>
        </braces>
        <braces/>
        <braces/>
      </command>
      <command value="\vspace*">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="-8pt"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\vspace*">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="-4pt"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\vskip">
        <braces>
          <text value="10pt plus 9pt minus 6pt"/>
        </braces>
      </command>
      <command value="\thispagestyle">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="headings"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\begin">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="2"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\label">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="st"/>
            <command value="\stat">
              <braces/>
            </command>
          </braces>
        </braces>
      </command>
      <section id="id1">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Введение"/>
        <text value="При приобретении ГИПП перед пользователем стоит задача убедиться в его полной исправности, в его способности без ошибок выполнять те функции, которые указаны в прилагаемой к нему документации. Для этого непосредственно перед эксплуатацией программный продукт (ПП) должен быть тщательно протестирован пользователями или передан для этого фирме, специализирующейся на тестировании ПП. Данные действия должны осуществляться независимо от того, прилагаются к ГИПП тесты разработчика или они отсутствуют. В первом случае"/>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <text value="следует убедиться, что ПП работает и с другими данными, выполнить проверку наиболее сложных и труднореализуемых функций, особенно тех, ошибки в которых могут привести к непредсказуемым последствиям. Во втором случае тестирование, безусловно, необходимо, поскольку только в этом случае можно убедиться в работоспособности ГИПП и его возможностях. Технология тестирования ГИПП отличается от технологии тестирования ПП на этапе его разработки и имеет свои особенности. Эти особенности подробно были разобраны в работе"/>
        <text value="1"/>
        <text value=". Среди данных особенностей можно в первую очередь выделить следующие:"/>
        <itemize/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="это последовательность шагов, каждый из которых содержит описание действий, предпринимаемых тестером, и описание ожидаемых результатов, используемых при тестировании в качестве эталонов. Разработка тестов ведется тестером на основе изучения работы ГИПП и эксплуатационной документации. В связи с тем что тестер может смоделировать лишь небольшую часть функций программы (так называемое остаточное моделирование)"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="7-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", возможны ошибки при задании как входных данных, так и ожидаемых результатов (эталонных значений), получаемых вручную. Эти ошибки проявляются при реализации процедур сравнения полученных результатов тестирования и эталонных данных и принятия на их основе решений о наличии ошибок в ПП, называемых в специальной литературе оракулами"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="4-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". При этом основную часть этих ошибок составляют ошибки, связанные с заданием эталонов, поскольку их получение осуществляется тестером, как правило, вручную"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="2-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Кроме того, в связи с тем что входные данные тестов ПП, как правило, представляют собой искусственно подобранные наборы данных, нет гарантии, что они достаточно полно проверяют все особенности ПП. В то же время при выполнении реальных задач с произвольными данными можно обнаружить некоторые отказы в программе, поскольку при их выполнении осуществляется максимальный охват программного кода. Например, при тестировании текстового редактора реальные"/>
          </braces>
        </command>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <text value="тексты могут быть не менее полезными, чем специально подобранные буквосочетания. Однако определение ожидаемых результатов при обработке"/>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <text value="программой реальных данных, особенно при реализации сложных вычислительных процессов, оказывается достаточно трудоемкой процедурой и, как следствие этого, с возможными ошибками. Таким образом, задача получения правильных эталонных данных при тестировании ГИПП является достаточно сложной и актуальной. В предлагаемой статье рассматривается ряд принципиальных трудностей практики тестирования, связанных с отсутствием полной спецификации программы и информации о тестах разработчика, об эталонных значениях в частности. Будет показано, что для программ, реализующих функции, обладающие свойствами случайной самоприводимости (RSR"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="5-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="), т."/>
          </braces>
        </command>
        <text value="е."/>
        <text value="функций, вычисление которых на конкретном входном наборе можно свести к вычислению на случайно выбранных входных наборах, часть трудностей, связанных с отсутствием эталонов, можно преодолеть. Заметим, что вопрос использования свойств RSR далеко не новый, он широко обсуждался в начале 1990-х гг."/>
        <text value="в рамках задач самотестирования/самопроверяемости (self-testing/self-checking) программ"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="6-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Принимая во внимание опыт по практическому тестированию программ"/>
          </braces>
          <braces/>
          <braces>
            <text value="1, 2"/>
          </braces>
          <braces/>
          <braces>
            <text value=", авторы считают полезным рассмотреть применение данной модели к проблеме тестирования готовых к использованию программ, особенно в связи с отмеченной проблемой обеспечения тестера информацией об эталонных значениях вычисляемых функций."/>
          </braces>
        </command>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-6pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
      </section>
      <section id="id2">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Основные подходы к тестированию готового к использованию программного продукта"/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-2pt"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="Подходы к тестированию ГИПП зависят в основном от того, для решения каких задач они используются. Возможны следующие ситуации:"/>
          </braces>
        </command>
        <enumerate/>
        <text value="Основные современные подходы к разработке тестов для различных вариантов данного списка задач можно разделить на методы &amp;lt;&amp;lt;черного ящика&amp;gt;&amp;gt; и инжекции ошибок (который может включать в себя и метод &amp;lt;&amp;lt;мутаций&amp;gt;&amp;gt; кодов и входных данных"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="8-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=")."/>
          </braces>
        </command>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-3pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <subsection>
          <text value="Метод &amp;lt;&amp;lt;черного ящика&amp;gt;&amp;gt;"/>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="-1pt"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="Для тестирования методом BB"/>
            </braces>
          </command>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="9-bf"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\specialsymbol">
            <braces>
              <text value="~---"/>
            </braces>
          </command>
          <text value="это записи (&amp;lt;&amp;lt;журналы&amp;gt;&amp;gt;, &amp;lt;&amp;lt;лог-файлы&amp;gt;&amp;gt;) различных активностей при выполнении программы на целевой платформе на некоторых тестовых входах, на которых значения вычисляемых функций должны играть роль эталонных значений при обнаружении ошибок рассматриваемым тестом."/>
          <text value="Однако при этом часто возникают указанные выше трудности, связанные с отсутствием информации об истинных эталонных выходных значениях и их связи с конкретным операционным профилем, который может меняться в зависимости от модификации операционной среды или от специфики работы рассматриваемой программы в составе конкретной сервис-ориентированной архитектуры. Возможным выходом из этой ситуации считают использование исполняемой версии приложения с аналогичной функциональностью, часть результатов которой можно принять за эталонные для новой ГИПП"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="2-bf, 11-bf"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=". Это соответствует ситуации, когда существуют прежние версии новой ГИПП или приложения, которые можно рассматривать как подобные рассматриваемой новой ГИПП (с точки зрения результатов вычислений). Часто, однако, такие версии не доступны приобретателю ГИПП."/>
            </braces>
          </command>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="-3pt"/>
              </braces>
            </braces>
            <braces/>
          </command>
        </subsection>
        <subsection>
          <text value="Инжекция возможных программных ошибок и системных сбоев"/>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="-1pt"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="Под инжекцией ошибок понимают введение в код программы на том или ином уровне представления (от исходного до исполнимого кода) искажений, которые могут приводить к тем или иным видам некорректного поведения"/>
            </braces>
          </command>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="8-bf"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=". Существует множество типов инжекций, которые могут отражать либо некоторые гипотетические сбои в операционной системе (включая вызванные сбоями в аппаратной части системы), либо списки возможных ошибок в исходном коде программы. Очевидно, что ввиду отсутствия у пользователя ГИПП исходного кода второй способ инжекций интереса не представляет. Реальным приложением инжекций может быть имитация режимов отказа системы, таких как искажение данных операционной среды, повреждение данных, проходящих между вызовами компонент. В"/>
            </braces>
          </command>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="10-bf"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="описана система инжекции ошибок при выполнении программы (runtime binary injection tool)."/>
            </braces>
          </command>
          <text value="Этот инструмент имитирует ошибки в запросах в вызываемых функциях и возвращает значения выполняемых при этом функций. Общий принцип использования таких инструментов основан на предположении, что тесты, обнаруживающие инжектированные ошибки во время выполнения программы, с высокой вероятностью обнаружат также и ошибки в операторах исходного кода"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="11-bf"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=", результатом которых может быть, например, неправильная обработка того или иного системного сбоя. Следовательно, входные данные, определенные с использованием инструмента инжекции как тестовые (т."/>
            </braces>
          </command>
          <text value="е."/>
          <text value="обнаруживающие по результатам выполнения программы возможные ошибки), могут использоваться для тестирования ГИПП в эксплуатационных условиях (например, при проведении регламентных работ). Трудности использования данного подхода связаны прежде всего с высокой стоимостью систем инжекции, а также высокими требованиями к квалификации тестера."/>
          <text value="При этом, разумеется, остается проблема определения правильных выходов выполняемых функций и программы в целом, используемых в качестве эталонов при оценке результатов тестирования на специфических тестах."/>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="-6pt"/>
              </braces>
            </braces>
            <braces/>
          </command>
        </subsection>
      </section>
      <section id="id3">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="О возможности тестирования программ с неизвестной структурой и не полностью специфицированными функциями"/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-2pt"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="Существенной трудностью тестирования ГИПП является отсутствие точных значений выходов программы при конкретных условиях ее выполнения (&amp;lt;&amp;lt;оракулов&amp;gt;&amp;gt;, в терминах современной практики тестирования программ"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="4-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="). Интересно было бы рассмотреть вопрос о принципиальной возможности решения этой проблемы. Представляется, что в качестве теоретической и концептуальной основы тестирования при неполной спецификации программы можно было бы"/>
          </braces>
        </command>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <text value="взять концепцию тестирования случайных самоприводимых функций, применяемую в теории самотестируемых программ. Поскольку самотестируемость означает, что программа сама может определить отличие правильного результата от неправильного, естественно использовать правильное значение как эталон в задаче внешнего (т."/>
        <text value="е."/>
        <text value="с выбором исходных данных самим пользователем программы) тестирования. Функция является случайной самоприводимой на некотором множестве, если ее значение в данной точке может быть эффективно реконструировано из ее оценки в случайных точках"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="5-bf, 13-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="."/>
          </braces>
        </command>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Определение."/>
        </command>
        <text value="Функция"/>
        <formula id="id4" value="$f(x)$"/>
        <text value=", определенная над множеством$D$, называется случайной самоприводимой функцией, если существует функция"/>
        <formula id="id5" value="$\varphi$"/>
        <text value="и множество функций"/>
        <formula id="id6" value="$\sigma_1, \ldots , &#10;\sigma_n$"/>
        <text value="таких, что"/>
        <formula id="id7" value="Token(TokenType.FORMULA&amp;quot;, &amp;quot;\begin{equation}&#10;    f(x)=\varphi\left(x, r, f\left( \sigma_1\left(x,r\right)\right),\ldots , &#10;f\left(\sigma_k\left( x,r\right)\right)\right)\,,&#10;    \label{e1-bs}&#10;    \end{equation}&amp;quot;, line=319, col=21)"/>
        <text value="где случайные переменные"/>
        <formula id="id8" value="$r\hm=\{r_1, \ldots , r_m\}$"/>
        <text value="имеют известные распределения, а функция"/>
        <formula id="id9" value="$\varphi$"/>
        <text value="и множество функций"/>
        <formula id="id10" value="$\sigma_1,\ldots , &#10;\sigma_k$"/>
        <text value="могут быть вычислены за полиномиальное время. Иными словами, если для функции"/>
        <formula id="id11" value="$f(x)$"/>
        <text value="оценку ее значения на любом входе$x$можно свести за полиномиальное время к оценке ее значения на одном или более случайных экземплярах входных переменных, то такая функция является самоприводимой. По сути, можно говорить о"/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="восстановлении"/>
        </command>
        <text value="значения функции"/>
        <formula id="id12" value="$f(x)$"/>
        <text value="по случайно выбранным входным переменным"/>
        <formula id="id13" value="$\{r\}$"/>
        <text value=", так как это свойство позволяет восстановить значение функции, используя конечное число элементов, взятых из ее области определения, без каких-либо знаний о реализации программы, которая выполняет вычисление. Например, пусть программа$A$должна вычислять линейную функцию"/>
        <formula id="id14" value="$f(x) \hm= wx$"/>
        <text value=", где$w$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="любое действительное число (кроме 0), и вычислениям функций"/>
        <formula id="id15" value="$\sigma_1,\ldots ,\sigma_4$"/>
        <text value="соответствуют вызовы программы:"/>
        <formula id="id16" value="$A\left(w-r_1, x-r_2\right)$"/>
        <text value=","/>
        <formula id="id17" value="$A\left(w-r_1, r_2\right)$"/>
        <text value=","/>
        <formula id="id18" value="$A\left(r_1, x-r_2\right)$"/>
        <text value="и"/>
        <formula id="id19" value="$A\left(r_1, &#10;r_2\right)$"/>
        <text value=", где$r_1$и$r_2$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="равномерно распределенные в области задания переменных$w$и$x$случайные величины. Если программа правильно вычисляет функцию с указанными аргументами, то из приведенного ниже очевидного тождества следует:"/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-5pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\begin">
          <braces>
            <text value="y_c = A"/>
          </braces>
        </command>
        <command value="\left">
          <braces>
            <text value="(w-r_1, x-r_2"/>
          </braces>
        </command>
        <command value="\right">
          <braces>
            <text value=") + A"/>
          </braces>
        </command>
        <command value="\left">
          <braces>
            <text value="(w-r_1, r_2"/>
          </braces>
        </command>
        <command value="\right">
          <braces>
            <text value=") +"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
            </braces>
          </braces>
        </command>
        <braces>
          <text value="{}"/>
          <text value="+A"/>
          <command value="\left">
            <braces>
              <text value="(r_1, x-r_2"/>
            </braces>
          </command>
          <command value="\right">
            <braces>
              <text value=") + A"/>
            </braces>
          </command>
          <command value="\left">
            <braces>
              <text value="(r_1, r_2"/>
            </braces>
          </command>
          <command value="\right">
            <braces>
              <text value=") ="/>
            </braces>
          </command>
          <command value="\left">
            <braces>
              <text value="(w-r_1"/>
            </braces>
          </command>
          <command value="\right">
            <braces>
              <text value=")"/>
            </braces>
          </command>
          <command value="\left">
            <braces>
              <text value="(x-r_2"/>
            </braces>
          </command>
          <command value="\right">
            <braces>
              <text value=") +"/>
            </braces>
            <braces>
              <braces>
                <text value="{}"/>
              </braces>
            </braces>
          </command>
        </braces>
        <braces>
          <text value="{}"/>
          <text value="+"/>
          <command value="\left">
            <braces>
              <text value="(w-r_1"/>
            </braces>
          </command>
          <command value="\right">
            <braces>
              <text value=")r_2 + r_1"/>
            </braces>
          </command>
          <command value="\left">
            <braces>
              <text value="(x-r_2"/>
            </braces>
          </command>
          <command value="\right">
            <braces>
              <text value=") + r_1r_2 = wx"/>
            </braces>
          </command>
        </braces>
        <text value=","/>
        <command value="\label">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="e2-bf"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="multline"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="что демонстрирует выполнение условий определения RSR при любых случайных$r_1$и$r_2$. В данном примере функции"/>
          </braces>
        </command>
        <formula id="id20" value="$\varphi$"/>
        <text value="в (1) соответствует сумма функций"/>
        <formula id="id21" value="$\sigma_1, \ldots, \sigma_4$"/>
        <text value="с соответствующими аргументами. Если каждый вызов программы выполняется с небольшой вероятностью ошибки"/>
        <formula id="id22" value="$\leq\alpha$"/>
        <text value="(скажем, 0,01), где"/>
        <formula id="id23" value="$\alpha$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="это доля входных наборов, на которых возможны ошибки вычисления (гарантированные, например, разработчиком программы), то вероятность ошибки вычисления суммы будет"/>
        <formula id="id24" value="$\leq 4\alpha$"/>
        <text value="и, соответственно, большинство значений$y_c$при достаточном большом числе случайно выбранных$r_1$и$r_2$будут равны истинному значению$wx$, что означает возможность определения правильного значения выхода программы (эталона) как значения, которое получается на большинстве входных наборов программы, вычисляющей данную функцию. Таким образом, для реализации данного подхода необходимо выбрать статистически обоснованное число пар"/>
        <formula id="id25" value="$r_1, r_2$"/>
        <text value=", чтобы обеспечить требуемую вероятность правильного вычисления с достаточным уровнем доверия (величиной доверительного интервала"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="13-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=")."/>
          </braces>
        </command>
        <text value="Для этого, предполагая, что последовательность правильных результатов образует последовательность Бернулли (поскольку случайные переменные$r_1$и$r_2$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="независимые, равномерно распределенные числа), получим вероятность того, что значение функции, получаемое на большинстве из$n$входных наборов переменных (т."/>
        <text value="е."/>
        <formula id="id26" value="$\geq [n/2]\hm+1$"/>
        <text value="), есть точное значение функции:"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <formula id="id27" value="Token(TokenType.FORMULA&amp;quot;, &amp;quot;\begin{equation}&#10;    \mathrm{Pr} \left( k\geq L+1\right)=1-\sum\limits^L_{k=0} C_n^k p^k &#10;q^{n-k}\,,&#10;    \label{e3-bf}&#10;    \end{equation}&amp;quot;, line=393, col=21)"/>
        <text value="где"/>
        <formula id="id28" value="$p&amp;gt;1/2$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="вероятность успеха (правильного вычисления функции,"/>
        <formula id="id29" value="$1\hm- 4\alpha$"/>
        <text value="в рассматриваемом примере);"/>
        <formula id="id30" value="$q\hm= 1 \hm- p$"/>
        <text value=";$k$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="число правильных ответов в данной последовательности$n$испытаний,"/>
        <formula id="id31" value="$L\hm= \lfloor n/2\rfloor\hm+1$"/>
        <text value=". Границы этой вероятности определяются различными формами неравенства Чернова (Chernoff inequality), например:"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <formula id="id32" value="Token(TokenType.FORMULA&amp;quot;, &amp;quot;\begin{equation}&#10;    \mathrm{Pr}\left( k&amp;gt;\fr{n}{2}\right) \geq 1-\exp \left( -2n\left( p-&#10;\fr{1}{2}\right)^2\right)\,,&#10;    \label{e4-bf}&#10;    \end{equation}&amp;quot;, line=407, col=21)"/>
        <text value="где$k$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="число успешных исходов в$n$испытаниях Бернулли. Очевидно, что с ростом числа испытаний$n$растет вероятность того, что большинство (больше половины всех исходов) будут успешными (т."/>
        <text value="е."/>
        <text value="функция будет вычислена правильно). Задавая требуемый статистический уровень доверия"/>
        <formula id="id33" value="$1\hm-&#10;\beta$"/>
        <text value=""/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="13-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="(например, 0,99, что означает, что вероятность"/>
          </braces>
        </command>
        <formula id="id34" value="$\mathrm{Pr}\,(k\hm&amp;gt; &#10;n/2)$"/>
        <text value="на конечной выборке испытаний длиной$n$в рассматриваемом примере будет оценена с вероятностью ошибки не более 0,01), получают число испытаний Бернулли (т."/>
        <text value="е."/>
        <text value="число тестовых прогонов для вычисления функции), необходимых для определения вероятности большинства правильных ответов при данном уровне"/>
        <formula id="id35" value="$\beta$"/>
        <text value=""/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="12-bf, 19-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=":"/>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <formula id="id36" value="Token(TokenType.FORMULA&amp;quot;, &amp;quot;\begin{equation}&#10;    n\geq  \fr{\ln(1/\beta)}{(p-1/2)^2}\,.&#10;    \label{e5-bf}&#10;    \end{equation}&amp;quot;, line=427, col=21)"/>
        <text value="Иными словами,$n$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="это число случайных наборов, которые дают достаточную вероятность того, что большая часть результатов вычислений тестируемой функции"/>
        <formula id="id37" value="$f(x)$"/>
        <text value="будет правильной и можно определить этот результат просто по большинству ответов при данной вероятности"/>
        <formula id="id38" value="$\alpha$"/>
        <text value="ошибки выполнения программы$A$. Формула ("/>
        <command value="\ref">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="e5-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=") применима для оценки необходимого числа запусков программы, вычисляющей любые функции, представимые как (1). В настоящее время доказано"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="14-bf, 15-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", что значительный класс вычислительных задач может быть представлен как вычисление функций со свойствами RSR. Сюда, например, относятся:"/>
          </braces>
        </command>
        <itemize/>
        <text value="Оставляя вопрос об автоматизированном построении функций"/>
        <formula id="id39" value="$\varphi$"/>
        <text value="и"/>
        <formula id="id40" value="$\sigma_i$"/>
        <text value="("/>
        <formula id="id41" value="$i\hm= 1, \ldots, k$"/>
        <text value=") в формуле (1), отметим, что в настоящее время в литературе приведены различные примеры"/>
        <formula id="id42" value="$\varphi$"/>
        <text value="и"/>
        <formula id="id43" value="$\{\sigma_1, &#10;\ldots , \sigma_k\}$"/>
        <text value="для всех перечисленных выше RSR-функций, т."/>
        <text value="е."/>
        <text value="с практической точки зрения можно говорить о возможности использования &amp;lt;&amp;lt;библиотеки&amp;gt;&amp;gt; таких функций"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="6-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Например, в"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="14-bf"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="доказана следующая"/>
          </braces>
        </command>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Теорема."/>
        </command>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="Для каждого набора"/>
        </command>
        <formula id="id44" value="$\{a_1, \ldots , a_{d+1}\}$"/>
        <text value="попарно различных элементов конечного поля$F$с числом элементов"/>
        <formula id="id45" value="$\vert &#10;F\vert \hm&amp;gt; d\hm+1$"/>
        <text value="существует конечное число чисел"/>
        <formula id="id46" value="$\{c_1, \ldots , &#10;c_{d+1})$, таких что для каждого полинома $P(x)$ степени~$d$, &#10;определенного на~$F$, справедливо}&#10;    \begin{equation*}&#10;    \forall x, r\in F,\ P(x)=\sum\limits_{i=1}^{d+1} c_i P\left( x+a_i r\right)\,.&#10;   % \label{e6-bf}&#10;    \end{equation*}&#10;    &#10;    {В этом случае функции $\sigma_i\hm= x\hm+ a_ir$, где~$r$, как &#10;и~выше,~--- случайное число. Если $(a_1, \ldots, a_{d+1}) \hm= (1, 2, \ldots, &#10;d+1)$, то $c_i\hm= (-1)^{i+1}C^i_{d+1}$, где $C^i_{d+1}$~--- биномиальные &#10;коэффициенты.}&#10;    &#10;    %\smallskip&#10;    &#10;    Существенно, что единственное, что надо знать в~данном случае &#10;о~вычисляемой функции,~--- это то, что она полином степени~$"/>
        <text value="d"/>
        <formula id="id47" value="$.&#10;    &#10;    Учитывая, что большинство непрерывных функций вычисляется через &#10;их полиномиальное представление, можно говорить о широких &#10;возможностях использования RSR в~задачах тестирования.&#10;    &#10;    Заметим, что, поскольку формально вычисления в~любых аппаратных &#10;средах являются при\-ближенными (конечность разрядной сетки про\-цессоров), &#10;в~теории RSR-функ\-ций введено также\linebreak&#10; понятие &amp;lt;&amp;lt;приближенной случайной &#10;самоприводимости&amp;gt;&amp;gt; (approximate-random self-reducible)~\cite{12-bf} для &#10;функции, значение в~некоторой точке~$"/>
        <text value="x"/>
        <formula id="id48" value="$ которой может быть представлено &#10;по формуле~(1) лишь с~некоторой точностью~$"/>
        <command value="\varepsilon"/>
        <formula id="id49" value="$. С~формальной &#10;точки зрения это вполне естественно для вычислений с~фиксированной &#10;и~плавающей точкой.&#10;&#10;    В~\cite{12-bf} приведены примеры выполнения~(1) при вычислении &#10;показательной и~логарифмической функций для $"/>
        <text value="k"/>
        <formula id="id50" value="$-бит\-ных чисел  &#10;с~$"/>
        <text value="l_m"/>
        <formula id="id51" value="$-бит\-ной мантиссой и~$"/>
        <text value="l_"/>
        <braces>
          <text value="{}"/>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="exp"/>
              </braces>
            </braces>
            <braces/>
            <braces/>
          </command>
          <formula id="id52" value="$-бит\-ной экспонентой.&#10;    &#10;    Соответственно, все сказанное выше о~вы\-чис\-ле\-нии значений функций &#10;тестируемыми программами может быть переформулировано в~терминах &#10;вычисления приближенных значений.&#10;    &#10;    Итак, если поставщик ГИПП (функциональное назначение которой &#10;состоит в~вычислении тех или иных функций) гарантирует достаточно &#10;высокую вероятность правильной работы программы, вычисляющей &#10;требуемую функцию, то, организовав вычисление функции &#10;на~$"/>
          <text value="n"/>
          <formula id="id53" value="$~случайных наборах из области определения тестируемой функции, где~$"/>
          <text value="n"/>
          <formula id="id54" value="$ &#10;определяется согласно~(\ref{e5-bf}), с~высокой вероятностью можно &#10;определить неизвестный из спецификации правильный результат вычисления &#10;функции.&#10;    &#10;    Очевидно, что при необходимости многократ\-ного тестирования ГИПП, &#10;например для оценки\linebreak не\-об\-хо\-ди\-мости дальнейшей модификации программы, &#10;или при тестировании в~процессе регла\-мент\-ной проверки оборудования нет &#10;не\-об\-хо\-ди\-мости прогона на указанных случайных наборах, поскольку &#10;достаточно использовать полученные ранее значения выхода программ как &#10;эталонные.&#10;&#10;\vspace*{-9pt}&#10;    &#10;\section{О самотестировании готового к~использованию программного продукта}&#10;&#10;\vspace*{-3pt}&#10;&#10;    Как отмечалось во введении, подход, основанный на теории  &#10;RSR-функ\-ций, был первоначально предложен для задач самотестирования &#10;и~самокоррекции программ. Соответственно, он может быть использован &#10;при решении задач самотестирования и~ГИПП~\cite{12-bf}, поскольку для &#10;самопроверки нужен лишь перебор достаточного числа входных значений &#10;без использования эталонных значений работы программы. Иными словами, &#10;можно использовать известные в~теории и~практике самокоррекции &#10;программ методы выбора правильного решения по большинству результатов &#10;(например, N-version programming). Более того, ввиду роста вероятности &#10;правильного вычисления по мере роста числа~$"/>
          <text value="n"/>
          <formula id="id55" value="$~случайных входных &#10;наборов $"/>
        </braces>
        <text value="r_1,"/>
        <command value="\ldots">
          <braces>
            <text value=", r_k"/>
          </braces>
        </command>
        <formula id="id56" value="$ (формулы~(\ref{e2-bf})--(\ref{e5-bf})), можно &#10;говорить о повышении надежности программы (этот эффект называют &#10;&amp;lt;&amp;lt;усилением&amp;gt;&amp;gt; (amplification)~\cite{16-bf}).&#10;    &#10;    Обычно используют два вида процедур са\-мо\-тес\-ти\-ро\-ва\-ния программ: &#10;следящее и~активное~\cite{4-bf, 17-bf}. При реализации первого вида &#10;самотестирования осуществляется проверка результатов обработки данных &#10;в~процессе эксплуатации. Примерами следящего самотестирования могут &#10;служить подстановка найденных корней в~уравнение и~оценка разности &#10;между левой и~правой частью, проверка правильности сортировки путем &#10;анализа выходного массива, вычисление и~сравнение контрольных\linebreak&#10; сумм &#10;и~т.\,д. Главным недостатком данного вида\linebreak самотестирования ПП является &#10;невозможность хранения эталонных данных работы программы, &#10;необходимых для анализа результатов ее работы и~диагностирования отказов &#10;программы.&#10;    &#10;    При активном самотестировании осуществляется проверка результатов &#10;обработки специальных тестовых наборов входных данных путем сравнения &#10;полученных результатов с~хранимыми в~программе эталонными данными.&#10;    &#10;    Активное самотестирование может быть полезно при оценке работы ПП &#10;с~различной аппаратурой или в~различных операционных средах, при &#10;использовании различных браузеров, при проверке правильности работы &#10;программы после обновления некоторых ее функций. Недостатком данного &#10;вида самотестирования является то, что работа с~ограниченным объемом &#10;фиксированных входных данных тестирования не позволяет оценить полноту &#10;тестирования.&#10;    &#10;    Самотестирование на основе предлагаемого в~статье подхода включает &#10;в~себя ряд достоинств как первого, так и~второго вида самотестирования &#10;и~в~то же время свободно от присущих им недостатков. Прежде всего это &#10;обусловлено отсутствием необходимости заранее вычислять ожидаемые &#10;выходы, и~тем самым исключаются ошибки разработчиков тестов при &#10;подготовке эталонных данных для самотестирования.&#10;&#10;\vspace*{-9pt}&#10;    &#10;\section{Заключение}&#10;&#10;\vspace*{-3pt}&#10;&#10;    Специфика тестирования приобретенных у~производителя ПП&#10;     (ГИПП) широко обсуждается в~современных публикациях по &#10;программному обеспечению (именуемая в~англоязычной литературе как &#10;проблема тестирования ПП Ready to Use Software &#10;Product (RUSP)~\cite{7-bf} или как Commercial off-the-shelf  &#10;(COTS)~\cite{18-bf}).&#10;    &#10;    Одна из основных проблем при этом состоит в~отсутствии достаточно &#10;подробных спецификаций продаваемых программ, что создает трудности &#10;покупателю в~тестировании этих программ, которое он, например, обязан &#10;выполнить перед включением их как компонентов в~более сложные системы с~повышенными требованиями к~надежности (авиационные, медицинские &#10;и~т.\,п.).&#10;    &#10;    В данной статье рассмотрена возможность преодоления проблемы &#10;отсутствия надежных данных о вычисляемых приобретаемыми программами &#10;функциях, используя при этом свойства случайной самоприводимости &#10;значительной части функций и~дополняя тем самым функциональное &#10;тестирование техникой случайного перебора входных наборов, что позволяет &#10;вычислять эталонные значения программ с~высокой достоверностью.&#10;    &#10;    Данный подход может быть использован для значительного числа &#10;вычислительных задач, таких\linebreak&#10; как преобразование Фурье, матричные &#10;вы\-чис\-ления, операции с~полиномами нескольких пе\-ре\-менных, вычисление &#10;различных полиномов над\linebreak&#10; конечными полями, широко используемых при &#10;вычислении хеш-функ\-ций в~задачах поиска и~хранения  &#10;информации~\cite{15-bf} и~функций шифрования, используемых &#10;в~компьютерных сетях для обеспечения кибербезопасности. &#10;%&#10;Существенно, &#10;что свойства случайной самоприводимости обеспечивают так-\linebreak же&#10;самотестирование и~самокоррекцию со\-от\-вет\-ст\-ву\-ющих программ, поскольку &#10;вычисление правильных значений функций (определяемых по\linebreak&#10; большинству &#10;используемых наборов) можно интерпретировать и~как под\-тверж\-де\-ние &#10;появления правильных результатов вычисления (тестирование), и~как &#10;ис\-прав\-ле\-ние (за счет использования &amp;lt;&amp;lt;правила большинства&amp;gt;&amp;gt;). А~если &#10;в~со\-ста\-ве предлагаемой на рынок программы будет преду\-смот\-рен генератор &#10;случайных чисел и~указанный механизм принятия решения, это может &#10;существенно снизить за\-тра\-ты на тес\-ти\-ро\-ва\-ние после приобретения &#10;(например, перед интегрированием в~более слож\-ные сис\-те\-мы) &#10;и,~соответственно, повысить их привлекательность для потенциального &#10;покупателя.&#10;&#10;\vspace*{-8pt}&#10;    &#10;  {\small\frenchspacing&#10; {%\baselineskip=10.8pt&#10; \addcontentsline{toc}{section}{References}&#10; \begin{thebibliography}{99}&#10; &#10; \vspace*{-1pt}&#10; &#10;     \bibitem{1-bf}&#10;     \Au{Басок Б.\,М., Головин~С.\,А., Захаров~В.\,Н., Френкель~С.\,Л.} Тестирование &#10;готового к~использованию про\-грам\-много продукта~// ИТ-Стан\-дарт: Электронный &#10;научный журнал, 2018. №\,1. 7~с.&#10;{\sf  &#10;http://journal.tc22.ru/\linebreak wp-content/uploads/2018/05/testirovanie\_gotovogo\_k\_\linebreak &#10;ispolzovaniyu\_programmnogo\_produkta.pdf}&#10;     \bibitem{2-bf}&#10;     \Au{Липаев В.\,В.} Тестирование компонентов и~комплексов программ.~---  &#10;Москва--Берлин: Директ-Медиа, 2015. 528~с.&#10;     \bibitem{3-bf}&#10;     7~Types of software errors, that every tester should know~// Software Testing Help, 2018. &#10;{\sf www.softwaretestinghelp.\linebreak com/types-of-software-errors}.&#10;&#10;\bibitem{7-bf} %4&#10;     ГОСТ Р ИСО/МЭК 25051-2017. Информационные технологии. Системная &#10;и~программная инженерия. Требования и~оценка качества систем и~программно\-го &#10;обеспечения (SQuaRE). Требования к~качеству готового к~использованию программного &#10;продукта (RUSP) и~инструкции по тестированию.~--- М.: Стандартинформ, 2017. 32~с.&#10;     \bibitem{4-bf} %5&#10;     \Au{Barr E.\,T., Harman~M., McMinn~P., Shahbaz~M., Yoo~S.} The oracle problem in &#10;software testing: A~survey~// IEEE T.~Software Eng., 2015. Vol.~41. No.\,5.  &#10;P.~507--525.&#10;     \bibitem{5-bf} %6&#10;     \Au{Lipton R.} New directions in testing~// &#10;      Distributed computing and cryptography~/&#10;      Eds.\ J.~Feigenbaum, M.\,J.~Merritt.~---&#10;      DIMACS ser. in discrete mathematics and &#10;theoretical computer science.~--- AMS, 1991. &#10;  Vol.~2. P.~191--202.&#10;     \bibitem{6-bf} %7&#10;     \Au{Blum M., Luby M., Rubinfeld~R.} Self-testing/correcting with applications to &#10;numerical problems~// 22nd ACM Symposium on Theory of Computing Proceedings.~--- New &#10;York, NY, USA: ACM Press, 1990. P.~73--83.&#10;     &#10;     \bibitem{8-bf} %8&#10;     \Au{Natella R., Cotroneo D., Duraes~J.\,A., Madeira~H.} On fault representativeness of &#10;software fault injection~// IEEE T.~Software Eng., 2013. Vol.~39. No.\,1. P.~80--96.&#10;     \bibitem{9-bf} %9&#10;     \Au{Canfora G., Di Penta~M.} Testing services and service-centric systems: Challenges &#10;and opportunities~// IT Prof., 2006. Vol.~8. No.\,2. P.~10--17.&#10;&#10;\bibitem{11-bf} %10&#10;     \Au{Buck D., Hollingsworth~J.} An API for runtime code patching~// Int. &#10;J.~High Perform. C., 2000. Vol.~14. No.\,4. P.~317--329.&#10;     \bibitem{10-bf} %11&#10;     \Au{Barrantes E.\,G., Ackley~D.\,H., Forrest~S., Palmer~T.\,S., Stefanovic~D., &#10;Zovi~D.\,D.} Randomized instruction set emulation to disrupt binary code injection attacks~// &#10;10th ACM Conference on Computer and Communications Security Proceedings.~--- New York, &#10;NY, USA: ACM Press, 2003. P.~281--289.&#10;&#10; \bibitem{13-bf} %12&#10;     \Au{Смирнов Н.\,В., Дунин-Барковский~И.\,В.} Курс теории вероятностей &#10;и~математической статистики для технических приложений.~--- Л.: Наука, 1969. 512~с.&#10;     &#10;     \bibitem{12-bf} %13&#10;     \Au{Gemmell P., Lipton R., Rubinfeld~R., Sudan~M., Wigderson~A.}  &#10;Self-testing/correcting for polynomials and for approximate functions~// 23rd ACM Symposium &#10;on the Theory of Computing Proceedings.~--- New York, NY, USA: ACM Press, 1991.  &#10;P.~32--43.&#10;&#10;\bibitem{19-bf} %14&#10;     \Au{Bhattacharyya A., Dey~P.} Sample complexity for winner prediction in elections~// &#10;arXiv.org, 2016. \mbox{arXiv}:\linebreak 1502.04354 [cs.DS]. &#10;    &#10;    &#10;     \bibitem{15-bf} %15&#10;     \Au{Carter L., Wegman~M.} Universal hash functions~// J.~Comput. Syst. Sci., 1979. &#10;Vol.~18. P.~143--154.&#10;&#10; \bibitem{14-bf} %16&#10;     \Au{Nouber G., Nussbauer~H.} Self-correcting polynomial programs~// Reliab. &#10;Comput., 1996. Vol.~2. No.\,2. P.~139--145.&#10;     \bibitem{16-bf} %17&#10;     \Au{Dolev Sh., Frenkel~S.} Extending the scope of self-correcting~// 13th Conference &#10;(International) on Applied Stochastic Models and Data Analysis Proceedings. P.~458--462.&#10;     \bibitem{17-bf} %18&#10;     \Au{Басок Б.\,М., Красовский~В.\,Е.} Тестирование про\-грам\-мно\-го обеспечения.~--- &#10;М.: МИРЭА, 2010. 120~с.&#10;     \bibitem{18-bf} %19&#10;     \Au{Voas J., Charron F., Miller~K.} Robust software interfaces: Can COTS-based &#10;systems be trusted without them?~// 15th Conference (International) on Computer Safety, &#10;Reliability and Security Proceedings.~--- Vienna: Springer Verlag, 1996. P.~126--135.&#10;     &#10; \end{thebibliography}&#10;&#10; }&#10; }&#10;&#10;\end{multicols}&#10;&#10;\vspace*{-3pt}&#10;&#10;\hfill{\small\textit{Поступила в~редакцию 10.06.18}}&#10;&#10;\vspace*{8pt}&#10;&#10;%\pagebreak&#10;&#10;%\newpage&#10;&#10;%\vspace*{-28pt}&#10;&#10;\hrule&#10;&#10;\vspace*{2pt}&#10;&#10;\hrule&#10;&#10;%\vspace*{-2pt}&#10;&#10;\def\tit{USING A PROBABILISTIC CALCULATION MODEL TO~TEST\\ ONE CLASS &#10;OF~READY-TO-USE SOFTWARE COMPONENTS\\ OF~LOCAL AND~NETWORK SYSTEMS}&#10;&#10;\def\titkol{Using a probabilistic calculation model to test one class of &#10;ready-to-use software components of local and network systems}&#10;&#10;\def\aut{B.\,M.~Basok$^1$, V.\,N.~Zakharov$^2$, and~S.\,L.~Frenkel$^3$}&#10;&#10;\def\autkol{B.\,M.~Basok, V.\,N.~Zakharov, and~S.\,L.~Frenkel}&#10;&#10;\titel{\tit}{\aut}{\autkol}{\titkol}&#10;&#10;\vspace*{-11pt}&#10;&#10;&#10;\noindent&#10;$"/>
        <text value="^1"/>
        <formula id="id57" value="$MIREA~--- Russian Technological University, 78~Vernadskogo Ave., Moscow 119454, Russian &#10;Federation&#10;&#10;\noindent&#10;$"/>
        <text value="^2"/>
        <formula id="id58" value="$Federal Research Center ``Computer Science and Control&amp;apos;&amp;apos; of the Russian Academy of Sciences, &#10;44-2~Vavilov\linebreak&#10;$"/>
        <command value="\hphantom">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="^1"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <formula id="id59" value="$Str., Moscow 119333, Russian Federation&#10;&#10;\noindent&#10;$"/>
        <text value="^3"/>
        <formula id="id60" value="$Institute of Informatics Problems, Federal Research Center ``Computer Sciences and Control&amp;apos;&amp;apos; of the &#10;Russian\linebreak&#10;$"/>
        <command value="\hphantom">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="^1"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <formula id="id61" value="$Academy of Sciences, 44-2~Vavilov Str., Moscow 119333, Russian Federation&#10;&#10;&#10;\def\leftfootline{\small{\textbf{\thepage}&#10;\hfill INFORMATIKA I EE PRIMENENIYA~--- INFORMATICS AND&#10;APPLICATIONS\ \ \ 2018\ \ \ volume~12\ \ \ issue\ 4}&#10;}%&#10; \def\rightfootline{\small{INFORMATIKA I EE PRIMENENIYA~---&#10;INFORMATICS AND APPLICATIONS\ \ \ 2018\ \ \ volume~12\ \ \ issue\ 4&#10;\hfill \textbf{\thepage}}}&#10;&#10;\vspace*{6pt}&#10;    &#10;    &#10;&#10;&#10;\Abste{The paper discusses and analyzes the possibility of &#10;providing effective testing of ready-to-use software products that solve &#10;the task of calculating functions, in the absence of complete information &#10;necessary for traditional testing. Efficiency means the possibility of &#10;providing an arbitrarily high probability of detecting possible computational &#10;errors that were not detected by the output control as the number of &#10;inspections increases. As a~conceptual model of the proposed approach, &#10;the properties of functions with the random self-reducible function  &#10;are used, that is, functions whose calculation on a~particular input set can &#10;be reduced to calculation on several randomly selected input sets.&#10;The rationality of providing self-testability properties in ready-to-use &#10;software is substantiated.}&#10;&#10;\KWE{software testing; self-testing}&#10;    &#10;\DOI{10.14357/19922264180407}&#10;&#10;%\vspace*{-18pt}&#10;&#10;\Ack&#10;\noindent&#10;The work was partly supported by&#10;the Russian Foundation for Basic Research (projects 18-07-00669 and 18-29-03100).&#10;&#10;&#10;&#10;%\vspace*{-3pt}&#10;&#10;  \begin{multicols}{2}&#10;&#10;\renewcommand{\bibname}{\protect\rmfamily References}&#10;%\renewcommand{\bibname}{\large\protect\rm References}&#10;&#10;{\small\frenchspacing&#10; {%\baselineskip=10.8pt&#10; \addcontentsline{toc}{section}{References}&#10; \begin{thebibliography}{99}&#10; &#10;&#10;&#10;\bibitem{1-bf-1}&#10;\Aue{Basok, B.\,M., S.\,A.~Golovin, V.\,N.~Zakharov, and S.\,L.~Frenkel.} 2018. &#10;Testirovanie gotovogo k ispol&amp;apos;zovaniyu programmnogo produkta [Testing of &#10;ready-to-use software product]. \textit{It-standart: Elektronnyy nauchnyy zh.} &#10; [IT-Standart: Electronic Scientific~J.]  1. 7~p. Available at: {\sf  &#10;http://journal.tc22.ru/wp-content/uploads/2018/05/\linebreak &#10;testirovanie\_gotovogo\_k\_ispolzovaniyu\_programmnogo\_\linebreak produkta.pdf} (accessed &#10;October~30, 2018).&#10;\bibitem{2-bf-1}&#10;\Aue{Lipaev, V.\,V.} 2015. \textit{Testirovanie komponentov i~kompleksov program} &#10;[Testing of components and software packages].  Moscow--Berlin: Direkt-Media. &#10;528~p.&#10;\bibitem{3-bf-1}&#10;\Aue{7~Types of software errors, that every tester should know}. \textit{Software &#10;Testing Help}. Available at: {\sf  &#10;www.\linebreak softwaretestinghelp.com/types-of-software-errors} (accessed October~30, &#10;2018).&#10;&#10;\bibitem{7-bf-1} %4&#10;GOST R~ISO/MEK 25051-2017. Informatsionnyye tekhnologii. Sistemnaya &#10;i~programmnaya inzheneriya. Trebovaniya i~otsenka kachestva sistem &#10;i~programmnogo obespecheniya (SQuaRE). Trebovaniya k~kachestvu gotovogo &#10;k~ispol&amp;apos;zovaniyu programmnogo produkta (RUSP) i~instruktsii po testirovaniyu &#10;[Information technology. System and software engineering. Requirements and &#10;quality assessment of systems and software (SQuaRE). Requirements for the &#10;quality of ready-to-use software product (RUSP) and instructions for testing]. &#10;Moscow: Standardinform Publs. 32~p.&#10;&#10;\bibitem{4-bf-1} %5&#10;\Aue{Barr, E.\,T., M.~Harman, P.~McMinn, M.~Shahbaz, and S.~Yoo.} 2015. &#10;The oracle problem in software testing: A~survey. \textit{IEEE T.~Software Eng.} &#10;41(5):507--525. &#10;\bibitem{5-bf-1} %6&#10;\Aue{Lipton, R.} 1991. New directions in testing.  \textit{Distributed &#10;computing and cryptography}. Eds.\ J.~Feigenbaum and M.\,J.~Merritt.&#10;DIMACS ser. in &#10;discrete mathematics and theoretical computer science.  AMS. 2:191--202.&#10;\bibitem{6-bf-1} %7&#10;\Aue{Blum, M., M.~Luby, and R.~Rubinfeld.} 1990. Self-testing/correcting with &#10;applications to numerical problems. \textit{22nd ACM Symposium on Theory of &#10;Computing Proceedings}. New York, NY: ACM Press. 73--83.&#10;&#10;\columnbreak&#10;&#10;\bibitem{8-bf-1}&#10;\Aue{Natella, R., D.~Cotroneo, J.\,A.~Duraes, and H.~Madeira.} 2013. On fault &#10;representativeness of software fault injection. \textit{IEEE T.~Software Eng.} &#10;39(1):80--96.&#10;\bibitem{9-bf-1}&#10;\Aue{Canfora, G. and V.~Di~Penta.} 2006. Testing services and servi ce-centric &#10;systems: Challenges and opportunities. \textit{IT Prof.} 8(2):10--17.&#10;&#10;\bibitem{11-bf-1} %10&#10;\Aue{Buck, D., and J.~Hollingsworth.} 2000.  An API for runtime code patching.   &#10;\textit{Int. J.~High Perform. C.} 14(4):317--329.&#10;&#10;\bibitem{10-bf-1} %11&#10;\Aue{Barrantes, E.\,G., D.\,Y.~Ackley, T.\,S.~Palmer, D.~Stefanovic, and &#10;D.~Zovi.} 2003. Randomized instruction set emulation to disrupt binary code &#10;injection attacks. \textit{10th ACM Conference on Computer and Communications &#10;Security Proceedings.} New York, NY: ACM Press. 281--289.&#10;&#10;\bibitem{13-bf-1} %12&#10;\Aue{Smirnov, N.\,V., and I.\,V.~Dunin-Barkovskiy.} 1969. \textit{Kurs teorii &#10;veroyatnostey i~matematicheskoy statistiki dlya tekhnicheskikh prilozheniy} &#10;[Course in the probabilities theory and mathematical statistics for technical &#10;applications]. Leningrad: Nauka. 512~p.&#10;\bibitem{12-bf-1} %13&#10;\Aue{Gemmell, P., R.~Lipton, R.~Rubinfeld, M.~Sudan, and A.~Wigderson.} &#10;1991. Self-testing/correcting for polynomials and for approximate functions. &#10;\textit{23rd ACM Symposium on the Theory of Computing Proceedings}. New &#10;York, NY: ACM Press. 32--43.&#10;\bibitem{19-bf-1} %14&#10;\Aue{Bhattacharyya, A., and P.~Dey.} 2016. Sample complexity for winner &#10;prediction in elections. \mbox{\textit{arXiv.org}}.  arXiv:\linebreak 1502.04354 [cs.DS].&#10;&#10;&#10;\bibitem{15-bf-1}&#10;\Aue{Carter, L., and M.~Wegman.} 1979. Universal hash functions. &#10;\textit{J.~Comput. Syst. Sci.} 18:143--154.&#10;&#10;\bibitem{14-bf-1} %16&#10;\Aue{Nouber, G., and H.~Nussbauer.} 1996. Self-correcting polynomial programs. &#10;\textit{Reliab. Comput.} 2(2):139--145.&#10;\bibitem{16-bf-1} %17&#10;\Aue{Dolev, Sh., and S.~Frenkel.} 2009. Extending the scope of self-correcting. &#10;\textit{13th Conference (International) on Applied Stochastic Models and Data &#10;Analysis Proceedings}. 458--462.&#10;\bibitem{17-bf-1} %18&#10;\Aue{Basok, B.\,M., and V.\,E.~Krasovskiy.} 2010. Testirovanie programmnogo &#10;obespecheniya [Software testing].  Moscow: MIREA. 120~p.&#10;\bibitem{18-bf-1} %19&#10;\Aue{Voas J., F.~Charron, and K.~Miller.} 1996.  Robust software interfaces: Can &#10;COTS-based systems be trusted without them? \textit{15th Conference &#10;(International) on Computer Safety, Reliability and Security Proceedings}. Vienna: &#10;Springer Verlag. 126--135.&#10;  &#10;\end{thebibliography}&#10;&#10; }&#10; }&#10;&#10;\end{multicols}&#10;&#10;\vspace*{-6pt}&#10;&#10;\hfill{\small\textit{Received September 20, 2018}}&#10;&#10;%\pagebreak&#10;&#10;\vspace*{-24pt}&#10;      &#10;    &#10;    \Contr&#10;    &#10;\noindent&#10;\textbf{Basok Boris M.} (b.\ 1948)~--- Candidate of Science (PhD) in technology, associate professor, &#10;MIREA~--- Russian Technological University, 78~Vernadskogo Ave., Moscow 119454, Russian Federation; &#10;\mbox{VM\_E@mail.ru} &#10;&#10;%\vspace*{3pt}&#10;&#10;\noindent&#10;\textbf{Zakharov Victor N.} (b.\ 1948)~--- Doctor of Science in technology, associate professor; Scientific &#10;Secretary, Federal Research Center ``Computer Science and Control&amp;apos;&amp;apos; of the Russian Academy of Sciences, &#10;44-2~Vavilov Str., Moscow 119333, Russian Federation; \mbox{vzakharov@ipiran.ru}&#10;&#10;&#10;%\vspace*{3pt}&#10;&#10;\noindent&#10;\textbf{Frenkel Sergey L.} (b.\ 1951)~--- Candidate of Science (PhD) in technology, associate professor, &#10;senior scientist, Institute of Informatics Problems, Federal Research Center ``Computer Sciences and Control&amp;apos;&amp;apos; &#10;of the Russian Academy of Sciences, 44-2~Vavilov Str., Moscow 119333, Russian Federation; &#10;fsergei51@gmail.com &#10;&#10;    &#10;\label{end\stat}&#10;&#10;\renewcommand{\bibname}{\protect\rm Литература}  "/>
      </section>
    </fulltext>
  </paper>
</papers>