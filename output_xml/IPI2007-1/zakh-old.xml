<?xml version="1.0" encoding="utf-8"?>
<papers>
  <paper>
    <metadata>
      <annotation value="\Abst{Рассмотрены проблемы построения отказоустойчивых серверов, возникающие в связи с недетерминированностью поведения приложений. Предложена формальная модель, описывающая поведение приложения, основными объектами которой являются ресурсы и события. Предложены алгоритмы протоколирования работы приложения на резервном узле кластера, а также восстановления и продолжения его работы при отказе основного узла. При этом для клиентов сбой остается незаметным, за исключением некоторого увеличения времени обслуживания.}"/>
      <keywords>
        <braces>
          <text value="\KW{сервер приложений $$ прозрачная отказоустойчивость $$ процесс $$ ресурс $$ событие $$ контрольная точка $$ детерминированность}"/>
        </braces>
      </keywords>
    </metadata>
    <fulltext>
      <literature/>
      <text value="zakh"/>
      <text value="СРЕДСТВА ОБЕСПЕЧЕНИЯ ОТКАЗОУСТОЙЧИВОСТИ ПРИЛОЖЕНИЙ"/>
      <text value="Средства обеспечения отказоустойчивости приложений"/>
      <text value="В."/>
      <text value="Н. Захаров$^1$, В."/>
      <text value="А. Козмидиади$^2$"/>
      <command value="\titel">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\razd">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\tit">
                    <braces/>
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <command value="\aut">
                          <braces/>
                          <braces>
                            <braces>
                              <text value="{}"/>
                              <command value="\titkol">
                                <braces/>
                              </command>
                            </braces>
                          </braces>
                        </command>
                      </braces>
                    </braces>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <command value="\vskip">
        <braces>
          <text value="12pt plus 6pt minus 3pt"/>
        </braces>
      </command>
      <command value="\begin">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="2"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\section*">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="ВВЕДЕНИЕ"/>
          </braces>
        </braces>
        <braces/>
        <braces>
          <text value="Средства вычислительной техники стали использоваться в областях, требующих безотказной работы систем в течение многих лет (24 часа в сутки, 365 дней в году)."/>
        </braces>
      </command>
      <command value="\label">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="st"/>
            <command value="\stat">
              <braces/>
            </command>
          </braces>
        </braces>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[]{}"/>
        </braces>
      </command>
      <text value="$^1$ФГУП Центральный институт авиационного моторостроения им. П.И. Баранова, Москва, Россия"/>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[]{}"/>
        </braces>
      </command>
      <text value="$^2$ФГУП Центральный институт авиационного моторостроения им. П.И. Баранова, Москва, Россия"/>
      <text value="К таким областям относятся, например, центры хранения и обработки данных в сетях (системы резервирования билетов, биллинговые, банковские и т.д.), массированные распределенные вычисления (GRID-вычисления) и другие."/>
      <command value="\thispagestyle">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="headings"/>
          </braces>
        </braces>
        <braces/>
        <braces>
          <text value="Обычно в подобных системах применяются частные решения, ориентированные в основном на обеспечение надежного хранения данных (например, файловые серверы, использующие для хранения RAID-контроллеры) и корректного их состояния при отказах (серверы баз данных с транзакционным выполнением запросов). Однако большинство приложений не гарантируют, что не произойдет потери части данных при отказе системы. Обычно предполагается, что клиентские средства должны повторять запросы после восстановления серверов, для того, чтобы данные не были потеряны, или что можно сделать возврат по времени на некоторое время назад и повторить работу с этого места. Однако далеко не все клиентские средства и условия применения приложений допускают это. Отказоустойчивые системы для критически важных приложений, корректно решающие проблемы восстановления после сбоев, предлагаемые ведущими производителями, как правило, дороги. Кроме того, они включают специфические серверные и клиентские приложения, не совместимые со стандартными приложениями, не обеспечивающими отказоустойчивость. Примером такого подхода к решению проблемы отказоустойчивости хранения данных являются системы NetApp FAS компании Network Appliance, работающие на базе специализированной операционной системы Data ONTAP"/>
        </braces>
        <braces/>
        <braces>
          <text value="1"/>
        </braces>
        <braces/>
        <braces>
          <text value=". Построение отказоустойчивых систем, использующих серверы со стандартными приложениями, в свете вышесказанного, является актуальной проблемой, вызывающей значительный интерес. Рассмотрение методов достижения прозрачной отказоустойчивости таких систем и является предметом статьи."/>
        </braces>
      </command>
      <figure id="id1" value="Token(TokenType.COMMAND&amp;quot;, &amp;quot;\begin{figure*}&#10;\vspace*{1pt}&#10;\begin{center}&#10;\mbox{%&#10;\epsfxsize=1.6in&#10;\epsfxsize=100mm&#10;\epsfbox{BbR-1.eps}&#10;}&#10;\end}&#10;\vspace*{-9pt}&#10;\Caption{Базовый вариант трубы с разными выходными устройствами&#10;(цилиндрическое, расширяющееся и сужающееся сопло)&#10;\label{f1bab}}&#10;\vspace*{-3pt}&#10;\end{figure*}&amp;quot;, line=41, col=16)"/>
      <section id="id2">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="ОСНОВНЫЕ ПОНЯТИЯ И ПОДХОДЫ"/>
        <text value="Под сервером в данной работе понимается вычислительный центр (отдельный компьютер или кластер) в сети, предоставляющий клиентам (пользователям, клиентским компьютерам) определенные услуги, разделяя между ними свои ресурсы. Подобные серверы названы серверами приложений. Широко распространенным примером сервера такого типа является файловый сервер, обеспечивающий удаленный коллективный доступ к файловой системе. Часто используются вычислительные серверы, предоставляющие клиентам возможность выполнять на них свои программы (например, в центрах коллективного пользования). Обычно приложение представляет собой программу или группу программ, работающих в операционной среде, создаваемой операционной системой (в другой терминологии - один или несколько взаимодействующих процессов или потоков (threads)), которые реализуют функциональность сервера. Для построения отказоустойчивых серверов приложений широко используется кластерная технология. Следуя"/>
        <text value="2"/>
        <text value=", кластером, названа разновидность параллельной или распределенной системы, которая:"/>
        <itemize/>
        <text value="Прозрачная отказоустойчивость (Transparent Fault Tolerance, TFT) сервера приложений - это такое его поведение при возникновении аппаратных или программных отказов либо отказов в сети, при котором:"/>
        <itemize/>
        <text value="Клиенты сервера &amp;quot;не замечают&amp;quot; произошедших отказов. Единственным"/>
        <command value="\footnote">
          <braces>
            <text value="\footnote{}"/>
          </braces>
          <text value="допустимым отклонением сервера от нормального поведения с точки зрения клиента является некоторое увеличение времени обслуживания"/>
        </command>
        <text value="(на несколько секунд или десятков секунд). Обычно приложения, работающие на серверах приложений, не ориентированы на прозрачную отказоустойчивость. Они &amp;quot;заботятся&amp;quot; лишь о собственной целостности (например, состояния файловой системы или базы данных). Восстановление работоспособности сервера приводит к разрыву соединений с клиентами и потере их запросов. Это замечают клиенты - запросы следует повторять, на что клиентские приложения далеко не всегда рассчитаны. В данной работе предполагается, что приложения (прикладные программные средства), выполняемые на сервере, являются стандартными, то есть не имеют специальных средств, обеспечивающих отказоустойчивость."/>
        <figure id="id3" value="Token(TokenType.COMMAND&amp;quot;, &amp;quot;\begin{figure*}&#10;\vspace*{1pt}&#10;\begin{center}&#10;\mbox{%&#10;\epsfxsize=1.6in&#10;\epsfxsize=100mm&#10;\epsfbox{BbR-1.eps}&#10;}&#10;\end}&#10;\vspace*{-9pt}&#10;\Caption{Базовый вариант трубы с разными выходными устройствами&#10;(цилиндрическое, расширяющееся и сужающееся сопло)&#10;\label{f1bab}}&#10;\vspace*{-3pt}&#10;\end{figure*}&amp;quot;, line=84, col=16)">
          <text value="Серьезные исследования в области обеспечения отказоустойчивости серверов были развернуты после создания вычислительных серверов, предназначенных для решения задач, требующих больших вычислительных ресурсов. Решение этих задач выполняется на суперкомпьютерах, обеспечивающих массово-параллельные вычисления и представляющих собой кластеры из сотен и тысяч узлов (процессоров). Однако даже на этих &amp;quot;монстрах&amp;quot; решение может требовать десятков или сотен часов, и одиночный сбой, если не предприняты специальные меры, может привести к необходимости начинать работу сначала. Обычно решение вычислительной задачи в таких случаях осуществляется в модели относительно редко взаимодействующих между собой процессов, выполняемых на разных узлах кластера. Эти взаимодействия нужны для координации работы процессов, в частности, для обмена данными и промежуточными результатами. Взаимодействия опираются на специальный протокол, называемый MPI (Message-Passing Interface) и представляющий собой стандарт &amp;quot;de facto&amp;quot;"/>
          <text value="3"/>
          <text value=". Для преодоления последствий сбоя достаточно давно была разработана и широко применяется технология, опирающаяся на механизм контрольных точек (checkpoints)"/>
          <text value="4-6"/>
          <text value=". По этой технологии система должна иметь стабильную память, которая не меняется при отказах. Соответствующие программные средства периодически сохраняют информацию о состоянии процессов приложения в стабильной памяти. Все процессы также имеют доступ к устройству стабильной памяти. В случае отказа или сбоя, записанная в стабильную память информация используется для повторения вычисления с момента, когда была записана эта информация, то есть выполняется откат назад по времени. Данные, сохранение которых позволяет выполнить откат, называются контрольной точкой. В качестве устройства стабильной памяти может использоваться дисковый том, энергонезависимая оперативная память, память другого узла или узлов кластера. В последнем случае узел, которому требуется сохранить информацию, пересылает ее через быстрый канал связи на другой узел. Стабильная память после отказа одного из узлов должна быть доступной узлу, на котором делается повтор. Однако решение, опирающееся только на контрольные точки, не является прозрачным, поскольку не скрывает от клиентов факт отказа системы и требует от них выполнения определенных действий. Так как при работе процессы обмениваются сообщениями, возможны два варианта решения проблемы. Первый - все процессы выполняют записи контрольных точек одновременно, что затруднительно. Второй вариант, при несоблюдении синхронности, - возврат в каждом процессе к такому скоординированному набору контрольных точек, при котором невозможна противоречивая ситуация. Такая ситуация возникает, когда один процесс вернулся к контрольной точке, после которой он должен получить сообщение от другого процесса, а этот другой процесс вернулся к точке, которая следует за выдачей этого сообщения. Однако при повторе ожидаемое первым процессом сообщение не поступит. В этом случае возможен эффект домино, в результате процессы оказываются отброшены как угодно далеко назад. В этом состоит первая проблема, которую необходимо преодолеть. Если нужно, чтобы последствия отказа узла не были видны клиенту, это означает:"/>
          <itemize/>
          <text value="Вторая проблема, которую надо решать, связана с недетерминированностью поведения сервера приложений. Приведем пример. Пусть имеется система продажи билетов на самолеты. Два клиента одновременно обратились к системе с запросом билета на один и тот же рейс. Клиентам безразлично, какие места им зарезервирует система. Система выполняет запросы клиентов параллельно, поэтому в какой-то момент между процессами, обрабатывающими эти запросы, может возникнуть конкуренция за ресурс - в данном случае, скажем, рейс. Один из процессов захватывает ресурс первым, резервирует место и освобождает ресурс. Потом второй процесс проделывает то же самое. Порядок, в котором в этом примере процессы захватили ресурс, зависит от многих факторов и, в конечном счете, случаен. Однако это не мешает правильному функционированию системы, поскольку клиентам важно одно - получить билеты, причем на разные места. Однако отсутствие детерминизма в поведении приложения приводит к тому, что при повторном выполнении могут быть получены другие результаты: например, клиенту уже сообщено, что ему зарезервировано место №5, а при повторе может получиться, что зарезервировано место №6. Система должна устранить это несоответствие и сделать его невидимым для клиента."/>
          <figure id="id4" value="Token(TokenType.COMMAND&amp;quot;, &amp;quot;\begin{figure*}&#10;\vspace*{1pt}&#10;\begin{center}&#10;\mbox{%&#10;\epsfxsize=1.6in&#10;\epsfxsize=100mm&#10;\epsfbox{BbR-1.eps}&#10;}&#10;\end}&#10;\vspace*{-9pt}&#10;\Caption{Базовый вариант трубы с разными выходными устройствами&#10;(цилиндрическое, расширяющееся и сужающееся сопло)&#10;\label{f1bab}}&#10;\vspace*{-3pt}&#10;\end{figure*}&amp;quot;, line=118, col=16)">
            <text value="Недетерминированность поведения системы это следствие, по крайней мере, двух обстоятельств. Во-первых, это присущая системам с разделением времени неопределенность в порядке выполнения процессов. Во-вторых, это конкуренция процессов за общие ресурсы. Перечислим некоторые причины недетерминированного поведения приложений:"/>
            <itemize/>
            <text value="По различным причинам время, которое тратится на выполнение вычислительной задачи с одними и теми же исходными данными, не является константой, то есть повторное выполнение может дать другое время. Процессы используют общие ресурсы, обращение к которым требует организации очередности выполнения (сериализации) - первым пришел, первым захватил. И, наконец, результат работы процесса может зависеть от состояния ресурса, а это состояние может изменить другой процесс, ранее захвативший ресурс. Все это создает значительные трудности при попытках воспроизведения поведения процессов с сохраненной контрольной точки. Прозрачная отказоустойчивость серверов приложений обычно осуществляется переносом приложения на другой узел кластера, идентичный первому по конфигурации аппаратных средств и операционной среды. Это делается методом, называемым snapshot/restore. На основном узле (оригинале) периодически фиксируется состояние приложения на этом узле кластера (так называемый снимок или snapshot). После отказа оригинала на резервном узле (копии) делается восстановление (restore), то есть восстанавливается последнее зафиксированное состояние приложения. Операционная среда при этом приводится в состояние, которое соответствует моменту изготовления снимка. После этого узел-копия продолжает работу с зафиксированного места. Сравнение метода snapshot/restore с другими подходами приведено в"/>
            <text value="7"/>
            <text value=". Ниже рассматриваются информационные технологии, позволяющие решить ряд принципиальных вопросов, связанных с реализацией прозрачной отказоустойчивости серверов приложений. Ими являются:"/>
            <itemize/>
            <figure id="id5" value="Token(TokenType.COMMAND&amp;quot;, &amp;quot;\begin{figure*}&#10;\vspace*{1pt}&#10;\begin{center}&#10;\mbox{%&#10;\epsfxsize=1.6in&#10;\epsfxsize=100mm&#10;\epsfbox{BbR-1.eps}&#10;}&#10;\end}&#10;\vspace*{-9pt}&#10;\Caption{Базовый вариант трубы с разными выходными устройствами&#10;(цилиндрическое, расширяющееся и сужающееся сопло)&#10;\label{f1bab}}&#10;\vspace*{-3pt}&#10;\end{figure*}&amp;quot;, line=156, col=16)"/>
          </figure>
        </figure>
      </section>
      <section id="id6">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="МОДЕЛЬ ОПИСАНИЯ ПОВЕДЕНИЯ ПРИЛОЖЕНИЯ"/>
        <text value="Предлагаемый подход опирается на построение модели вычислений, связанной с использованием понятия времени в многопроцессных приложениях. Впервые подобные проблемы были изучены в классической работе Л. Лампорта"/>
        <text value="8"/>
        <text value=". Многопроцессными приложения называются потому, что в них параллельно работают несколько процессов. Процесс ведет себя детерминированно, пока в предписанном кодом порядке выполняет процессорные инструкции. Конечно, его работа может быть прервана практически в любой момент и процессор передан другому процессу или ядру. Поэтому абсолютное время, которое затрачивает процесс на выполнение определенной работы, не константа, а случайная величина. То же относится к относительному времени, то есть времени, которое процесс занимал процессор, поскольку одни и те же обращения к операционной среде могут вызвать работы разной длительности, а значит потребовать разное время на свое выполнение. Кэшированность инструкций и данных, а также длина хэш-списков влияют на действительное время пребывания в операционной среде. Утрачивает смысл понятие одновременность действий, поскольку нельзя установить, выполнили ли два разных процесса какие-либо действия одновременно или одно из них предшествовало другому. Таким образом, с процессом можно связать только его локальное время, которое линейно упорядочивает события, происходившие в этом процессе. Глобальное время, линейно упорядочивающее действия во всех процессах, отсутствует. Расстояние (в этом качестве используется время) между действиями оказывается случайной величиной. Эти соображения важны, поскольку процессы в интересующих нас приложениях взаимодействуют и используют общие ресурсы. Для взаимодействия они используют средства синхронизации, предоставляемые операционной средой - например, наборы семафоров SVR4 (System V Release 4), POSIX-семафоры, бинарные семафоры и другие примитивы взаимного исключения (POSIX- mutual exclusion locks) и т.д. Подобные средства операционной среды, которые позволяют процессам синхронизировать свою деятельность друг с другом или сериализовать обращения к совместно используемым объектам, будут ниже называться ресурсами. С каждым ресурсом связано свое локальное время, линейно упорядочивающее события в жизни ресурса. Например, в случае двоичных семафоров это создание семафора, а также его захват и освобождение процессом. Заметим, что событие - это не намерение процесса (например, захватить бинарный семафор), а сам факт захвата семафора процессом (т.е. успешное выполнение намерения). От изъявления намерения до его осуществления может многое произойти. Например, семафор, который хочет захватить рассматриваемый процесс, принадлежал другому процессу, потом тот процесс его освободил, но семафор был сначала передан операционной средой третьему процессу, который также на него претендовал, и т.д. Поведение рассматриваемого процесса в это время нас не интересует - он ресурсом еще не овладел, а только его захват определяет его дальнейшее поведение. По причинам, изложенным выше, расстояние между двумя событиями - случайная величина. Однако, события замечательны тем, что они одновременно присутствуют и в локальном времени процесса, и в локальном времени ресурса. Поэтому все, что произошло в истории процесса или/и ресурса до этого события, предшествует ему. Далее будет считаться, что истории и ресурсов и процессов состоят только из событий, причем между двумя последовательными событиями в жизни процесса последний ведет себя детерминированно. Это означает, что на поведении процесса сказывается только его предыдущая история, то есть состояние ресурсов, с которыми он взаимодействовал. Это свойство процессов ниже будет называться локальной детерминированностью. Этим свойством не обладают ресурсы, поскольку - следующее событие в истории ресурса не определяется однозначно по его предыдущей истории. Утверждение, касающееся детерминированного поведения процессов, неявно опирается на предположение, что учтены все ресурсы, которые могут привести к недетерминированности процессов. Таким образом, описанное нами очень неформально время в многопроцессном комплексе представляет собой отношение частичного порядка, введенное на множестве событий. Зная полное состояние комплекса в некоторый момент времени, нельзя однозначно определить, какое событие в истории ресурса наступит следующим. Можно говорить только о вероятности наступления того или иного события. Недетерминированность поведения есть следствие двух обстоятельств. Во-первых, это неопределенность времени, которое тратит процесс на переход от одного события к другому. Во-вторых, конкуренция процессов за общие ресурсы. Выполнение приложения, на множестве событий которого введена частичная упорядоченность, можно описать направленным ациклическим графом выполнения. Вершинами этого графа являются события, с каждым из которых связаны две входящие в него дуги. Одна дуга начинается в событии, которое непосредственно предшествует данному событию в истории процесса, другая - в истории ресурса. Построение средств обеспечения прозрачной отказоустойчивости приложений опирается на следующее утверждение: для восстановления работы приложения после отказа достаточно располагать:"/>
        <itemize/>
        <figure id="id7" value="Token(TokenType.COMMAND&amp;quot;, &amp;quot;\begin{figure*}&#10;\vspace*{1pt}&#10;\begin{center}&#10;\mbox{%&#10;\epsfxsize=1.6in&#10;\epsfxsize=100mm&#10;\epsfbox{BbR-1.eps}&#10;}&#10;\end}&#10;\vspace*{-9pt}&#10;\Caption{Базовый вариант трубы с разными выходными устройствами&#10;(цилиндрическое, расширяющееся и сужающееся сопло)&#10;\label{f1bab}}&#10;\vspace*{-3pt}&#10;\end{figure*}&amp;quot;, line=195, col=16)">
          <text value="Вся эта информация должна находиться в стабильной памяти, не разрушающейся при отказе. Ниже неформально описан алгоритм восстановления работы приложения после отказа, который опирается на наличие контрольной точки и графа выполнения. Будем считать, что в распоряжении имеются средства, позволяющие остановить процесс в тот момент, когда он намерен совершить некоторую операцию над ресурсом. Заметим, что событие в графе выполнения соответствует не изъявлению намерения, а его удовлетворению, то есть завершению выполнения операции. Предварительно сделаем следующее:"/>
          <itemize/>
          <text value="Пусть некоторый процесс проявляет намерение выполнить операцию над каким-либо ресурсом. Отыщем для этого процесса в его истории последнее наступившее событие. Следующее в его истории событие - это то, которое соответствует требуемой операции. Посмотрим, наступило ли событие в истории ресурса, которое ему предшествует. Если нет, переведем процесс в состояния ожидания, отметив в предшествующем событии, что данный процесс ожидает его наступления. Если да, разрешим процессу выполняться, то есть выполнить операцию над ресурсом. Пусть некоторый процесс объявляет, что он выполнил операцию над каким-либо ресурсом (это соответствует моменту протоколирования при оригинальном выполнении). Отыщем для этого процесса в его истории последнее наступившее событие и перейдем к следующему событию в его истории. Это опять то событие, которое мы рассматриваем. Отметим его как &amp;quot;наступившее&amp;quot;. Если наступления этого события ожидал какой-нибудь процесс, выведем этот процесс из состояния ожидания. Наконец, разрешим процессу, выполнившему операцию, продолжаться дальше. Когда выясняется, что наступили все события графа выполнения, повторное выполнение считается законченным. Естественным следствием из сказанного является следующее утверждение: для того, чтобы размер протокола не рос неограниченно, нужно периодически создавать контрольные точки, очищая при этом протокол."/>
        </figure>
      </section>
      <section id="id8">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="ФОРМАЛЬНОЕ ОПИСАНИЕ МОДЕЛИ ПОВЕДЕНИЯ МНОГОПРОЦЕССНОГО ПРИЛОЖЕНИЯ"/>
        <figure id="id9" value="Token(TokenType.COMMAND&amp;quot;, &amp;quot;\begin{figure*}&#10;\vspace*{1pt}&#10;\begin{center}&#10;\mbox{%&#10;\epsfxsize=1.6in&#10;\epsfxsize=100mm&#10;\epsfbox{BbR-1.eps}&#10;}&#10;\end}&#10;\vspace*{-9pt}&#10;\Caption{Базовый вариант трубы с разными выходными устройствами&#10;(цилиндрическое, расширяющееся и сужающееся сопло)&#10;\label{f1bab}}&#10;\vspace*{-3pt}&#10;\end{figure*}&amp;quot;, line=231, col=16)">
          <text value="Опишем формально поведение приложения, неформальное описание которого было приведено выше. Рассматриваются два типа объектов:"/>
          <itemize/>
          <command value="\end">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="multicols"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\label">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="end"/>
                <command value="\stat">
                  <braces/>
                </command>
              </braces>
            </braces>
          </command>
        </figure>
      </section>
    </fulltext>
  </paper>
</papers>