<?xml version="1.0" encoding="utf-8"?>
<papers>
  <paper>
    <metadata>
      <author value="\index{}"/>
      <author value="\index{}"/>
      <author value="\index{}"/>
      <author value="\index{}"/>
      <author value="\index{}"/>
      <author value="\index{}"/>
      <annotation value="\Abst{коды, исправляющие ошибки). Первая заключается в оптимизации набора бинарных подзадач с учетом качества решающих их алгоритмов. Вторая представляет собой развитие метода нечеткой объектной резолюции, где в качестве кодового описания класса используется мультимножество кодов обучающих объектов. Предложенные модификации позволяют в различных условиях улучшать качество исходного метода, что продемонстрировано с по мощью модельных и прикладных задач.}"/>
      <keywords>
        <braces>
          <text value="\KW{распознавание; многоклассовая задача; ECOC; многоуровневый метод; корректность; алгебраический подход; логический подход; кодовое описание класса}"/>
        </braces>
      </keywords>
    </metadata>
    <fulltext>
      <literature/>
      <text value="dokukin"/>
      <text value="МНОГОУРОВНЕВЫЕ МОДЕЛИ РЕШЕНИЯ МНОГОКЛАССОВЫХ ЗАДАЧ РАСПОЗНАВАНИЯ$^*$"/>
      <text value="Многоуровневые модели решения многоклассовых задач распознавания"/>
      <text value="А."/>
      <text value="A. Докукин$^1$, В."/>
      <text value="В. Рязанов$^2$, О."/>
      <text value="В. Шут$^3$"/>
      <text value="А."/>
      <text value="A. Докукин, В."/>
      <text value="В. Рязанов, О."/>
      <text value="В. Шут"/>
      <command value="\titel">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\tit">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\aut">
                    <braces/>
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <command value="\autkol">
                          <braces/>
                          <braces>
                            <braces>
                              <text value="{}"/>
                              <command value="\titkol">
                                <braces/>
                              </command>
                            </braces>
                          </braces>
                        </command>
                      </braces>
                    </braces>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <text value="Докукин А."/>
      <text value="A."/>
      <text value="Рязанов В."/>
      <text value="В."/>
      <text value="Шут О."/>
      <text value="В."/>
      <text value="Dokukin A."/>
      <text value="A."/>
      <text value="Ryazanov V."/>
      <text value="V."/>
      <text value="Shut O."/>
      <text value="V."/>
      <braces>
        <text value="{}"/>
        <command value="\renewcommand">
          <braces>
            <braces>
              <text value="{}"/>
              <command value="\thefootnote">
                <braces/>
                <braces>
                  <braces>
                    <text value="{}"/>
                    <command value="\fnsymbol">
                      <braces>
                        <braces>
                          <text value="{}"/>
                          <text value="footnote"/>
                        </braces>
                      </braces>
                      <braces/>
                      <braces/>
                    </command>
                  </braces>
                </braces>
              </command>
            </braces>
          </braces>
        </command>
      </braces>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[1]{}"/>
        </braces>
      </command>
      <text value="Работа выполнена при финансовой поддержке РФФИ (проект 15-51-04028) и БРФФИ (проект Ф15РМ-037)."/>
      <command value="\renewcommand">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\thefootnote">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\arabic">
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <text value="footnote"/>
                      </braces>
                    </braces>
                    <braces/>
                    <braces/>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[1]{}"/>
        </braces>
      </command>
      <text value="Федеральный исследовательский центр &amp;lt;&amp;lt;Информатика и управление&amp;gt;&amp;gt; Российской академии наук,"/>
      <command value="\mbox">
        <braces>
          <braces>
            <text value="{}"/>
            <affiliation>
              <braces>
                <text value="dalex@ccas.ru"/>
              </braces>
            </affiliation>
          </braces>
        </braces>
        <braces/>
        <braces/>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[2]{}"/>
        </braces>
      </command>
      <text value="Московский физико-технический институт (государственный университет),"/>
      <command value="\mbox">
        <braces>
          <braces>
            <text value="{}"/>
            <affiliation>
              <braces>
                <text value="vasyarv@mail.ru"/>
              </braces>
            </affiliation>
          </braces>
        </braces>
        <braces/>
        <braces/>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[3]{}"/>
        </braces>
      </command>
      <text value="Белорусский государственный университет,"/>
      <command value="\mbox">
        <braces>
          <braces>
            <text value="{}"/>
            <affiliation>
              <braces>
                <text value="olgashut@tut.by"/>
              </braces>
            </affiliation>
          </braces>
        </braces>
        <braces/>
        <braces/>
      </command>
      <command value="\vspace*">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="2pt"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\vskip">
        <braces>
          <text value="10pt plus 9pt minus 6pt"/>
        </braces>
      </command>
      <command value="\thispagestyle">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="headings"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\begin">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="2"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\label">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="st"/>
            <command value="\stat">
              <braces/>
            </command>
          </braces>
        </braces>
      </command>
      <section id="id1">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Введение"/>
        <text value="В настоящей статье рассматривается задача распознавания со многими классами. Будем использовать стандартную постановку задачи из"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="zhur1"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="."/>
          </braces>
        </command>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Определение 1."/>
        </command>
        <text value="Назовем задачей распознавания$Z$следующую задачу. Пусть задана обучающая выборка"/>
        <formula id="id2" value="$\tilde{S}_t(Z)\hm=\{S_1,\ldots,S_m\}$"/>
        <text value=", описанная векторами вещественных признаков,"/>
        <formula id="id3" value="$S_i\hm=(a_{i1}, \ldots, a_{in})$"/>
        <text value=","/>
        <formula id="id4" value="$i\hm=1,\ldots,m$"/>
        <text value=". Выборка разбита на$l$классов"/>
        <formula id="id5" value="$K_1,\dots,K_l$"/>
        <text value=". Классификация объектов обучающей выборки задается информационными векторами"/>
        <formula id="id6" value="${\alpha_i}\hm=(\alpha_{i1}, \ldots, \alpha_{il})$"/>
        <text value=", где"/>
        <formula id="id7" value="$\alpha_{ij}$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="значение предиката &amp;lt;&amp;lt;"/>
        <formula id="id8" value="$S_i\hm\in K_j$"/>
        <text value="&amp;gt;&amp;gt;. Необходимо построить алгоритм$A$, позволяющий вычислить классификацию нового объекта$S$."/>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <text value="Если классы не пересекаются, то классификацию объектов можно задавать одним числом"/>
        <formula id="id9" value="$\alpha_i\hm\in\{1,\ldots,l\}$"/>
        <text value=", и в дальнейшем будет использоваться именно такая нотация. Многоклассовой задачей распознавания будем называть задачу с"/>
        <formula id="id10" value="$l\hm&amp;gt;2$"/>
        <text value=". Особенностью такой постановки является тот факт, что не все эффективные методы распознавания способны непосредственно решать многоклассовые задачи. В отличие от, например, метода ближайших соседей или алгоритма вычисления оценок"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="zhur1, zhur2"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", такие методы, как метод опорных векторов"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="svm"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="или статистически взвешенные синдромы"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="sws"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", приходится применять в несколько этапов. Сначала решается набор дихотомических подзадач, после чего их результаты объединяются и интерпретируются в терминах исходного набора классов. Некоторые из таких многоуровневых подходов достаточно очевидны. Это так называемые &amp;lt;&amp;lt;один против всех&amp;gt;&amp;gt; (one-vs-all)"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="svm"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="и &amp;lt;&amp;lt;каждый с каждым&amp;gt;&amp;gt; (one-vs-one)"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="knerr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Применяются и более общие подходы. Так, в методе ECOC"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="Dietterich"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="используются произвольные разбиения множества классов на пары метаклассов. Каждый класс при этом получает двоичный код, как и каждый распознаваемый объект. Решение о классификации принимается на основании близости кодов. Этот метод был, в свою очередь, обобщен в"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="Allwein"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Отличие заключается в том, что при построении бинарных задач допускается исключение из рассмотрения исходных классов. Таким образом, коды классов становятся троичными. Это важное дополнение позволяет включить схему &amp;lt;&amp;lt;каждый с каждым&amp;gt;&amp;gt; в общий метод. В настоящей работе предпринята попытка предложить свой метод построения набора бинарных подзадач и обосновать его. Первые главы посвяще-"/>
          </braces>
        </command>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-12pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\pagebreak"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="ны теоретическому исследованию вопроса с точки зрения алгебраического и логического подходов к распознаванию. Затем предлагаются прикладные методы и проводится тестирование."/>
      </section>
      <section id="id11">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Корректность многоуровневого алгоритма"/>
        <text value="Вопрос корректности является центральным в алгебраической теории распознавания, созданной академиком Ю."/>
        <text value="И. Журавлевым в 1970-х гг."/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="zhur1, zhur2"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Под корректностью понимается способность алгоритма безошибочно распознать заданную контрольную выборку. Этому вопросу посвящено большое количество теоретических исследований. Так, сам Ю."/>
          </braces>
        </command>
        <text value="И. Журавлев сформулировал теорему существования корректного алгоритма для задачи распознавания в алгебраическом замыкании семейства алгоритмов вычисления оценок (АВО)"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="zhur1,zhur2"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="и оценил его сложность, т."/>
          </braces>
        </command>
        <text value="е."/>
        <text value="степень корректного полинома. Эта оценка постепенно уточнялась его учениками, и в итоге точная оценка была получена А."/>
        <text value="Г. Дьяконовым"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="djakonov"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Таким образом, вопрос корректности в одноуровневых схемах можно считать закрытым, как минимум, для семейства алгоритмов вычисления оценок. Однако представляет интерес корректность многоуровневых схем, рассматриваемых в данной работе. Перейдем к рассмотрению связи корректности алгоритмов на разных уровнях и для начала запишем несколько формальных определений."/>
          </braces>
        </command>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Определение 2."/>
        </command>
        <text value="Пусть задана задача распознавания$Z$и контрольная выборка объектов"/>
        <formula id="id12" value="$\tilde{S}_r(Z)\hm=\{S^1,\ldots,S^q\}$"/>
        <text value="с известной классификацией"/>
        <formula id="id13" value="$\alpha^t\hm\in\{1,\ldots,l\}$"/>
        <text value=", т."/>
        <text value="е."/>
        <text value="выполняется предикат &amp;lt;&amp;lt;"/>
        <formula id="id14" value="$S^t\hm\in K_{\alpha^t}$"/>
        <text value="&amp;gt;&amp;gt;,"/>
        <formula id="id15" value="$t\hm=1,\ldots,q$"/>
        <text value=". Будем называть алгоритм$A$корректным для задачи$Z$и контрольной выборки"/>
        <formula id="id16" value="$\tilde{S}_r(Z)$"/>
        <text value=", если"/>
        <formula id="id17" value="$A(S^t)\hm=\alpha^t$"/>
        <text value="для всех"/>
        <formula id="id18" value="$t\hm=1,\ldots,q$"/>
        <text value=". Здесь"/>
        <formula id="id19" value="$A(S^t)\hm\in\{1,\ldots,l,\Delta\}$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="ответ алгоритма о классификации объекта$S^t$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value=""/>
        <formula id="id20" value="$\Delta$"/>
        <text value="."/>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Определение 3."/>
        </command>
        <text value="Пусть задана задача распознавания$Z$и два непересекающихся подмножества множества классов"/>
        <formula id="id21" value="$K^0\subset\{K_1,\ldots,K_l\}$"/>
        <text value=","/>
        <formula id="id22" value="$K^1\hm\subset\{K_1,\ldots,K_l\}$"/>
        <text value=","/>
        <formula id="id23" value="$K^0\cap K^1\hm=\emptyset$"/>
        <text value=". Назовем бинарной (дихотомической) подзадачей$Z$задачу распознавания"/>
        <formula id="id24" value="$Z^\prime$"/>
        <text value="следующего вида:"/>
        <formula id="id25" value="$\tilde{S}_t(Z^\prime)\hm=\tilde{S}_t(Z)\cap (K^0\cup K^1)$"/>
        <text value=","/>
        <formula id="id26" value="$\tilde{S}_r(Z^\prime)\hm=\tilde{S}_r(Z)\cap (K^0\cup K^1)$"/>
        <text value=", классы соответствуют метаклассам$K^0$и$K^1$. Будем говорить, что класс$K_i$активен в бинарной подзадаче"/>
        <formula id="id27" value="$Z^\prime$"/>
        <text value=", если"/>
        <formula id="id28" value="$K_i\hm\in (K^0\cup K^1)$"/>
        <text value=". Бинарную подзадачу, в которой все классы активны, будем называть полной. Число активных классов будем называть рангом бинарной подзадачи"/>
        <formula id="id29" value="$r(Z_i)$"/>
        <text value="."/>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <text value="Основным условием теоремы существования"/>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <text value="корректного полинома над алгоритмами вычисления оценок"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="zhur1, zhur2"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="является попарная неизоморфность контрольных объектов, т."/>
          </braces>
        </command>
        <text value="е."/>
        <text value="наличие для"/>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <text value="любой пары контрольных объектов такого обучающего, что хотя бы по одному признаку расстояния от этих контрольных до него не равны:"/>
        <formula id="id30" value="$\forall\ S^i,S^j\hm\in\tilde{S}_r(Z)$"/>
        <text value=","/>
        <formula id="id31" value="$\exists\ S_k\in\tilde{S}_t(Z)$"/>
        <text value=","/>
        <formula id="id32" value="$p\hm\in\{1,\ldots,n\}$"/>
        <text value=", такие что"/>
        <formula id="id33" value="$|a_{kp}\hm-a^i_p|\hm\neq|a_{kp}\hm-a^j_p|$"/>
        <text value=". Оно и попарное неравенство классов являются достаточным условием существования корректного алгоритма в алгебраическом замыкании семейства АВО"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="dokukin2001"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". С точки зрения теоремы существования рассматриваемая связь достаточно очевидна. Несложно показать, что выполнение достаточных условий для исходной многоклассовой задачи не гарантирует их выполнения для бинарных подзадач. Подробно этот вопрос и другие доказательства рассмотрены в"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="patrec"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". При этом также достаточно очевидно, что в обратную сторону следствие выполняется. Если набор бинарных подзадач содержит все контрольные объекты и для них выполняются достаточные условия, то для исходной многоклассовой задачи эти условия также выполняются и корректный алгоритм существует. Однако этот факт сам по себе не дает дополнительных конструктивных средств построения такого корректного алгоритма, кроме уже имеющихся в теореме существования. Исходное же предположение состоит в том, что двухуровневая схема позволит упростить такое построение. Поэтому перейдем к рассмотрению методов построения корректного многоклассового алгоритма на базе корректных двухклассовых слагаемых. Рассмотрим следующую общую схему двухуровневого распознавания."/>
          </braces>
        </command>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Определение 4."/>
        </command>
        <text value="Пусть задана задача распознавания$Z$и набор из$W$ее бинарных подзадач"/>
        <formula id="id34" value="$Z_1,\ldots,Z_W$"/>
        <text value=". Назовем алгоритмом первого уровня алгоритмы$A_i$, решающие соответственно подзадачи$Z_i$,"/>
        <formula id="id35" value="$i\hm=1,\ldots,W$"/>
        <text value=". Назовем алгоритмом второго уровня алгоритм$A$, решающий задачу$Z$и использующий для этого выходы алгоритмов первого уровня. При этом будем называть вектор"/>
        <formula id="id36" value="$\gamma(K_i)$"/>
        <text value=", где$$"/>
        <command value="\gamma">
          <braces>
            <text value="(K_i)_j="/>
          </braces>
        </command>
        <command value="\begin">
          <braces>
            <text value="1"/>
          </braces>
        </command>
        <text value=", &amp;amp;"/>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="если"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="K_i"/>
          </braces>
        </command>
        <command value="\in">
          <braces>
            <text value="K^0_j"/>
          </braces>
        </command>
        <text value=";"/>
        <text value="-1"/>
        <text value=", &amp;amp;"/>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="если"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="K_i"/>
          </braces>
        </command>
        <command value="\in">
          <braces>
            <text value="K^1_j"/>
          </braces>
        </command>
        <text value=";"/>
        <text value="0 &amp;amp;"/>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="в остальных случаях"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <text value=","/>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="cases"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="$$кодом класса$K_i$,"/>
          </braces>
        </command>
        <formula id="id37" value="$i\hm=1,\ldots,l$"/>
        <text value=","/>
        <formula id="id38" value="$j\hm=1,\ldots,W$"/>
        <text value=". Рангом класса"/>
        <formula id="id39" value="$r(K_i)$"/>
        <text value="будем называть число бинарных подзадач, в которых он активен, или"/>
        <formula id="id40" value="$|\{\gamma(K_i)_j \,|\, \gamma(K_i)_j\hm\neq0$,&#10;$j\hm=1,\ldots,W\}|$"/>
        <text value=". Аналогично определим код объекта"/>
        <formula id="id41" value="$\gamma(S^t)$"/>
        <text value=":$$"/>
        <command value="\gamma">
          <braces>
            <text value="(S^t)_j="/>
          </braces>
        </command>
        <command value="\begin">
          <braces>
            <text value="1"/>
          </braces>
        </command>
        <text value=", &amp;amp;"/>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="если"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="K_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="A_j(S^t)"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\in">
          <braces>
            <text value="K^0_j"/>
          </braces>
        </command>
        <text value=";"/>
        <text value="-1"/>
        <text value=", &amp;amp;"/>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="если"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="K_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="A_j(S^t)"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\in">
          <braces>
            <text value="K^1_j"/>
          </braces>
        </command>
        <text value=";"/>
        <text value="0"/>
        <text value=", &amp;amp;"/>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="если произошел отказ"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <text value="&amp;amp;"/>
        <command value="\hspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="17mm"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="от распознавания"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <text value=","/>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="cases"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="$$"/>
          </braces>
        </command>
        <formula id="id42" value="$t\hm=1,\ldots,q$"/>
        <text value=","/>
        <formula id="id43" value="$j\hm=1,\ldots,W$"/>
        <text value="."/>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <text value="Рассмотрим многоклассовую задачу распознавания$Z$и набор бинарных подзадач"/>
        <formula id="id44" value="$Z_1,\ldots,Z_W$"/>
        <text value=". Очевидно, если коды классов на данном наборе попарно различаются и бинарные подзадачи полны, то алгоритм, построенный по схеме ECOC, будет корректен. Сложность представляют неполные бинарные подзадачи, поскольку объекты игнорируемых классов будут получать произвольные оценки. При этом если допустить в наборе бинарных подзадач полные, то этот недостаток также легко исправить за счет полных вспомогательных задач. Таким образом, наибольшую сложность представляет случай, когда все бинарные подзадачи неполны. К тому же он представляет и наибольший интерес, поскольку позволяет упростить бинарные подзадачи за счет сокращения количества объектов. Перейдем к его рассмотрению и для определенности будем считать, что ранг всех бинарных подзадач одинаков."/>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Определение 5."/>
        </command>
        <text value="Назовем расстоянием между двумя классами"/>
        <formula id="id45" value="$d(K_i, K_j)$"/>
        <text value="число бинарных подзадач, в которых они оба активны и принадлежат различным метаклассам:"/>
        <command value="\begin">
          <braces>
            <text value="d(K_i, K_j) ="/>
          </braces>
        </command>
        <command value="\left">
          <braces>
            <text value="|"/>
          </braces>
        </command>
        <command value="\left"/>
        <text value="t"/>
        <command value="\in"/>
        <text value="1,"/>
        <command value="\ldots">
          <braces>
            <text value=",W"/>
          </braces>
        </command>
        <text value="|"/>
        <command value="\gamma">
          <braces>
            <text value="(K_i)_t"/>
          </braces>
        </command>
        <command value="\neq"/>
        <command value="\gamma">
          <braces>
            <text value="(K_j)_t,"/>
          </braces>
        </command>
        <command value="\right">
          <braces>
            <text value="."/>
          </braces>
        </command>
        <command value="\right">
          <braces>
            <text value="."/>
          </braces>
        </command>
        <command value="\left">
          <braces>
            <text value="."/>
          </braces>
        </command>
        <command value="\left">
          <braces>
            <text value="."/>
          </braces>
        </command>
        <command value="\gamma">
          <braces>
            <text value="(K_i)_t"/>
          </braces>
        </command>
        <command value="\neq">
          <braces>
            <text value="0,"/>
          </braces>
        </command>
        <command value="\gamma">
          <braces>
            <text value="(K_j)_t"/>
          </braces>
        </command>
        <command value="\neq">
          <braces>
            <text value="0"/>
          </braces>
        </command>
        <command value="\right"/>
        <command value="\right">
          <braces>
            <text value="|"/>
          </braces>
        </command>
        <text value="."/>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="multline*"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="Сформулируем достаточное условие корректности алгоритма второго уровня. Пусть задана задача распознавания$Z$и набор бинарных подзадач"/>
          </braces>
        </command>
        <formula id="id46" value="$Z_1,\ldots,Z_W$"/>
        <text value=", ранг всех бинарных подзадач одинаков и равен"/>
        <formula id="id47" value="$r\hm&amp;lt;l$"/>
        <text value=". Пусть также алгоритмы первого уровня"/>
        <formula id="id48" value="$A_1,\ldots,A_W$"/>
        <text value="являются корректными на соответствующих бинарных подзадачах."/>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Теорема 1."/>
        </command>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="Если для любых двух классов разность их рангов меньше расстояния между ними, т."/>
        </command>
        <text value="е."/>
        <text value="выполнено неравенство"/>
        <text value=":"/>
        <command value="\begin">
          <braces>
            <text value="r(K_j) - r(K_i) &amp;lt; d(K_j,K_i),"/>
          </braces>
        </command>
        <command value="\forall"/>
        <text value="i,j=1,"/>
        <command value="\ldots">
          <braces>
            <text value=",l,"/>
          </braces>
        </command>
        <text value="i"/>
        <command value="\neq">
          <braces>
            <text value="j"/>
          </braces>
        </command>
        <text value=","/>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="equation*"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="то алгоритм второго уровня$A$является корректным"/>
        </command>
        <text value="."/>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <text value="Заметим, что выполнение условия теоремы возможно только при положительном расстоянии между любыми двумя классами. Обратное утверждение выполняется только для случая трех классов. Действительно, есть следующие типы наборов бинарных подзадач, которые не удовлетворяют условию утверждения:"/>
        <formula id="id49" value="$\{\{1\}\mbox{--}\{2\}\}$"/>
        <text value=","/>
        <formula id="id50" value="$\{\{1\}\mbox{--}\{2\}, \{1\}\mbox{--}\{3\}\}$"/>
        <text value="и"/>
        <formula id="id51" value="$\{\{1\}\mbox{--}\{2\}$, $\{1\}\mbox{--}\{2,3\}\}$"/>
        <text value=". Легко убедиться, что во всех случаях алгоритм второго уровня будет некорректным. Для случая четырех классов можно привести контрпример. Возьмем следующие обучающие объекты:"/>
        <formula id="id52" value="$S_1\hm=(-2, 2)\hm\in K_1$"/>
        <text value=","/>
        <formula id="id53" value="$S_2\hm=(2, 2)\hm\in K_2$"/>
        <text value=","/>
        <formula id="id54" value="$S_3\hm=(-2, -2)\hm\in K_3$"/>
        <text value="и"/>
        <formula id="id55" value="$S_4\hm=(2, -2)\hm\in K_4$"/>
        <text value=". Контрольные построим похожим образом:"/>
        <formula id="id56" value="$S^1\hm=(-1, 1)\hm\in K_1$"/>
        <text value=","/>
        <formula id="id57" value="$S^2=(1, 1)\hm\in K_2$"/>
        <text value=","/>
        <formula id="id58" value="$S^3\hm=(-1, -1)\hm\in K_3$"/>
        <text value="и"/>
        <formula id="id59" value="$S^4\hm=(1, -1)\hm\in K_4$"/>
        <text value=". В качестве набора бинарных подзадач возьмем схему &amp;lt;&amp;lt;каждый с каждым&amp;gt;&amp;gt; и исключим пару"/>
        <formula id="id60" value="$\{\{1\}\mbox{--}\{4\}\}$"/>
        <text value=", чтобы нарушить достаточное условие. При этом достаточно несложно построить корректный алгоритм второго уровня. Рассмотрим теперь случай, когда алгоритмы первого уровня некорректны. Если ошибок незначительное количество, то можно модифицировать теорему 1 и потребовать большего расстояния между классами, чтобы их исправить. Кроме того, в достаточном условии фигурирует верхняя оценка голосов за чужие классы, что может позволить получить корректный результирующий алгоритм в реальной ситуации при более равномерном распределении ошибок между классами. Если же ошибок значительное количество, то возникают следующие соображения. Во-первых, теряется смысл использования теоремы 1 и появляется необходимость рассматривать уже не коды классов, а коды отдельных объектов, чтобы делать выводы о корректности. Во-вторых, теряется смысл рассмотрения неполных подзадач. Учитывая эти соображения, рассмотрим предельную, в некотором смысле, ситуацию. Пусть дана задача распознавания$Z$и набор полных бинарных подзадач"/>
        <formula id="id61" value="$Z_1,\ldots,Z_W$"/>
        <text value=". Пусть также дан набор алгоритмов первого уровня"/>
        <formula id="id62" value="$A_1,\ldots,A_W$"/>
        <text value=", решающих эти подзадачи. Для простоты рассмотрим случай, когда эти алгоритмы не дают отказов на объектах задачи$Z$."/>
        <text value="Построим следующую задачу"/>
        <formula id="id63" value="$Z^\prime$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="$W$, при этом все признаки бинарные. Обучающую выборку составляют коды классов. Объектами контрольной выборки являются коды объектов исходной задачи"/>
        <formula id="id64" value="$\tilde{S}_r(Z)$"/>
        <text value=", полученные алгоритмами первого уровня. При этом в рамках одного класса повторяющиеся объекты исключаются. Тогда справедлива следующая теорема."/>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Теорема 2."/>
        </command>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="Пусть в обучающей выборке"/>
        </command>
        <formula id="id65" value="$\tilde{S}_t(Z^\prime)$"/>
        <text value="попарно различны классы, тогда для существования алгоритма"/>
        <formula id="id66" value="$A^\prime$"/>
        <text value=", корректного для задачи"/>
        <formula id="id67" value="$Z^\prime$"/>
        <text value=", необходимо и достаточно попарное различие объектов контрольной выборки"/>
        <text value=""/>
        <formula id="id68" value="$\tilde{S}_r(Z^\prime)$"/>
        <text value="."/>
        <command value="\smallskip">
          <braces>
            <text value="\smallskip"/>
          </braces>
        </command>
        <text value="Таким образом, ошибки в результирующем алгоритме возникают, если невозможно предложить такую бинарную подзадачу, в которой два объекта из разных классов относились бы к разным метаклассам. Объекты, неправильно классифицируемые по этой причине, логично считать выбросами и исключать из рассмотрения. Очевидно, такой подход обладает всеми недостатками теоремы существования. Хотя решение и строится конструктивно, оно громоздко, а получаемый алгоритм склонен к переобучению. Прикладной метод двухуровневого распознавания, основанный на оптимизации набора бинарных подзадач, будет предложен в разд. 4 и испытан на практике."/>
      </section>
      <section id="id69">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Метод резолюций"/>
        <text value="В задачах распознавания образов часто используются два способа представления информации: логический, представляющий собой описание объектов с использованием логических формул или правил, и прецедентный, заключающийся в непосредственном перечислении объектов и классов, которым принадлежат эти объекты. Первый из них"/>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <text value="применяется в продукционных экспертных системах"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="Giarratano"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", второй характерен для большинства задач распознавания с обучением. Для решения"/>
          </braces>
        </command>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="задач"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", информация в которых представлена логическим или прецедентным способом, соответственно используются метод резолюций и многочисленные алгоритмы распознавания, примером которых может служить семейство алгоритмов, описанное в"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="krasn1998"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="например, это задача медицинской диагностики"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="ablam2011"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". В данной работе предлагается использовать аналогичный подход для построения многоуровневых схем распознавания. При этом на первом уровне могут использоваться любые алгоритмы, а объединение их результатов будет производиться в рамках логического подхода. Переформулируем задачу распознавания образов$Z$в общей постановке"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="ablam2011"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="с использованием принятых в логическом подходе обозначений. На множестве объектов$X$произвольной природы заданы подмножества"/>
          </braces>
        </command>
        <formula id="id70" value="$ X_{1},\ldots,X_{l} $"/>
        <text value=", называемые классами. Задана также начальная информация"/>
        <formula id="id71" value="$I_{0}$"/>
        <text value="о классах"/>
        <formula id="id72" value="$X _{1},\ldots,X_{l} $"/>
        <text value=". Требуется указать алгоритм$A$, определенный на всем множестве$X$, вычисляющий на основании информации"/>
        <formula id="id73" value="$I_{0}$"/>
        <text value="для произвольного объекта"/>
        <formula id="id74" value="$ x \hm\in X $"/>
        <text value="результат, который может быть интерпретирован в терминах принадлежности$x$к классам"/>
        <formula id="id75" value="$X _{1},\ldots,X_{l} $"/>
        <text value=". Введем систему предикатов, характеризующую принадлежность произвольного объекта"/>
        <formula id="id76" value="$x \hm\in X $"/>
        <text value="классам"/>
        <formula id="id77" value="$X _{1},\ldots,X_{l} $"/>
        <text value=":$$P_"/>
        <braces>
          <text value="{}"/>
          <text value="i"/>
        </braces>
        <text value="(x)="/>
        <command value="\begin">
          <braces>
            <text value="1"/>
          </braces>
        </command>
        <text value=", &amp;amp;"/>
        <text value="x"/>
        <command value="\in">
          <braces>
            <text value="X_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="i"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <text value=";"/>
        <text value="0"/>
        <text value=", &amp;amp;"/>
        <text value="x"/>
        <command value="\notin">
          <braces>
            <text value="X_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="i"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <text value=","/>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="cases"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\qquad">
          <braces>
            <text value="i=1,"/>
          </braces>
        </command>
        <command value="\ldots">
          <braces>
            <text value=",l"/>
          </braces>
        </command>
        <text value=".$$Информацию"/>
        <formula id="id78" value="$I_{0}$"/>
        <text value="представим в виде:$$I_"/>
        <braces>
          <text value="{}"/>
          <text value="0"/>
        </braces>
        <text value="="/>
        <command value="\left"/>
        <command value="\lbrace">
          <braces>
            <text value="(x,P(x))|x"/>
          </braces>
        </command>
        <command value="\in">
          <braces>
            <text value="X, P(x)=(P_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="1"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="(x),"/>
          </braces>
        </command>
        <command value="\ldots">
          <braces>
            <text value=",P_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="l"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="(x))"/>
          </braces>
        </command>
        <command value="\right"/>
        <command value="\rbrace"/>
        <text value=",$$где"/>
        <formula id="id79" value="$ P(x) $"/>
        <text value="называется информационным вектором, который сопоставляется объектам"/>
        <formula id="id80" value="$x \hm\in X$"/>
        <text value=""/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="zhur1"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Для каждого такого объекта, входящего в описание"/>
          </braces>
        </command>
        <formula id="id81" value="$I_{0}$"/>
        <text value=", информационный вектор считается известным. В распознавании образов множество таких объектов называется выборкой. Обычно ее принято разделять на две части"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="zhur1"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Первая часть называется обучающей выборкой и используется для определения параметров или настройки процесса обучения алгоритмов распознавания. Вторая часть называется контрольной выборкой и используется для оценки качества работы алгоритмов. Обозначим эти части через"/>
          </braces>
        </command>
        <formula id="id82" value="$X^{0}$"/>
        <text value="и"/>
        <formula id="id83" value="$X^{q}$"/>
        <text value="соответственно. К введенным выборкам чаще всего предъявляется требование"/>
        <formula id="id84" value="$X^{0} \cap X^{q}\hm= \emptyset$"/>
        <text value=". Будем говорить, что любой алгоритм$A$, решающий задачу$Z$, строит классификационный вектор"/>
        <formula id="id85" value="$ P^{A}(x)\hm=(P^{A}_{1}(x),\ldots,P^{A}_{l}(x)) $"/>
        <text value=", где"/>
        <formula id="id86" value="$ P^{A}_{i}(x)\hm\in \left\lbrace 0,1\right\rbrace $"/>
        <text value=". Если"/>
        <formula id="id87" value="$ P^{A}_{i}(x)\hm=1 $"/>
        <text value=", то результат алгоритма интерпретируется как"/>
        <formula id="id88" value="$x \hm\in X_{i} $"/>
        <text value="; если"/>
        <formula id="id89" value="$ P^{A}_{i}(x)\hm=0 $"/>
        <text value=", то"/>
        <formula id="id90" value="$x \notin X_{i} $"/>
        <text value=". Для оценки качества работы алгоритма$A$вводится функционал качества"/>
        <formula id="id91" value="$\Phi_{A}(X)$"/>
        <text value=", значения которого легко интерпретировались бы в терминах совпадения или близости"/>
        <formula id="id92" value="$P_{i}(x)$"/>
        <text value="и"/>
        <formula id="id93" value="$P^{A}_{i}(x)$"/>
        <text value=". В общем случае чем ближе значение"/>
        <formula id="id94" value="$\Phi_{A}(X^{q})$"/>
        <text value="к$1$, тем меньше ошибок допускает алгоритм$A$. Поэтому из нескольких алгоритмов предпочтительным считается тот, который имеет наибольшее значение функционала"/>
        <formula id="id95" value="$\Phi_{A}$"/>
        <text value=". В предельном случае, если"/>
        <formula id="id96" value="$\Phi_{A}(X^{q})\hm=1$"/>
        <text value=", то алгоритм$A$решает задачу$Z$безошибочно. Такие алгоритмы называются корректными в алгебраической теории распознавания (см."/>
        <text value="определение 2). Введем следующие определения и обозначения. Пусть"/>
        <formula id="id97" value="$S\hm=\left\lbrace s_{1},\ldots,s_{n} \right\rbrace $"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="множество всех признаков в предметной области задачи$Z$, где"/>
        <formula id="id98" value="$n\hm&amp;lt;\infty $"/>
        <text value=";"/>
        <formula id="id99" value="$D_{j}$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="множество значений признака"/>
        <formula id="id100" value="$s_{j}\hm\in S$"/>
        <text value=". Не нарушая общности, можно считать, что"/>
        <formula id="id101" value="$D_{j}\hm=\left\lbrace 0,1,\ldots,|D_{j}|-1 &#10;\right\rbrace $"/>
        <text value=". Обозначим$$D="/>
        <command value="\left"/>
        <command value="\lbrace">
          <braces>
            <text value="0,1,"/>
          </braces>
        </command>
        <command value="\ldots">
          <braces>
            <text value=","/>
          </braces>
        </command>
        <command value="\max"/>
        <command value="\limits">
          <braces>
            <text value="_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="j"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\left"/>
        <command value="\lbrace">
          <braces>
            <text value="|D_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="j"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="|-1"/>
          </braces>
        </command>
        <command value="\right"/>
        <command value="\rbrace"/>
        <command value="\right"/>
        <command value="\rbrace">
          <braces>
            <text value="="/>
          </braces>
        </command>
        <command value="\left"/>
        <command value="\lbrace">
          <braces>
            <text value="0,1,"/>
          </braces>
        </command>
        <command value="\ldots">
          <braces>
            <text value=",k-1"/>
          </braces>
        </command>
        <command value="\right"/>
        <command value="\rbrace"/>
        <text value=".$$В дальнейшем предполагается, что все признаки принимают значения из множества$D$, где"/>
        <formula id="id102" value="$k\hm\neq 1 $"/>
        <text value=". Объектом назовем отображение"/>
        <command value="\pagebreak"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="$$p"/>
        <command value="\left">
          <braces>
            <text value="(s_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="1"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=","/>
          </braces>
        </command>
        <command value="\ldots">
          <braces>
            <text value=",s_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="n"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\right">
          <braces>
            <text value=")="/>
          </braces>
        </command>
        <command value="\left">
          <braces>
            <text value="(D^"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="p"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="1"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=","/>
          </braces>
        </command>
        <command value="\ldots">
          <braces>
            <text value=",D^"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="p"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="n"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\right">
          <braces>
            <text value=")"/>
          </braces>
        </command>
        <text value=",$$где"/>
        <formula id="id103" value="$D^{p}_{j}\subset D $"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="множество значений признака"/>
        <formula id="id104" value="$s_{j}\hm\in S $"/>
        <text value="объекта$p$, причем"/>
        <formula id="id105" value="$ D^{p}_{j}\hm\neq\emptyset $"/>
        <text value=". Объекты называются равными, если"/>
        <formula id="id106" value="$ \forall\ j\, D^{p}_{j}\hm= D^{q}_{j} $"/>
        <text value=". Если"/>
        <formula id="id107" value="$ D^{p}_{j}\hm=\emptyset$"/>
        <text value=", то считается, что$p$не обладает признаком"/>
        <formula id="id108" value="$s_{j}$"/>
        <text value="и потому не рассматривается в рамках задачи$Z$. В общем случае для произвольного признака существует"/>
        <formula id="id109" value="$ |\rho(D)|\hm=2^{k} $"/>
        <text value="возможных комбинаций его допустимых значений, где"/>
        <formula id="id110" value="$\rho(D)$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="множество всех подмножеств$D$. Поэтому будем считать, что"/>
        <formula id="id111" value="$X\hm=(\rho(D))^{n} $"/>
        <text value=". Для удобства рассуждений назовем множество объектов набором. В"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="patrec"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="показано существование кодировки, использование которой правомерно для описания как нормализованных, так и ненормализованных объектов, откуда следует эквивалентность прецедентного и логического способов представления информации в задаче$Z$. Опишем применение метода резолюций для решения задачи$Z$. Рассмотрим метод резолюций, исходными данными для которого являются не логические формулы, а объекты из$X$. Этот модифицированный метод назовем методом объектных резолюций. Объект$r$называется объектной резольвентой, построенной по объектам$p$и$q$, если значения признаков$r$удовлетворяют следующему условию:$$D_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="j"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="^"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="r"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="="/>
          </braces>
        </command>
        <command value="\begin">
          <braces>
            <text value="D_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="j"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="^"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="p"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\bigcup">
          <braces>
            <text value="D_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="j"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="^"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="q"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <text value=", &amp;amp; j=h"/>
        <text value=";"/>
        <text value="D_"/>
        <braces>
          <text value="{}"/>
          <text value="j"/>
        </braces>
        <text value="^"/>
        <braces>
          <text value="{}"/>
          <text value="p"/>
        </braces>
        <command value="\bigcap">
          <braces>
            <text value="D_"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="j"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="^"/>
          </braces>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="q"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <text value=", &amp;amp; j"/>
        <command value="\neq">
          <braces>
            <text value="h"/>
          </braces>
        </command>
        <text value=","/>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="cases"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="$$где$h$"/>
          </braces>
        </command>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="номер произвольного признака"/>
        <formula id="id112" value="$ s_{h}\hm\in S $"/>
        <text value=". Операцию построения объектной резольвенты обозначим"/>
        <formula id="id113" value="$r\hm=Or_{h}(p,q) $"/>
        <text value=". Также в"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="patrec"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="показана правомерность использования метода объектных резолюций для построения новых объектов на основе информации, заданной прецедентным способом. Рассмотрим алгоритм использования метода объектных резолюций для решения задачи$Z$. Зафиксируем номер$i$класса"/>
          </braces>
        </command>
        <formula id="id114" value="$X_{i}$"/>
        <text value="и определим, принадлежит ли объект$x$этому классу. Пусть"/>
        <formula id="id115" value="$ X_{i}^{0}\hm=X^{0} \bigcap X_{i} $"/>
        <text value=". Алгоритм объектных резолюций"/>
        <formula id="id116" value="$A_{1} $"/>
        <text value=":"/>
        <command value="\begin"/>
      </section>
    </fulltext>
  </paper>
</papers>