<?xml version="1.0" encoding="utf-8"?>
<papers>
  <paper>
    <metadata>
      <annotation value="\Abst{The method and tools to use Algorithmic State Machine (ASM) formalism for high-level specification of complex digital designs and their Model-Checking-based verification are described. This methodology is based on the possibility of hierarchical description of the target digital designs at algorithmic level of abstraction, and ability to generate finite state machines (FSM) models of the systems from the ASM flowcharts. The software tool was developed for automatic generation of SMV (Symbolic Modes Verifier) codes from the ASMs and corresponding FSMs. A way of this approach application to design verification is demonstrated for a pipelined microprocessor.}"/>
      <keywords>
        <braces>
          <text value="\KWE{formal verification; Model Checking; finite state machines}"/>
        </braces>
      </keywords>
    </metadata>
    <fulltext>
      <literature/>
      <command value="\renewcommand">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\figurename">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\protect"/>
                  <command value="\bf">
                    <braces>
                      <text value="Figure"/>
                    </braces>
                    <braces/>
                  </command>
                  <command value="\renewcommand">
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <command value="\tablename">
                          <braces/>
                          <braces>
                            <braces>
                              <text value="{}"/>
                              <command value="\protect"/>
                              <command value="\bf">
                                <braces>
                                  <text value="Table"/>
                                </braces>
                                <braces/>
                              </command>
                              <command value="\renewcommand">
                                <braces>
                                  <braces>
                                    <text value="{}"/>
                                    <command value="\bibname">
                                      <braces/>
                                      <braces>
                                        <braces>
                                          <text value="{}"/>
                                          <command value="\protect"/>
                                          <command value="\rmfamily">
                                            <braces>
                                              <text value="References"/>
                                            </braces>
                                            <braces/>
                                          </command>
                                        </braces>
                                      </braces>
                                    </command>
                                  </braces>
                                </braces>
                              </command>
                            </braces>
                          </braces>
                        </command>
                      </braces>
                    </braces>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <text value="fr"/>
      <text value="SEMIFORMAL VERIFICATION FOR PIPELINED DIGITAL DESIGNS BASED ON ALGORITHMIC STATE MACHINES$^*$"/>
      <text value="Semiformal verification for pipelined digital designs based on Algorithmic State Machines"/>
      <text value="S. Baranov, S. Frenkel, and V. Zakharov"/>
      <text value="S. Baranov$^1$, S. Frenkel$^2$, and V. Zakharov$^3$"/>
      <command value="\titel">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\tit">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\aut">
                    <braces/>
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <command value="\autkol">
                          <braces/>
                          <braces>
                            <braces>
                              <text value="{}"/>
                              <command value="\titkol">
                                <braces/>
                                <braces>
                                  <braces>
                                    <text value="{}"/>
                                    <command value="\renewcommand">
                                      <braces>
                                        <braces>
                                          <text value="{}"/>
                                          <command value="\thefootnote">
                                            <braces/>
                                            <braces>
                                              <braces>
                                                <text value="{}"/>
                                                <command value="\fnsymbol">
                                                  <braces>
                                                    <braces>
                                                      <text value="{}"/>
                                                      <text value="footnote"/>
                                                    </braces>
                                                  </braces>
                                                  <braces/>
                                                  <braces/>
                                                </command>
                                              </braces>
                                            </braces>
                                          </command>
                                        </braces>
                                      </braces>
                                    </command>
                                  </braces>
                                </braces>
                              </command>
                            </braces>
                          </braces>
                        </command>
                      </braces>
                    </braces>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[1]{}"/>
        </braces>
      </command>
      <text value="The research was partially supported by RFBR (project No."/>
      <text value="09-07-12032) and RAS Presidium program ``Fundamental Problems of the System Programming (project 1.1).&amp;apos;&amp;apos;"/>
      <command value="\renewcommand">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\thefootnote">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\arabic">
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <text value="footnote"/>
                      </braces>
                    </braces>
                    <braces/>
                    <braces/>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[1]{}"/>
        </braces>
      </command>
      <text value="Holon Institute of Technology,Holon, Israel, samary@012.net.il"/>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[2]{}"/>
        </braces>
      </command>
      <text value="Institute of Informatics Problems RAS, fsergei@mail.ru"/>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[3]{}"/>
        </braces>
      </command>
      <text value="Institute of Informatics Problems RAS, VZakharov@ipiran.ru"/>
      <command value="\vskip">
        <braces>
          <text value="14pt plus 9pt minus 6pt"/>
        </braces>
      </command>
      <command value="\thispagestyle">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="headings"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\begin">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="2"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\label">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="st"/>
            <command value="\stat">
              <braces/>
            </command>
          </braces>
        </braces>
      </command>
      <section id="id1">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Introduction"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="Standards for safety and security increasingly demand the use of formal development methods and automated verification. To apply the formal methods in a systematic way, the nature of the system has to be taken into account. For example, one of the key optimizations used in hardware systems is pipelining, the idea being that the functionality of a system is partitioned into several stages, which can work in parallel resulting in an increase in the throughput of the pipelined implementation of the system. Existing techniques for verifying of pipelined machines, models that describe the pipelined behavior of hardware systems, effort and resources, paired with the cost of software tools supporting this task lead to an activity that is mostly ad-hoc, labor intensive, and accessible only to a few verification specialists (with PhD degree, usually) within a design team. In the past few decades, much research has been dedicated to improving the quality and the effectiveness of verification algorithms, Model Checking, first of all"/>
        <text value="1"/>
        <text value=". However, much less effort has been devoted to support team activity in the design in order to reduce the efforts mentioned above. In this paper, which is a continuation of the authors&amp;apos; work"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="11fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="a possibility to use ASM"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="4fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="as a semiformal specification of pipelined systems is shown, which can provide essential economy of human resources in the design verification process. This semiformality is based on Model Checking with support by well-known SMV (Symbolic Model Verifier) Cadence tool."/>
          </braces>
        </command>
      </section>
      <section id="id2">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Verification Techniques"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="Key point for designers involved in the activity of design verification is to choose appropriate verification algorithms to verify a design relatively properties, which would guarantee the lack of well-known possible hazards in systems. Finally, these problems are affecting the state space explosion problem. Among the techniques and methodologies available for functional verification, simulation-based verification is prevalent in the industry because of its linear and predictable complexity"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="2fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". The common methodology in this context is"/>
          </braces>
        </command>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="random simulation"/>
        </command>
        <text value=", where stimuli are provided by a constraint-based random generator. Such generators can automatically produce random legal input for the design at a very high rate, based on a set of rules (or constraints) derived from the specification document. In random simulation, bugs are detected by means of assertion statements, or checkers, embedded in the design. However, because of the randomized nature of this methodology, simulations cannot provide guarantees on the worst case behavior of a given system as they try to generalize the behavior of the system from a few observed test cases. Besides, real-life Systems-on-Chip (SoCs) are usually highly nondeterministic; therefore, they cannot be efficiently verified by simulations. To overcome the limitations of simulation, the industry is starting to use formal and semiformal methods"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="1fr, 2fr, 3fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", often in conjunction with simulation-based techniques. Verification approaches based on formal methods essentially provide a mathematical proof of correctness for the system and are therefore very exhaustive. For example, Intel&amp;apos;s used of formal verification on a large-scale was during the Pentium 4 design cycle and consisted of about 60 person years"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="3fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Formal methods were used to verify that the design satisfied various properties describing the expected behavior of the microprocessor and, to date, no bugs have been discovered in the parts of the design that were formally verified. Further, only formal and semiformal approaches will be shortly outlined as a principal topic of this paper."/>
          </braces>
        </command>
        <subsection>
          <text value="Formal verification summary"/>
          <command value="\noindent">
            <braces>
              <text value="\noindent"/>
            </braces>
          </command>
          <text value="Let us consider the most popular formal verification algorithm via Model Checking"/>
          <text value="1"/>
          <text value=". In general, a"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="model checking problem"/>
          </command>
          <text value="is a problem of checking whether a given model, describing a design verified, satisfies a given property:$$M"/>
          <command value="\models"/>
          <command value="\phi">
            <braces>
              <text value="$$which means that a property"/>
            </braces>
          </command>
          <formula id="id3" value="$\phi$"/>
          <text value="is satisfied for the model$M$. The properties are expressed in terms of ``atomic propositions&amp;apos;&amp;apos; (i."/>
          <text value="e., variables in the design), Boolean connectives (AND, OR, NOT, IMPLY, etc.), and so-called ``Temporal operators.&amp;apos;&amp;apos; The model$M$is a"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="finite state transition system"/>
          </command>
          <text value=", and its properties which must be true for an"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="implementation"/>
          </command>
          <text value="of the system at the lower level of the system design (e."/>
          <text value="g., by a"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="structural"/>
          </command>
          <text value="FSM, that is, with binary coding of its inputs, states, outputs"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="1fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=") are expressed in a"/>
            </braces>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="propositional temporal logic"/>
          </command>
          <text value="like"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="Linear temporal logic"/>
          </command>
          <text value="(LTL) and"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="Computational Tree Logic"/>
          </command>
          <text value="(CTL)"/>
          <text value="1"/>
          <text value=". Linear temporal logic is a temporal logic which can describe logical formulae about the future of paths such as that a condition will eventually be true, that a condition will be true until another fact becomes true. Computational tree logic is a branching-time logic, meaning that its model of time is a tree-like structure in which the future is not determined. That is, there are different paths in the future, any one of which might be an actual path."/>
          <command value="\textbf">
            <braces>
              <text value="\textbf{}"/>
            </braces>
            <text value="Temporal Operators:"/>
          </command>
          <itemize/>
          <text value="Temporal connectives according to their character can occur as single symbols such as$X$,$F$,$G$,$U$(linear time temporal logic LTL) or as a pair of symbols where each symbol of$X$,$F$,$G$,$U$must be preceded by path quantifiers an$A$or an$E$(branching time temporal logic CTL), similar to well-known quantifiers of predicate calculus, that is"/>
          <formula id="id4" value="$\forall$"/>
          <text value="(``All quantor&amp;apos;&amp;apos;) and"/>
          <formula id="id5" value="$\exists$"/>
          <text value="(``Existense quantor&amp;apos;&amp;apos;). Quantifier"/>
          <formula id="id6" value="$A\langle$"/>
          <text value="PF"/>
          <formula id="id7" value="$\rangle$"/>
          <text value="means that for all paths leading from the current state, the path formula PF holds. For example,$AXg$means that state formula$g$is true in the next state of all paths leading from the current state. E"/>
          <formula id="id8" value="$\langle$"/>
          <text value="PF"/>
          <formula id="id9" value="$\rangle$"/>
          <text value="means that for some of the paths leading from the current state, the path formula PF holds. For example, EF$g$means that there exists a possible timeline where the formula (``statement&amp;apos;&amp;apos;)$g$will eventually become true. Various temporal operators allow us to relate properties of the current state of a given digital system model with the properties of succeeding states of the model. Both CTL and LTL are interpreted at the states of a"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="transition system, which constitute different paths"/>
          </command>
          <text value="$s0$,"/>
          <command value="\linebreak">
            <braces>
              <text value="\linebreak"/>
            </braces>
          </command>
          <text value="$s1$,"/>
          <command value="\ldots">
            <braces>
              <text value="By this mean, a design is modeled as a state transition graph, called a"/>
            </braces>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="Kripke structure"/>
          </command>
          <text value=""/>
          <text value="1"/>
          <text value=", which is a four-tuple model"/>
          <formula id="id10" value="$K =(S, S_0, R, L)$"/>
          <text value=".$S$is a finite set of states.$S_0$is a set of initial states, where"/>
          <formula id="id11" value="$S_0\in S$"/>
          <text value=","/>
          <formula id="id12" value="$R:\ S\times S$"/>
          <text value="is a transition relation between states, where for every state"/>
          <formula id="id13" value="$s\in S$"/>
          <text value=", there is a state"/>
          <formula id="id14" value="$s&amp;apos;\in S$"/>
          <text value="such that for the state transition"/>
          <formula id="id15" value="$(s, s&amp;apos;)\in R$"/>
          <text value=","/>
          <formula id="id16" value="$L:\ S\subseteq 2^{\mathrm{AP}}$"/>
          <text value="is the labeling function to mark each state with a set of atomic propositions (AP) that hold in that state. It is basically a graph whose nodes represent the reachable states of the system and whose edges represent state transitions. A labeling function is used to assign a set of properties to each state. If the transition system is described as a FSM, as a Mealy automaton$M$, in particular,"/>
          <formula id="id17" value="$M=\langleS, I, O, \delta, \lambda\rangle$"/>
          <text value=", where$S$and$I$are the state space and the input space;$O$is the output space,"/>
          <formula id="id18" value="$\delta$"/>
          <text value="is the state transition function, and"/>
          <formula id="id19" value="$\lambda$"/>
          <text value="is the output function, then the Kripke structure, corresponding to the FSM$M$can be described as following"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="12fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=":"/>
            </braces>
          </command>
          <formula id="id20" value="Token(TokenType.FORMULA&amp;quot;, &amp;quot;\begin{equation}&#10;\left.&#10;\begin{array}{c}&#10; (\langle s, i\rangle,\langle s&amp;apos;, i&amp;apos;\rangle)\in R\  &#10;\mbox{iff}\ \delta (s,i)=s&amp;apos;\,;\\[6pt]&#10; L(\langle s,i\rangle )= S\cup i\cup \lambda (s,i)       &#10;\end}&#10;\right \}&#10;\label{e1fr}&#10;\end{equation}&amp;quot;, line=176, col=17)"/>
          <text value="for any$s$,"/>
          <formula id="id21" value="$s&amp;apos; \in  S$"/>
          <text value="and any$i$,"/>
          <formula id="id22" value="$i&amp;apos;\in  I$"/>
          <text value=". In terms of the structure, the properties of a target system can be expressed as propositional temporal logic that describes sequences of transitions on the computation paths of expected design behavior. For example, the modulo-3 counter in Fig. 1 with input"/>
          <formula id="id23" value="$I =\{\mathrm{rst}\}$"/>
          <text value="(corresponding to"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="reset"/>
          </command>
          <text value="signal with active logical value 1), state space"/>
          <formula id="id24" value="$S=\{S0, S1, S2\}$"/>
          <text value="is translated to the Kripke structure shown in Fig. 2. Here, each transition"/>
          <formula id="id25" value="$\delta(s, i) &#10;\rightarrow s&amp;apos;$"/>
          <text value="in the FSM corresponds to a node"/>
          <formula id="id26" value="$\langles_k, i \rangle$"/>
          <text value=","/>
          <formula id="id27" value="$k=0, 1, 2$"/>
          <text value=";"/>
          <formula id="id28" value="$i \in I$"/>
          <text value="in the Kripke structure one-by-one."/>
          <formula id="id29" value="$\{S00,S10,S20,S01,S11,S21\}$"/>
          <text value="is a list of transitions of the Kripke structure. For example,$S10$in the Kripke structure represents the transition from$S1$to$S2$in the FSM. The structural automaton that is an implementation of this abstract one (see above) can be"/>
          <command value="\linebreak">
            <braces>
              <text value="\linebreak"/>
            </braces>
          </command>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="-12pt"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\pagebreak"/>
          <center/>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="4pt"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <center/>
          <command value="\addtocounter">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="figure"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <braces>
                <text value="{}"/>
                <text value="1"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <center/>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="4pt"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <center/>
          <command value="\bigskip"/>
          <command value="\addtocounter">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="figure"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <braces>
                <text value="{}"/>
                <text value="1"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\noindent">
            <braces>
              <text value="\noindent"/>
            </braces>
          </command>
          <text value="performed by coding of its states by vector of logical values of the counter bits"/>
          <formula id="id30" value="$\{\mathrm{bit}[0], &#10;\mathrm{bit}[1]\}$"/>
          <text value=", initial state"/>
          <formula id="id31" value="$S_0=S0$"/>
          <text value="(with the vector"/>
          <formula id="id32" value="$\{\mathrm{bit}[0]=\mathrm{bit}[1]=0\}$"/>
          <text value=", state transition function"/>
          <formula id="id33" value="$\delta$"/>
          <text value="is represented on the transition diagram in Fig. 1. The variable$cnt$in Fig. 1 is the number of clocks ("/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="step of the FSM transition"/>
          </command>
          <text value="). Correspondingly, there are the following atomic propositions in this case:"/>
          <command value="\begin">
            <braces>
              <text value="&amp;amp;"/>
            </braces>
          </command>
          <text value="p1:("/>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="cnt"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="=0"/>
            </braces>
          </command>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="rst"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="=1)"/>
            </braces>
          </command>
          <command value="\rightarrow">
            <braces>
              <text value="S01"/>
            </braces>
          </command>
          <text value=";"/>
          <text value="&amp;amp;"/>
          <text value="p2: ("/>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="cnt"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="=1"/>
            </braces>
          </command>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="rst"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="=1"/>
            </braces>
          </command>
          <command value="\rightarrow">
            <braces>
              <text value="S11)"/>
            </braces>
          </command>
          <text value=";"/>
          <text value="&amp;amp;"/>
          <text value="p3: ("/>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="cnt"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="=2"/>
            </braces>
          </command>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="rst"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="=1"/>
            </braces>
          </command>
          <command value="\rightarrow">
            <braces>
              <text value="S21)"/>
            </braces>
          </command>
          <text value=";"/>
          <text value="&amp;amp;"/>
          <command value="\mbox">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="etc."/>
              </braces>
            </braces>
            <braces/>
          </command>
          <text value="("/>
          <command value="\mbox">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="total up to$p$6"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=")"/>
            </braces>
          </command>
          <text value="."/>
          <command value="\end">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="align*"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="In fact, the Kripke structure nodes constitute global states of the state space of the design and contain all the propositional atoms, which are true in that particular state. The edges of the graph are oriented global state transitions. Having this structure, desirable properties of the FSM implementation can be described. For example, if CTL is used"/>
            </braces>
          </command>
          <command value="\begin"/>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="AG"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <text value="(("/>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="bit"/>
              </braces>
            </braces>
            <braces/>
            <braces/>
            <braces>
              <text value="0"/>
            </braces>
            <braces/>
            <braces>
              <text value="=0)"/>
            </braces>
          </command>
          <text value="("/>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="bit"/>
              </braces>
            </braces>
            <braces/>
            <braces/>
            <braces>
              <text value="1"/>
            </braces>
            <braces/>
            <braces>
              <text value="=0)"/>
            </braces>
          </command>
          <text value="("/>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="rst"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="=0))"/>
            </braces>
          </command>
          <command value="\supset">
            <braces>
              <braces>
                <text value="{}"/>
              </braces>
            </braces>
          </command>
          <braces>
            <text value="{}"/>
            <command value="\supset"/>
            <command value="\mathrm">
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="AX"/>
                </braces>
              </braces>
              <braces/>
            </command>
          </braces>
          <text value="(("/>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="bit"/>
              </braces>
            </braces>
            <braces/>
            <braces/>
            <braces>
              <text value="0"/>
            </braces>
            <braces/>
            <braces>
              <text value="=1)"/>
            </braces>
          </command>
          <text value="("/>
          <command value="\mathrm">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="bit"/>
              </braces>
            </braces>
            <braces/>
            <braces/>
            <braces>
              <text value="1"/>
            </braces>
            <braces/>
            <braces>
              <text value="=0))"/>
            </braces>
          </command>
          <command value="\end">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="multline*"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="which means that designed correctly counter with the states encoded as above must transit from the state"/>
            </braces>
          </command>
          <formula id="id34" value="$\{\mathrm{bit}[0]=0,\ \mathrm{bit}[1]=0\}$"/>
          <text value="to"/>
          <formula id="id35" value="$\{\mathrm{bit}[0]=1,\ \mathrm{bit}[1]=0\}$"/>
          <text value=", if there is no reset signal. So, the Model-Checking-based formal verification is performed as following: Given a formal model"/>
          <formula id="id36" value="$M = (S, S0, R, L)$"/>
          <text value="of a design and a propositional temporal logic$p$of a property, the model checking problem is to find the set of all states in$S$that satisfy$p$,"/>
          <formula id="id37" value="$\{s \in &#10;S \vert M, s \vert= p\}$"/>
          <text value=". The design satisfies the property if all initial states are in the set. If the property does not hold for the design, error trace from the error state to an initial state is given as a counterexample that helps designers debug the error. To achieve 100 percent confidence of correctness of the design, the specification should include all the properties that the design should satisfy. In general, hardware verification involves comparing two descriptions of a design for ``consistency.&amp;apos;&amp;apos; This requires ($i$) the two descriptions; ($ii$) formal models for each (since these may or may not be the same); ($iii$) a formal notion of the ``consistency&amp;apos;&amp;apos; relation between them; and ("/>
          <formula id="id38" value="$i\nu$"/>
          <text value=") some way of checking or proving the consistency relation. Such a proof does not need necessarily directly resemble a ``traditional&amp;apos;&amp;apos; logic proof (e."/>
          <text value="g., it may simply be a mechanical enumeration of all possibilities)."/>
        </subsection>
        <subsection>
          <text value="Semiformal verification"/>
          <command value="\noindent">
            <braces>
              <text value="\noindent"/>
            </braces>
          </command>
          <text value="Pure formal verification techniques, such as symbolic simulation, bounded model checking (BMC) or reachability analysis"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="1fr, 3fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=", would be ideal to generate verification solutions. Unfortunately, they do not scale well and can only be applied to very small designs. This problem leads to the concept of semiformal verification"/>
            </braces>
          </command>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="3fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=". The idea is to combine the strengths of simulation, namely, ease of use and the ability to handle large designs with the thoroughness of formal verification along with various combinations of formal and simulation-based approaches to verification cost reduction. In fact, there are two possibilities to perform such combination:"/>
            </braces>
          </command>
          <enumerate/>
          <text value="Thus, in very general sense, Model-Checking-based semiformal verification can deal either with formal test examples generation with an informal results analysis, or with formal generation counterexamples using some results of informal simulation"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="8fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=", or in using of a description with well-formalized syntax as an input of simulation. An example of the first approach is BMC"/>
            </braces>
          </command>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="3fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=", which is a semiformal one as it includes a choice of a trajectory length$k$. Note that the lack of precise semantics for modeling notations may lead to incorrect interpretations and misunderstands for models. So, the interpretations of model&amp;apos;s designer may differ from model&amp;apos;s reader. The lack of formal semantics results in the lack of analysis tools that check the consistency of the resulting models and their satisfaction to their properties. Below, it will be shown that using of ASM flowcharts as description is a good point of the semiformal verification as it allows, on one hand, formal description and, on the other hand, a combination of formal model checking and informal simulation."/>
            </braces>
          </command>
        </subsection>
      </section>
      <section id="id39">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Pipelined Microprocessor Model-Checking-Based Verification"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="There are a lot of papers on verifying pipelined processors (systems) with Model-Checking-based formal methods"/>
        <text value="8, 9"/>
        <text value=". Using Model Checking, one achieves an essential amount of automation but one suffers from the state explosion problem when the number of properties checked grows. In general, the properties verified have to meet to the lack of the following hazards:"/>
        <itemize/>
        <text value="It is obvious that plethora of such possible conditions leads to enormous the Model-Checking exploration space. One of the ways which could help by reducing the state space is to use so-called abstractions, refinement technique, and compositions"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="1fr, 3fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". In general, an abstraction is used to build from a model$M$an abstract model"/>
          </braces>
        </command>
        <formula id="id40" value="$M^\prime$"/>
        <text value="such that$$M^"/>
        <command value="\prime">
          <braces>
            <text value="="/>
          </braces>
        </command>
        <command value="\vert"/>
        <command value="\varphi"/>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="implies"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <text value="M ="/>
        <command value="\vert"/>
        <command value="\varphi">
          <braces>
            <text value="$$where"/>
          </braces>
        </command>
        <formula id="id41" value="$\varphi$"/>
        <text value="is an CTL /LTL specification formula. Intuitively speaking, existent abstraction allows partitioning the states of a Kripke structure into some states"/>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-12pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <center/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-6pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <center/>
        <command value="\bigskip"/>
        <command value="\addtocounter">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="figure"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="1"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="agglomerations (or clusters), and treating the clusters as new abstract states. That is, the model"/>
        <formula id="id42" value="$M^\prime$"/>
        <text value="contains states set$S&amp;apos;$which is a surjection$f$:"/>
        <formula id="id43" value="$S\rightarrow  S&amp;apos;$"/>
        <text value=", and$S&amp;apos;$in this case is the set of abstract states"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="1fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". For example, in Fig. 3,"/>
          </braces>
        </command>
        <formula id="id44" value="$S_a=S2\cup S3$"/>
        <text value=". From the practical point of view, the main difficulty is that there may be variables in the model with large or unbounded ranges (such as memory addresses) and arrays with large or unbounded number of elements (such as memory arrays). These difficulties can be overcome by using abstract interpretation to reduce each data type to a small number of abstract values"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="13fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". For example, suppose that one has a property with a parameter$i$ranging over memory addresses. The type$A$of memory addresses is reduced to a set containing two values: parameter value$i$, and symbol$A/i$representing all values other than$i$. In the abstract interpretation, accessing an array at location$i$will produce the value of that location, whereas accessing the array at$A/i$will produce a symbol representing an unknown value"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="1fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Obviously that use of these abstractions deals with a lot of manual work in order to bridge the gap in abstraction level between the implementation and the specification. The ``specification&amp;apos;&amp;apos; is a description of the design at more abstract level, say, as the instruction set architecture (ISA)"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="13fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", ASM, etc. As the SMV Model checking is considered as the basis of formal verification, let us outline the possibilities of reducing SMV models by the abstractions."/>
          </braces>
        </command>
        <figure id="id45" value="Token(TokenType.COMMAND&amp;quot;, &amp;quot;\begin{figure*}&#10;       \vspace*{1pt}&#10;\begin{center}&#10;\mbox{%&#10;\epsfxsize=166mm&#10;\epsfbox{bar-4.eps}&#10;}&#10;\end}&#10;\vspace*{-6pt}&#10;       \Caption{Example of an ASM:  (\textit{a})~bubble sort processor; and (\textit{b})~DMACycle&#10;       \label{f4fr}}&#10;       \vspace*{-2pt}&#10;       \end{figure*}&amp;quot;, line=393, col=23)"/>
      </section>
      <section id="id46">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Specification Based on Algorithmic State Machine"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="Let us consider the ASM description as a specification of a digital design."/>
        <subsection>
          <text value="Algorithmic State Machines"/>
          <command value="\noindent">
            <braces>
              <text value="\noindent"/>
            </braces>
          </command>
          <text value="Algorithmic state machine is a directed connected graph (Fig."/>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f4fr"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="a"/>
          </command>
          <text value=") containing an initial vertex (Begin), a final vertex (End), a finite set of operators (microinstructions) and conditional vertices (rhombuses)"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="4fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=". Operators and conditional vertices have only one input; the initial vertex has no input. The initial vertex and operators have only one output; a conditional vertex has two outputs marked by ``1&amp;apos;&amp;apos; and ``0.&amp;apos;&amp;apos; The final vertex has no outputs. Each operator is, in fact, a microinstruction, and it includes some body consisting of so-called microoperations. These microinstructions correspond to the instruction set architecture ISA mentioned above. Execution of each operator vertex takes exactly one clock cycle, in accordance with true values of the Boolean variables in the rhombuses. For example, in Fig."/>
            </braces>
          </command>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f4fr"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="a"/>
          </command>
          <text value=", the variables$s$, dma, and done are the Boolean ones, which can be marked, say, as$x_1$,$x_2$, and$x_3$. The gray vertexes are the nested ASMs corresponding to pieces of the target design algorithm (see below). The ASM-based design methodology is implemented in ABELITE software tool"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="5fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=", which, in particular, generates from ASM a Mealy automaton which is used in a Control Unit design(synthesis), describing the sequence of the microinstruction executions and represented in the form"/>
            </braces>
          </command>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="2pt"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\noindent">
            <braces>
              <text value="\noindent"/>
            </braces>
          </command>
          <formula id="id47" value="Token(TokenType.FORMULA&amp;quot;, &amp;quot;\begin{equation}&#10;\{a_m, a_s , f_{ms}(x_{i1}, \ldots , x_{ik}),Y\}&#10;\label{e2fr}&#10;\end{equation}&amp;quot;, line=441, col=17)"/>
          <text value="where$a_m$and$a_s$are the current and the next states of the automaton, and the transitions"/>
          <formula id="id48" value="$a_m\rightarrow a_s$"/>
          <text value="corresponding to execution of microoperations in the vertexes (see Table 1 and some explanations after as well) labeled as components$Y_j$of a vector Y (index$j$ranged as number of the vertexes ("/>
          <formula id="id49" value="$j=1, \ldots 5$"/>
          <text value="for ASM in Fig."/>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f4fr"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="a"/>
          </command>
          <text value=")), which are considered as the automaton output variables constituted by set of the microoperations (labeled by ABELITE as$y_k$,"/>
          <command value="\linebreak">
            <braces>
              <text value="\linebreak"/>
            </braces>
          </command>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="-12pt"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <center/>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="2pt"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <braces>
                <text value="{}"/>
                <command value="\small"/>
              </braces>
            </braces>
          </command>
          <center/>
          <command value="\bigskip"/>
          <command value="\addtocounter">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="table"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <braces>
                <text value="{}"/>
                <text value="1"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\noindent">
            <braces>
              <text value="\noindent"/>
            </braces>
          </command>
          <text value="$k$"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="are the indexes of the microoperations in the vertex"/>
          </command>
          <text value=")"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="executed in the given vertex"/>
          </command>
          <text value=". These transitions are performed on the automaton inputs (column"/>
          <formula id="id50" value="$X(a_m,a_s)$"/>
          <text value="in Table 1) in accordance with conjunction of all Boolean variables"/>
          <formula id="id51" value="$x_{i1}, \ldots , x_{ik}$"/>
          <text value=", in the conditional vertexes (rhombuses), where$i$"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="marks a path"/>
          </command>
          <text value="between some rectangles (operational vertex). These variables in the column"/>
          <formula id="id52" value="$X(a_m,a_s)$"/>
          <text value="are ordered (with one index) by ABELITE as in the field ``"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="Logical Conditions"/>
          </command>
          <text value="&amp;apos;&amp;apos; of the following structure:"/>
          <formula id="id53" value="Token(TokenType.FORMULA&amp;quot;, &amp;quot;\begin{equation}&#10;          \left.&#10;          \begin{array}{l}&#10; \mathrm{Microinstructions}:\ \langle Y_j =\{y_1, y_2,\ldots ,y_k\}\rangle\\[6pt]&#10; \mathrm{Microoperations}:\ \langle y_j\;:\;\mathrm{Op}_j\rangle \\[6pt]&#10; \mathrm{Logical\ Conditions}:\ \langle x_i\;:\;R_v^i\rangle&#10;\end}&#10;\right \}&#10;\label{e3fr}&#10;\end{equation}&amp;quot;, line=491, col=27)"/>
          <text value="where Op$_j$are the signatures of microoperations mentioned above (see below the detailed description of Fig."/>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f4fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="), whereas in the set of strings ``Logical Conditions&amp;apos;&amp;apos; symbols$x_i$are Boolean variables (where indexes are ranged in accordance with number of rhombus labels in a given ASM flowchart, 1--3 in Fig."/>
            </braces>
          </command>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f4fr"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="a"/>
          </command>
          <text value=") referring the rhombuses, which correspond to some control variables"/>
          <formula id="id54" value="$R_v^i$"/>
          <text value="used in the target systems. Column"/>
          <formula id="id55" value="$Y(a_m,a_s)$"/>
          <text value="contains the"/>
          <formula id="id56" value="$Y_j =\{y_1,y_2,\ldots$\linebreak $\ldots ,y_{kj}\}$"/>
          <text value="mentioned above. For example, the ASM in Fig."/>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f4fr"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="a"/>
          </command>
          <text value="represents an algorithm of the bubble sort processor. Figure"/>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f4fr"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="b"/>
          </command>
          <text value="is a detailization of one of its gray vertexes, the DMACycle (Direct Memory Access) block. Direct Memory Access is the special mode that does not execute an operation but connects its memory with the outside storage device to read or write information; ext"/>
          <command value="\_rdwr">
            <braces>
              <text value="is the signal from outside. When ext"/>
            </braces>
          </command>
          <command value="\_rdwr"/>
          <text value="="/>
          <text value="1, external system writes information to memory from its output ext"/>
          <command value="\_out">
            <braces>
              <text value=". When ext"/>
            </braces>
          </command>
          <command value="\_rdwr"/>
          <text value="="/>
          <text value="0, external system reads information from memory to its input ext"/>
          <command value="\_in">
            <braces>
              <text value=". Recall that the transition table of the automata Mealy (FSM) obtained from the ASM of Fig."/>
            </braces>
          </command>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f4fr"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="a"/>
          </command>
          <text value="(without any gray blocks translation) is represented in Table 1. The table represents the FSM behavior in well-known"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="cubic"/>
          </command>
          <text value="form, that is, each vector of the third column may contain free components (which do not affect the output values). For example, one can say that the second row of Table 1 presents transitions from$a_1$with any vector which is covered by cube$10x$. Here, the states marking (generated by ABELITE) can be easily seen from the Microinstruction/Microoperations structure. For example, transition to the state$a_3$corresponds to execution of microinstruction (vertex)"/>
          <braces>
            <text value="{}"/>
            <formula id="id57" value="$i:=0$"/>
            <text value=","/>
            <formula id="id58" value="$\mathrm{done}\;=\;0$"/>
          </braces>
          <text value=". Note that state$a_1$is assigned to vertexes ``Begin&amp;apos;&amp;apos; and ``End&amp;apos;&amp;apos; (this assignment deals with some logical synthesis issues, see"/>
          <text value="3"/>
          <text value=". One can look at the condition$s$as a signal from the button Start-Stop; so, the instruction will be executed only when"/>
          <formula id="id59" value="$s = 1$"/>
          <text value=". There is a possibility to transit to state$a_1$both from state$a_1$(after execution of microoperations"/>
          <formula id="id60" value="$i:=0$"/>
          <text value=","/>
          <formula id="id61" value="$\mathrm{done}:=0$"/>
          <text value="in the vertex$Y_5$) and from the state$a_2$(after execution of microoperation"/>
          <formula id="id62" value="$i:=i+1$"/>
          <text value="in the vertex$Y_3$). Structures ("/>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="e3fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=") formed by ABELITE for this example are as follows:"/>
            </braces>
          </command>
          <command value="\smallskip">
            <braces>
              <text value="\smallskip"/>
            </braces>
          </command>
          <command value="\textbf">
            <braces>
              <text value="\textbf{}"/>
            </braces>
            <text value="Microinstructions:"/>
          </command>
          <command value="\smallskip">
            <braces>
              <text value="\smallskip"/>
            </braces>
          </command>
          <formula id="id63" value="$Y1 = y1$"/>
          <formula id="id64" value="$Y2 = y2$"/>
          <formula id="id65" value="$Y3 = y3$"/>
          <formula id="id66" value="$Y4 = y4$"/>
          <formula id="id67" value="$Y5 = y5\,y6$"/>
          <command value="\smallskip">
            <braces>
              <text value="\smallskip"/>
            </braces>
          </command>
          <command value="\textbf">
            <braces>
              <text value="\textbf{}"/>
            </braces>
            <text value="Microoperations:"/>
          </command>
          <command value="\smallskip">
            <braces>
              <text value="\smallskip"/>
            </braces>
          </command>
          <formula id="id68" value="$y1  :  \mbox{DMACycle}$"/>
          <formula id="id69" value="$y2  :  \mbox{For2}$"/>
          <formula id="id70" value="$y3  :  i:=i+1$"/>
          <formula id="id71" value="$y4  :  \mathrm{For\_Check}$"/>
          <formula id="id72" value="$y5  :  i:=0$"/>
          <formula id="id73" value="$y6  :  \mathrm{done}:=0$"/>
          <command value="\smallskip">
            <braces>
              <text value="\smallskip"/>
            </braces>
          </command>
          <command value="\textbf">
            <braces>
              <text value="\textbf{}"/>
            </braces>
            <text value="Logical Conditions:"/>
          </command>
          <command value="\smallskip">
            <braces>
              <text value="\smallskip"/>
            </braces>
          </command>
          <formula id="id74" value="$x1  : s$"/>
          <formula id="id75" value="$x2  : \mathrm{dma}$"/>
          <formula id="id76" value="$x3  : \mathrm{done}$"/>
          <command value="\smallskip">
            <braces>
              <text value="\smallskip"/>
            </braces>
          </command>
          <text value="As it can be seen from this example, ABELITE supports the"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="hierarchical"/>
          </command>
          <text value="design style, that is, each of gray vertexes can be included in the automaton either as a microoperation$Y_j$or it can be translated with its own ASM (like DMA vertex in Fig."/>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f4fr"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="b"/>
          </command>
          <text value=")."/>
        </subsection>
        <subsection>
          <text value="Decomposition-Based Design"/>
          <command value="\noindent">
            <braces>
              <text value="\noindent"/>
            </braces>
          </command>
          <text value="Decomposition-based design (Fig. 5) means a possibility to get unified model of target system from the models of each individual blocks (both on system high-level and logical level). At the system level, the models are some abstract automata and set of microoperations ($y_i$in the example above). Since the principal stage of Model checking is the analysis of the Kripke structure (see Section 2), one could use the ASM flowcharts as an input of formal specification if they would have included all information needed for the Kripke structure building. Comparison of formula ("/>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="e1fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=") and structure ("/>
            </braces>
          </command>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="e2fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=") shows the possibility of this mapping. Example in Table 1 shows all possible transitions from each pair of (input, state) to all reachable states."/>
            </braces>
          </command>
          <center/>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="-6pt"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <center/>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="6pt"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\bigskip"/>
          <command value="\addtocounter">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="figure"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <braces>
                <text value="{}"/>
                <text value="1"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="In other words, the Kripke structure, whose state is defined by a collection of state variables, which may be of Boolean or scalar type, can be described by Transitions Table of FSM, generated from the ASM flowchart (like Table 1), as well as by structures ``Microoperation,&amp;apos;&amp;apos; ``Microinstruction,&amp;apos;&amp;apos; and ``Logical Condition&amp;apos;&amp;apos; of Section 4 (structure ("/>
            </braces>
          </command>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="e3fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=")). Also, ASM enables a convenient way to abstraction description. A possibility to use the ASM-based formalized specification is due to some formal rules, used for ASM flowchart construction"/>
            </braces>
          </command>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="5fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=":"/>
            </braces>
          </command>
          <enumerate/>
          <text value="Therefore, it is possible to obtain automatically a Kripke structure from the ASM description, and the ASM description can be used in the Model-checking-based formal verification of the designs. An example of the ASM transformation in SMV code will be done in Section 6. Below, a methodology of ASM-based semiformal verification, based on the possibility to use ASM as an input of Model Checking, is considered."/>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="-6pt"/>
              </braces>
            </braces>
            <braces/>
          </command>
        </subsection>
      </section>
      <section id="id77">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Model Checking Based on Algorithmic State Machine"/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-2pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="Let us consider the verification methodology in detail. The design verification scheme is shown in Fig. 6. The verification process starts from the informal description (specification) of the target design. The description is manually transformed into ASM flowcharts (see Section 4). The ASM formalism is supported by ABELITE tool"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="5fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", which enables rapidly prototyping hardware systems, performing design space exploration, and simplifying hardware verification. It should be noted that main purpose of ABELITE tool is high-level hardware synthesis using ASM flowchart as an input"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="5fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="but this topic is out of the scope of this paper. The ASM flowcharts can be automatically transformed into SMV code, corresponding to microarchitecture (MA) level (see Section 3) using the program ASM2 SMV devel-"/>
          </braces>
        </command>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-12pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <center/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-6pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <center/>
        <command value="\bigskip"/>
        <command value="\addtocounter">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="figure"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="1"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="oped in the Institute of Informatics Problems of the Russian Academy of Sciences (the team of Alexander Kurts and Dmitry Liburkin)"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="14fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". ABELITE output is the automata tables (in the format of structure ("/>
          </braces>
        </command>
        <command value="\ref">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="e2fr"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="see example in Table 1). Some desirable temporal properties on the design are described formally by the CTL language in SMV format. Such properties are supplemented by specification consistency conditions, like absence of hazards and deadlocks between parallel operations. Then, temporal properties are verified by the SMV model checking tool"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="6fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". If the ASM description satisfies all the specified properties, a verification specialist prepares some cycle-accurate specifications of the design (e."/>
          </braces>
        </command>
        <text value="g., as in"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="10fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=") using semiautomated refinement from ASM flowcharts (see Section 3). Finally, the specifications are used for simulation-based verification of the design with some simulation tool. Before receiving the SMV code, the ASM flowchart can be transformed into a cubic representation of an FSM"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="2fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="(formula ("/>
          </braces>
        </command>
        <command value="\ref">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="e1fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=") and structure ("/>
          </braces>
        </command>
        <command value="\ref">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="e2fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=")), where variables from conditional vertexes of ASM correspond to FSM input variables, and results of operators correspond to its outputs. It should be emphasized that during compilation, all generalized operational vertexes (see Section 4) will be included in the overall ASM. Thus, a microinstruction can be either a set of microoperations or a generalized operator. At early stages of the design process, when some operations (or parts of operations) are not clearly defined, we may informally outline some desirable actions in the vertexes using textual comments. This allows us to capture a timing structure of the target operations without specifying their functionality. On the base of such partial flowcharts, one can automatically construct various test benches for verification via simulation. Usage of ASM for graphical representation of target design is more convenient in comparison with informal description in natural language. It allows verification engineers to present visually a timing structure of operations and their functionality (totally or partially). It should be emphasized that the ASM flowchart is not only a picture describing the target design; it has formal semantics and can be used for formal verification."/>
          </braces>
        </command>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-6pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
      </section>
      <section id="id78">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Pipelined Microprocessor Algorithmic-State-Machine-Based Specification and Verification"/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-3pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="Let us consider the pipelined processor"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="7fr"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". In the processor, every pipeline stage has its data path and"/>
          </braces>
        </command>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-12pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\pagebreak"/>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="multicols"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <figure id="id79" value="Token(TokenType.COMMAND&amp;quot;, &amp;quot;\begin{figure}&#10;\vspace*{1pt}&#10;\begin{center}&#10;\mbox{%&#10;\epsfxsize=165.752mm&#10;\epsfbox{bar-7.eps}&#10;}&#10;\end}&#10;\vspace*{-9pt}&#10;\Caption{ASMM of  Fetch stage~(\textit{a}), and (Fetch~1/Fetch~2) blocks~(\textit{b})&#10;\label{f7fr}}&#10;\vspace*{-6pt}&#10;\end{figure}&amp;quot;, line=735, col=15)">
          <command value="\begin">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="2"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\noindent">
            <braces>
              <text value="\noindent"/>
            </braces>
          </command>
          <text value="control unit. Instruction execution begins by fetching the instruction from program memory which address is in the program counter (PC). The instruction is then decoded to determine the operation type, the operand registers, the branch target, etc. The program counter is updated by incrementing its current value. Let us consider the fetch stage in the pipeline (Fig."/>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f7fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="), which is responsible for fetching instructions from the instruction memory. Note that the gray vertexes are the nested ASMs (not expanded here). The instruction is read into two Instruction Registers, IR1 and IR2, used for short and long instructions, correspondingly. The address of the instruction is stored in the PC, which is promoted every time when instruction is read. Program counter, IR1 and IR2 are then passed to the next stage. The fetch stage also deals with branch execution, interrupts, and DMA which allows outside devices to read or write data directly into each of two memory blocks. The CheckBranch vertex checks whether the fetched instruction is a branch one, and in dependence of the result, produces corresponding flag. ``Int&amp;apos;&amp;apos; block fetches an instruction from memory, say, a memory block M0 (Fig."/>
            </braces>
          </command>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f7fr"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="b"/>
          </command>
          <text value="), and if it is a short instruction (length of 16 bits), then this is indicated by zero in bit 5 of the IR1$f$register (suffix$f$denotes that the register copy is modeled on the Fetch stage), and the following action will correspond to the right branch of the flowchart. But if this bit is one, Fetch 2 block is activated, and the remaining bits of the instruction are written to the 16-bit register IR2$f$. The Logical condition ShLodInpBran"/>
          <command value="\_in"/>
          <command value="\_F">
            <braces>
              <text value="checks if the fetched instruction is one of the types ``Shift,&amp;apos;&amp;apos; ``Load,&amp;apos;&amp;apos; ``Input,&amp;apos;&amp;apos; or ``Branch.&amp;apos;&amp;apos; They require for their processing algorithm, described in the nested vertex Fetch2Oper2, another instructions are processed in the nested vertex Fetch2Oper1. Note that thanks to hierarchical properties of the ASM/ABELITE, we can abstract away all data from gray blocks when we are aimed to study properties on the high level description. The condition variable bool2std(IR1f(0to3) checks condition of skip of next instruction. In distinct of more specialized systems like SystemC, ABELITE does not support directly the modeling of several simultaneous process, but possibility of reading/writing description in numerous register blocks, using different models of their interactions, as well as hierarchical description of target design by ASM allows description and verification of the pipelining stages execution. In particular, in the framework of Model-Checking verification, the idea is to show that a machine modeled at the MA level, which corresponds to microoperations set and connections of ABELITE ASM model, implements (refines) a machine modeled at the ISA level. That is, a mapping function from MA states to ISA states. The refinement map,$r$, shows how to view an MA state as an ISA state, e."/>
            </braces>
          </command>
          <text value="g., the refinement map has to hide some MA components that do not appear in the ISA. That is, the verification problem can be considered as a checking of equivalence of ISA and MA. In terms of formal verification, SMV model obtained from ASM with generalized blocks (hierarchical ASM) is an"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="implementation"/>
          </command>
          <text value="of the system designed (see subsection 2.1) in comparison with the high-level ASM. States of the Pipelined machine FSM model, generated from ASM by the FSM2SMV program mentioned above contain both all visible by a programmer components and the pipeline registers, which should be represented in ASM specification. In fact, ASM captures the structure, behavior, and mapping (between the structure and behavior) of the architecture pipelines. The structure is defined by its components (units, storages, ports, connections) and the connectivity (pipeline and data paths) between these components. We can write CTL/LTL-based properties for each category of the hazard mentioned above. Designers can be interested to check various properties, which show how instructions are transferred from fetch pipeline stage to Fetch2Oper1 and Fetch2Oper2 stages. Taking into account that the authors verify their design via Model-Checking methodology, that is, compare instruction level description of the target processor and its MA level FSM behavior (represented in terms of microoperations generated by ABELITE), the program ASM2SMV with fetch flowchart as input (see Fig."/>
          <command value="\ref">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="f4fr"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=") is used and one gets the SMV model of FSM, implemented all microoperations as a result. It is interesting, for example, to check the fulfillment of the property, described by LTL as"/>
            </braces>
          </command>
          <command value="\begin"/>
          <command value="\mbox">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="assert G"/>
              </braces>
            </braces>
            <braces/>
          </command>
          <text value="(("/>
          <command value="\mbox">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="ShLodInpBran"/>
                <command value="\_in"/>
                <command value="\_F">
                  <braces/>
                </command>
              </braces>
            </braces>
          </command>
          <text value="="/>
          <text value="0)"/>
          <braces>
            <text value="{}"/>
            <command value="\rightarrow"/>
            <command value="\mbox">
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="F"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="("/>
              </braces>
            </command>
            <command value="\mbox">
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="state"/>
                </braces>
              </braces>
              <braces/>
            </command>
          </braces>
          <text value="= n))"/>
          <command value="\end">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="multline*"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="where ``state&amp;apos;&amp;apos; is a state of FSM, generated from ASM, with a number"/>
            </braces>
          </command>
          <formula id="id80" value="$n=1, 2, \ldots , 7$"/>
          <text value="."/>
          <text value="The specific variable ``state&amp;apos;&amp;apos; is assigned from the ASM, by the program, which translated ASM to SMV. In this example, state 1 corresponds to the DMA feature, that is, one checks that before the DMA is performed, fetch stage waits for all other stages to stop so there are no conflicts between the stages."/>
          <figure id="id81" value="Token(TokenType.COMMAND&amp;quot;, &amp;quot;\begin{figure*}&#10;\vspace*{9pt}&#10;\begin{center}&#10;\mbox{%&#10;\epsfxsize=120mm&#10;\epsfbox{bar-9.eps}&#10;}&#10;\end}&#10;\vspace*{-6pt}&#10;\Caption{Window of SMV program execution  &#10;\label{f9fr}}&#10;\end{figure*}&amp;quot;, line=833, col=16)">
            <text value="The resulted SMV code of the Fetcher is:"/>
            <command value="\begin">
              <braces>
                <text value="module main()"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="S : boolean; ShLodInpBran_in_F : boolean; bool2std : array 1..100 of boolean; to3 : boolean; PCf : 0..100; DMA : boolean; IR1f :array 1..100 of boolean; FGO : boolean; FGI : boolean; state : 1..7; init(state):=1; case"/>
                </braces>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="state=1 : if ((S) &amp;amp; !(DMA))"/>
                </braces>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="; /* CheckBranch */ next(state):=7;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="else if (!(S)) next(state):=1; else"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="; /* DMACycle */ next(state):=1;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="state=2 : if (!(ShLodInpBran_in_F))"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="; /* Fetch2Oper1 */ next(state):=1;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="else"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="; /* Fetch2Oper2 */ next(state):=1;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="state=3 : if (!(IR1f"/>
              </braces>
              <braces/>
              <braces>
                <text value="5"/>
              </braces>
              <braces/>
              <braces>
                <text value=") &amp;amp; (bool2std"/>
              </braces>
              <braces/>
              <braces>
                <text value="IR1f"/>
              </braces>
              <braces/>
              <braces>
                <text value="0to3"/>
              </braces>
              <braces/>
              <braces>
                <text value="=1100"/>
              </braces>
              <braces/>
              <braces>
                <text value="))"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="next(state):=5; next(PCf):=PCf+1;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="else if (!(IR1f"/>
              </braces>
              <braces/>
              <braces>
                <text value="5"/>
              </braces>
              <braces/>
              <braces>
                <text value=") &amp;amp; !(bool2std"/>
              </braces>
              <braces/>
              <braces>
                <text value="IR1f"/>
              </braces>
              <braces/>
              <braces>
                <text value="0to3"/>
              </braces>
              <braces/>
              <braces>
                <text value="=1100"/>
              </braces>
              <braces/>
              <braces>
                <text value=") &amp;amp; (ShLodInpBran_in_F))"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="; /* Fetch2Oper2 */ next(state):=1;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="else if (IR1f"/>
              </braces>
              <braces/>
              <braces>
                <text value="5"/>
              </braces>
              <braces/>
              <braces>
                <text value=")"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="; /* Fetch2 */ next(state):=2;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="else"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="; /* Fetch2Oper1 */ next(state):=1;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="state=4 :"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="; /* Fetch1 */ next(state):=3;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="state=5 : if ((IR1f"/>
              </braces>
              <braces/>
              <braces>
                <text value="4"/>
              </braces>
              <braces/>
              <braces>
                <text value=") &amp;amp; !(FGO)) next(state):=1; else if (!(IR1f"/>
              </braces>
              <braces/>
              <braces>
                <text value="4"/>
              </braces>
              <braces/>
              <braces>
                <text value=") &amp;amp; (FGI))"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="next(state):=6; next(PCf):=PCf+1;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="else if (!(IR1f"/>
              </braces>
              <braces/>
              <braces>
                <text value="4"/>
              </braces>
              <braces/>
              <braces>
                <text value=") &amp;amp; !(FGI)) next(state):=1; else"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="next(state):=6; next(PCf):=PCf+1;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="state=6 :"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="next(state):=1; next(PCf):=PCf+1;"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="state=7 :"/>
              </braces>
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="; /* Int */ next(state):=4;"/>
                </braces>
              </braces>
              <braces/>
              <braces/>
              <braces>
                <text value="assert G ((ShLodInpBran_in_F=0) -&amp;gt; F (state = 1));"/>
              </braces>
              <braces/>
            </command>
            <command value="\end">
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="verbatim"/>
                </braces>
              </braces>
              <braces/>
            </command>
            <text value="Let us describe briefly the states constituting the Kripke structure built form the ASM flowchart in Fig."/>
            <command value="\ref">
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="f7fr"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value=". Totally 7 following states were generated: state 1 is an initial state of the fetcher, and it corresponds both to the vertexes ``Begin&amp;apos;&amp;apos; and ``End,&amp;apos;&amp;apos; execution of the vertexes Fetch2Oper1or Fetch2Oper2 corresponds to transition from the state 2 to state 1 (end of this fetch stage), execution of the vertex Fetch1 means the transition either from state 3 to state 5 with the PC promotion (in dependence of the flags FGO/FG1 values), or execution of the Fetch2Oper1/Fetch2Oper2 functions with ending of the fetch stage, etc. Execution of the SMV code by CADENCE SMV program shows (see the SMV code of the Fetcher above) that given property is carried out with necessity (true is indicated in the ``Result&amp;apos;&amp;apos; position in Fig."/>
              </braces>
            </command>
            <command value="\ref">
              <braces>
                <braces>
                  <text value="{}"/>
                  <text value="f9fr"/>
                </braces>
              </braces>
              <braces/>
              <braces>
                <text value="). Here, structure Kripke is represented by SMV operators next() which correspond to transitions represented by Table 1. Note that as it was mentioned above, the main difficulty is that there may be variables in the model with large or unbounded ranges (such as memory addresses) and arrays with a large or unbounded number of elements (such as memory arrays). Therefore, the program ASM2SMV allows definition of any type of variables during synthesis of SMV code."/>
              </braces>
            </command>
          </figure>
        </figure>
      </section>
      <section id="id82">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Concluding Remarks"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="This paper introduces a new semiformal methodology for functional verification of pipelined hardware designs. This methodology has two specification levels: ($i$) ASM (upper level) and ($ii$) microarchitectural specifications (lower level). Algorithmic state machine is used for the graphic specification of target design. Using the ASM descriptions, one can automatically check temporal properties of the design using model checking techniques. In fact, ASM captures the structure, behavior, and mapping (between the structure and behavior) of the pipelines MA. The structure is defined by its components (units, storages, ports, connections) and the connectivity (pipeline and data-transfer paths) between these components. Usage of ASM for graphical representation of target design is more convenient in comparison with informal description in natural language. It allows verification engineers to visually present a timing structure of operations and their functionality (totally or partially). It should be emphasized that the ASM is not only a picture describing the target design; it has formal semantics and can be used for formal verification."/>
        <braces>
          <text value="{}"/>
          <command value="\small"/>
          <command value="\frenchspacing">
            <braces>
              <braces>
                <text value="{}"/>
              </braces>
            </braces>
          </command>
        </braces>
        <command value="\addcontentsline">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="toc"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="section"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="Литература"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\begin">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="99"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <item id="id83" value="\bibitem">
          <braces>
            <text value="\bibitem{1fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Clarke E."/>
        <text value="M., Grumberg O., Peled D."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="MIT Press, 2000."/>
        <item id="id84" value="\bibitem">
          <braces>
            <text value="\bibitem{11fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Baranov S., Frenkel S., Sinelnikov V., Zakharov V."/>
        <text value="Concurrent design and verification of digital hardware // Informatics and Its Applications, 2008. Vol. 2. Issue 3. P. 7--25."/>
        <item id="id85" value="\bibitem">
          <braces>
            <text value="\bibitem{4fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Baranov S."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="TTU Press, 2008."/>
        <item id="id86" value="\bibitem">
          <braces>
            <text value="\bibitem{2fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Lee R., Tsien B."/>
        <text value="Pre-silicon verification of the Alpha 21364 microprocessor error handling system // Design Automation Conference, DAC&amp;apos;01, Proceedings. 2001. P. 822--827."/>
        <item id="id87" value="\bibitem">
          <braces>
            <text value="\bibitem{3fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Bhadra J., Abadir M."/>
        <text value="S., Wang L.-C., Ray S."/>
        <text value="A survey of hybrid techniques for functional verification // IEEE Design"/>
        <text value="Test of Computers, March--April 2007. P. 112--122."/>
        <item id="id88" value="\bibitem">
          <braces>
            <text value="\bibitem{12fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Xu X., Kimura S., Horika K., Tsuchiya T."/>
        <text value="Coverage estimation using transition perturbation for symbolic model checking in hardware verification //"/>
        <command value="\mbox">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="IEICE"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value="TRANS. Fundamentals, 2006. Vol. E89-A. No."/>
          </braces>
        </command>
        <text value="12. P. 3451--3457."/>
        <item id="id89" value="\bibitem">
          <braces>
            <text value="\bibitem{8fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Kirxhsteiger Chr., Grinshel J., Trummer Chr., Steger Chr., Weil R."/>
        <text value="Automatic test generation from semi-formal specification for function // IEEE International System Conference SysCon2008. Montreal, Canada. April 7--10, 2008."/>
        <item id="id90" value="\bibitem">
          <braces>
            <text value="\bibitem{9fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Mcmillan K."/>
        <text value="L."/>
        <text value="Verification of an implementation of Tomasulo&amp;apos;s algorithm by compositional model checking // CAV98 Proceedings. 1998. P. 110--121."/>
        <item id="id91" value="\bibitem">
          <braces>
            <text value="\bibitem{13fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="McMillan K."/>
        <text value="L."/>
        <text value="A methodology for hardware verification using compositional model checking // Sci. Comp. Prog., 2000. Vol. 37. No."/>
        <text value="1--3. P. 279--309."/>
        <item id="id92" value="\bibitem">
          <braces>
            <text value="\bibitem{5fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Baranov S."/>
        <text value="ASMs in high level synthesis of EDA tool ABELITE // DESDes&amp;apos;09 Int. IFAC Workshop Proceedings. Valensia, Spain, 2009. P. 195--200."/>
        <item id="id93" value="\bibitem">
          <braces>
            <text value="\bibitem{14fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Frenkel S., Kurts A., Liburkin D., Anders B., Fandjushina N."/>
        <text value="Certificate of the State Registration No."/>
        <text value="2010612828 on the software program ``Translator of the Mealy automaton table representations into programs on SMV language for the automation of the process of digital devices verification basing on Model Checking&amp;apos;&amp;apos;. 26 April, 2010."/>
        <item id="id94" value="\bibitem">
          <braces>
            <text value="\bibitem{6fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="McMillan K."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="Cadence, 2001."/>
        <item id="id95" value="\bibitem">
          <braces>
            <text value="\bibitem{10fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Frenkel S., Kamkin A."/>
        <text value="Verification methodology based on algorithmic state machine and cycle-accurate contract specifications // 7th IEEE East--West Design"/>
        <text value="Test Symposium EWDTS Proceedings. 2009. P. 39--42."/>
        <item id="id96" value="\bibitem">
          <braces>
            <text value="\bibitem{7fr}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Kutzman I., Raitzin A."/>
        <text value="Design of fast pipelined processor with complex addressing mode. M.Sc. Thesis. Bar Ilan University, 2007."/>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="thebibliography"/>
            </braces>
          </braces>
          <braces/>
          <braces/>
          <braces/>
        </command>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="multicols"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-30pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <text value="ПОЛУФОРМАЛЬНАЯ ВЕРИФИКАЦИЯ ЦИФРОВОГО УСТРОЙСТВА С КОНВЕЙЕРОМ, ОСНОВАННАЯ НА ИСПОЛЬЗОВАНИИ АЛГОРИТМИЧЕСКИХ МАШИН СОСТОЯНИЯ"/>
        <text value="С. Баранов$^1$, С."/>
        <text value="Л. Френкель$^2$, В."/>
        <text value="Н. Захаров$^3$"/>
        <command value="\titelr">
          <braces>
            <braces>
              <text value="{}"/>
              <command value="\tit">
                <braces/>
                <braces>
                  <braces>
                    <text value="{}"/>
                    <command value="\aut">
                      <braces/>
                    </command>
                  </braces>
                </braces>
              </command>
            </braces>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="$^1$Холонский технологический институт, Израиль, samary@012.net.il"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="$^2$Институт проблем информатики Российской академии наук, fsergei@mail.ru"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="$^3$Институт проблем информатики Российской академии наук, VZakharov@ipiran.ru"/>
        <command value="\medskip"/>
        <annotation value="\Abst{Статья описывает методы и средства использования Алгоритмических машин состояний (ASM) для высокоуровневой спецификации проектов сложных цифровых систем и их верификации методом Проверки моделей (Model Checking). Данный подход использует иерархическое описание проектов на алгоритмическом уровне абстракции и возможность построения конечно-автоматных моделей по ASM-диаграммам алгоритмов. Для автоматической генерации программ Проверки моделей на языке SMV (Symbolic Modes Verifier) по ASM-диаграмме проектируемого устройства была разработана специальная программа. Способ применения данного подхода и программы демонстрируется на примере верификации проекта конвейерного микропроцессора.}"/>
        <keywords>
          <braces>
            <text value="\KW{формальная верификация; метод Проверки моделей; конечные автоматы}"/>
          </braces>
        </keywords>
        <command value="\label">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="end"/>
              <command value="\stat">
                <braces/>
              </command>
              <command value="\renewcommand">
                <braces>
                  <braces>
                    <text value="{}"/>
                    <command value="\figurename">
                      <braces/>
                      <braces>
                        <braces>
                          <text value="{}"/>
                          <command value="\protect"/>
                          <command value="\bf">
                            <braces>
                              <text value="Рис."/>
                            </braces>
                            <braces/>
                          </command>
                          <command value="\renewcommand">
                            <braces>
                              <braces>
                                <text value="{}"/>
                                <command value="\tablename">
                                  <braces/>
                                  <braces>
                                    <braces>
                                      <text value="{}"/>
                                      <command value="\protect"/>
                                      <command value="\bf">
                                        <braces>
                                          <text value="Таблица"/>
                                        </braces>
                                        <braces/>
                                      </command>
                                      <command value="\renewcommand">
                                        <braces>
                                          <braces>
                                            <text value="{}"/>
                                            <command value="\bibname">
                                              <braces/>
                                              <braces>
                                                <braces>
                                                  <text value="{}"/>
                                                  <command value="\protect"/>
                                                  <command value="\rmfamily">
                                                    <braces>
                                                      <text value="Литература"/>
                                                    </braces>
                                                    <braces/>
                                                  </command>
                                                </braces>
                                              </braces>
                                            </command>
                                          </braces>
                                        </braces>
                                      </command>
                                    </braces>
                                  </braces>
                                </command>
                              </braces>
                            </braces>
                          </command>
                        </braces>
                      </braces>
                    </command>
                  </braces>
                </braces>
              </command>
            </braces>
          </braces>
        </command>
      </section>
    </fulltext>
  </paper>
</papers>