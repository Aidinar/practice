<?xml version="1.0" encoding="utf-8"?>
<papers>
  <paper>
    <metadata>
      <annotation value="\Abst{This paper presents several ways for extending the scope of program self-correction methods, based on the ``random self-reducibility&amp;apos;&amp;apos; property, to hardware design. The concept can be utilized for both analog and digital hardware-design. The extension is based on sampling, polynomial-interpolation, and error-correcting codes. In particular, the authors suggest using the well-known reconstruction of real-numerical functions for correcting faults remaining in analog and digital hardware, e.g., arithmetic logic units (ALU), after manufacturing testing. The present approach can complement the state-of-the-art technique of program self-correction by uniformly testing samples of operations and verifying the results of these samples.}"/>
      <keywords>
        <braces>
          <text value="\KWE{self-correcting; real function computation; data analysis; interpolation}"/>
        </braces>
      </keywords>
    </metadata>
    <fulltext>
      <literature/>
      <command value="\renewcommand">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\bibname">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\protect"/>
                  <command value="\rmfamily">
                    <braces>
                      <text value="References"/>
                    </braces>
                    <braces/>
                  </command>
                  <command value="\renewcommand">
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <command value="\figurename">
                          <braces/>
                          <braces>
                            <braces>
                              <text value="{}"/>
                              <command value="\protect"/>
                              <command value="\bf">
                                <braces>
                                  <text value="Figure"/>
                                </braces>
                                <braces/>
                              </command>
                            </braces>
                          </braces>
                        </command>
                      </braces>
                    </braces>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <text value="dolev"/>
      <text value="PROBABILISTIC METHODS FOR SELF-CORRECTING HARDWARE DESIGN$^*$"/>
      <text value="Probabilistic methods for self-correcting hardware design"/>
      <text value="S. Dolev, S. Frenkel, and D."/>
      <text value="E. Tamir"/>
      <text value="S. Dolev$^1$, S. Frenkel"/>
      <formula id="id1" value="$^{2,3}$"/>
      <text value=", and D."/>
      <text value="E. Tamir$^4$"/>
      <command value="\titel">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\tit">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\aut">
                    <braces/>
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <command value="\autkol">
                          <braces/>
                          <braces>
                            <braces>
                              <text value="{}"/>
                              <command value="\titkol">
                                <braces/>
                                <braces>
                                  <braces>
                                    <text value="{}"/>
                                    <command value="\renewcommand">
                                      <braces>
                                        <braces>
                                          <text value="{}"/>
                                          <command value="\thefootnote">
                                            <braces/>
                                            <braces>
                                              <braces>
                                                <text value="{}"/>
                                                <command value="\fnsymbol">
                                                  <braces>
                                                    <braces>
                                                      <text value="{}"/>
                                                      <text value="footnote"/>
                                                    </braces>
                                                  </braces>
                                                  <braces/>
                                                  <braces/>
                                                </command>
                                              </braces>
                                            </braces>
                                          </command>
                                        </braces>
                                      </braces>
                                    </command>
                                  </braces>
                                </braces>
                              </command>
                            </braces>
                          </braces>
                        </command>
                      </braces>
                    </braces>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[1]{}"/>
        </braces>
      </command>
      <text value="Extended abstract of this work was presented at the 13th International Conference on Applied Stochastic Models and Data Analysis (ASMDA), 2009. This research is partially supported by the Russian Foundation for Basic Research (Grant RFBR 12-07-00109) and by the Rita Altura Trust Chair in Computer Sciences, Lynne and William Frankel Center for Computer Science, Israel Science Foundation (Grant No."/>
      <text value="428/11), Cabarnit Cyber Security MAGNET Consortium, Grant from the Institute for Future Defense Technologies Research named for the Medvedi of the Technion, and the Israeli Internet Association."/>
      <command value="\renewcommand">
        <braces>
          <braces>
            <text value="{}"/>
            <command value="\thefootnote">
              <braces/>
              <braces>
                <braces>
                  <text value="{}"/>
                  <command value="\arabic">
                    <braces>
                      <braces>
                        <text value="{}"/>
                        <text value="footnote"/>
                      </braces>
                    </braces>
                    <braces/>
                    <braces/>
                  </command>
                </braces>
              </braces>
            </command>
          </braces>
        </braces>
      </command>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[1]{}"/>
        </braces>
      </command>
      <text value="Department of Computer Science, Ben-Gurion University, Beer-Sheva 84105, Israel"/>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[2]{}"/>
        </braces>
      </command>
      <text value="Institute of Informatics Problems, Russian Academy of Sciences, Moscow 119333, Russian Federation"/>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[3]{}"/>
        </braces>
      </command>
      <text value="Moscow Institute of Radio, Electronics, and Automation ``MIREA,&amp;apos;&amp;apos; Moscow 119454, Russian Federation"/>
      <command value="\footnotetext">
        <braces>
          <text value="\footnotetext[4]{}"/>
        </braces>
      </command>
      <text value="Department of Computer Science, Texas State University, San Marcos, TX 78666, USA"/>
      <command value="\small">
        <braces>
          <braces>
            <text value="{}"/>
          </braces>
        </braces>
      </command>
      <command value="\textbf">
        <braces>
          <text value="\textbf{}"/>
        </braces>
      </command>
      <command value="\thepage">
        <braces/>
      </command>
      <command value="\hfill"/>
      <command value="\specialsymbol">
        <braces>
          <text value="~---"/>
        </braces>
      </command>
      <text value="INFORMATICS AND APPLICATIONS"/>
      <text value="2013"/>
      <text value="volume 7"/>
      <text value="issue"/>
      <text value="4"/>
      <command value="\small">
        <braces>
          <braces>
            <text value="{}"/>
          </braces>
        </braces>
      </command>
      <command value="\specialsymbol">
        <braces>
          <text value="~---"/>
        </braces>
      </command>
      <text value="INFORMATICS AND APPLICATIONS"/>
      <text value="2013"/>
      <text value="volume 7"/>
      <text value="issue"/>
      <text value="4"/>
      <command value="\hfill"/>
      <command value="\textbf">
        <braces>
          <text value="\textbf{}"/>
        </braces>
      </command>
      <command value="\thepage">
        <braces/>
        <braces/>
        <braces/>
      </command>
      <command value="\vskip">
        <braces>
          <text value="20pt plus 9pt minus 6pt"/>
        </braces>
      </command>
      <command value="\thispagestyle">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="myheadings"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\begin">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="2"/>
          </braces>
        </braces>
        <braces/>
      </command>
      <command value="\label">
        <braces>
          <braces>
            <text value="{}"/>
            <text value="st"/>
            <command value="\stat">
              <braces/>
            </command>
          </braces>
        </braces>
      </command>
      <section id="id2">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Introduction"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="The reliability of computation in the presence of errors is an important research topic. In particular, it is crucial in the scope of Digital Signal Processors (DSP) based classification tasks and for embedded devices of safety-critical systems. Robust methods for identifying incoming waveforms, referred to as Modulation Classification"/>
        <text value="1"/>
        <text value="are some examples of this type of classification problems. The objective in these computation tasks is to minimize the error probability. Since it is very difficult to test and detect all of the possible manufacturing faults in the stage of fabrication of modern hardware, there is an increasing interest in methods for self-correction"/>
        <text value="2"/>
        <text value=". The methods presented in the literature (cf."/>
        <text value="2"/>
        <text value="), however, require knowledge related to the logical structure of the target design as well as sophisticated models to analyze their reliability. In addition, the task of verifying the correctness of information processing devices such as microprocessors is a very challenging task since, typically, an exhaustive verification is an exponential function of the device complexity. Generally, self-correction is based on simple estimation of the error probability using sampling rather than proving correctness or exhaustive evaluation. Sampling can be used to efficiently identify the probability of a given ``black-box&amp;apos;&amp;apos; device to correctly compute the results for uniformly selected inputs. Originally, the scope of self-correction has involved a program that computes functions-over-finite-fields, overcoming computation errors on a small fraction ("/>
        <formula id="id3" value="$\varepsilon$"/>
        <command value="\specialsymbol">
          <braces>
            <text value="~"/>
          </braces>
        </command>
        <text value="3, 4"/>
        <text value=". In this paper, however, it is shown that the random reducibility-based self-correction approach, originally suggested to"/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="amplify"/>
        </command>
        <text value="the reliability of programs"/>
        <text value="3, 4"/>
        <text value=", can be used in the scope of nonfinite fields for self-correcting hardware. One of the main contributions of the current paper is the introduction of novel ways to extend the software-based self-correction paradigm to digital and analog hardware. The proposed approach can complement state-of-the-art techniques by uniformly testing samples of operations and verifying the results of these samples. Hence, it enables tolerating a small percentage of incorrect results due to manufacturing defects, thereby facilitating the use of nonperfect hardware. In operation mode when an operation op$_i$has to be executed, a uniformly chosen set of operations op$_j$, op$_k$that can imply the result of the operation in hand are executed in order to maintain a verified result. It is essential to note that the domain/range of computed functions cannot be restricted to finite fields and, by using some techniques"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="4-dol, 12-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", can include the real numbers. In addition, sampling, error correction codes, polynomial interpolation, and segmentation are used to increase the efficiency of self-correction for any given function over the real numbers. The paper, which is an extended version of paper"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="14-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", is organized as follows. Section 2 provides the problem definition and surveys related research. Section 3 presents a methodology for increasing the computation accuracy by polynomial interpolation with error correction. Section 4 considers possible ways to reconstruct real functions using interpolation and section 5 presents a synopsis of approaches to possible implementation of self-correcting based hardware. Conclusions and proposals for future work are included in section 6."/>
          </braces>
        </command>
      </section>
      <section id="id4">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Problem Analysis and Related Work"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="The following aspects of self-correcting computations are considered in this section: ($i$) incorrect function on a small fraction of the inputs; and ($ii$) sampling-based self-correcting."/>
        <subsection>
          <text value="Incorrect function on a small fraction of the inputs"/>
          <command value="\noindent">
            <braces>
              <text value="\noindent"/>
            </braces>
          </command>
          <text value="Consider a hardware computation device, such as an ALU, designed to compute a function"/>
          <formula id="id5" value="$f(x)$"/>
          <text value="of input values from the domain$X$; and assume that the device produces incorrect results"/>
          <formula id="id6" value="$f^*(x)\not= f(x)$"/>
          <text value="for a small fraction of$X$. That is,"/>
          <formula id="id7" value="$f^*(x)\not= f(x)$"/>
          <text value="for"/>
          <formula id="id8" value="$x\in X_C\subset X$"/>
          <text value=", such that"/>
          <formula id="id9" value="$\vert X_C\vert \ll \vert &#10;X\vert$"/>
          <text value="where"/>
          <formula id="id10" value="$\vert A\vert$"/>
          <text value="denotes the rank of a set$A$. This is depicted in Fig. 1. Generally, the correctness of general-purpose and application-specific microprocessors is verified by manufacturer-testing at production time and/or self-checking procedures which are based on online detection. The detection of all possible permanent faults through testing at the manufacturing cycle, however, is not feasible; and self-checking covers only a small fraction of erroneous bits. Hence, it requires specific knowledge about the logical structure of the target design."/>
          <center/>
          <command value="\vspace*">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="6pt"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <braces>
                <text value="{\figurename~1}"/>
              </braces>
            </braces>
          </command>
          <command value="\small">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="Incorrect results of the computation of the target function"/>
                <formula id="id11" value="$f(x)$"/>
              </braces>
            </braces>
            <braces/>
            <braces/>
          </command>
          <command value="\addtocounter">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="figure"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <braces>
                <text value="{}"/>
                <text value="1"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="The Floating Point divide instruction on the Pentium"/>
            </braces>
          </command>
          <formula id="id12" value="$^\registered$"/>
          <text value="processor is one of the well-known examples for this phenomenon. Despite more than 10 years of debugging and enhancements, the Pentium"/>
          <formula id="id13" value="$^\registered$"/>
          <text value="processor Floating Point divide instructions have produced inaccurate results for a fraction of inputs"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="5-dol"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=". Nevertheless, sampling can be used to efficiently identify the probability of a given device to correctly compute the results for inputs selected consistently according to a probability distribution such as uniform distribution. Indeed, sampling-based self-correction along with testing and self-checking is suggested in literature"/>
            </braces>
          </command>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="3-dol, 4-dol"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value="."/>
            </braces>
          </command>
        </subsection>
        <subsection>
          <text value="Sampling-based self-correction"/>
          <command value="\noindent">
            <braces>
              <text value="\noindent"/>
            </braces>
          </command>
          <text value="A function is"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="random self-reducible"/>
          </command>
          <text value="of order$k$over a set$D$if its value at a given point can be efficiently reconstructed from its evaluation at random points"/>
          <text value="3, 4"/>
          <text value=". The reconstruction is possible if, and only if, there exists a function"/>
          <formula id="id14" value="$\varphi$"/>
          <text value="and a set of random functions"/>
          <formula id="id15" value="$\sigma_1, \sigma_2,\ldots , \sigma_n$"/>
          <text value="such that"/>
          <formula id="id16" value="$f(x)=\varphi(x,r,f(\sigma_1(x,r),\ldots , f(\sigma_n(x,r)))$"/>
          <text value="for"/>
          <formula id="id17" value="$x,r\in D$"/>
          <text value=". This property allows reconstruction of the value of a function$f$using a finite number of elements taken from its domain without requiring any knowledge about the implementation of the device that implements the function, e."/>
          <text value="g., a hardware operational block or a program, which performs the computation. Note that polynomials of degree$d$over a finite field are random self-reducible using$d+1$random points"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="4-dol"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=". Consider a function with no input/output domain restrictions. For example, these domains might include integer values, real numbers, vectors, etc. In order to use the"/>
            </braces>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="reliability amplification"/>
          </command>
          <text value="technique utilizing the random self-reducible property"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="3-dol, 6-dol"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=", it is necessary to provide a specific number of"/>
            </braces>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="batches"/>
          </command>
          <text value="that yield sufficient probability for the majority of the batches to be correct; thereby, enabling using majority vote procedures for self- correction. In this context, the term"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="batch"/>
          </command>
          <text value="denotes a"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="set of program input/output instances"/>
          </command>
          <text value=". In other words, in the context of this paper, reliability amplification denotes the increase of correct computation probability due to computation reorganization, for example, using the fact that the functions are random self-reducible to reorganize the functions. Let$n$be the number of batches and let$p$denote a fraction of the inputs for which the computations can be incorrect. The probability of correct computation can be calculated as the probability that the outputs obtained for more than$n/2$of the batches are correct. This is given by:"/>
          <formula id="id18" value="Token(TokenType.FORMULA&amp;quot;, &amp;quot;\begin{equation}&#10;       \mathrm{Pr}\left( k\geq \left\lfloor \fr{n}{2}\right\rfloor+1\right)=1-\sum\limits_{k=1}^L C_n^k p^k q^{n-k}&#10;       \label{e1-dol}&#10;       \end{equation}&amp;quot;, line=212, col=24)"/>
          <text value="where$k$is the number of correct outputs;"/>
          <formula id="id19" value="$p=1-q$"/>
          <text value=";"/>
          <formula id="id20" value="$L=\lfloor &#10;n/2\rfloor +1$"/>
          <text value="is the probability of correct computation for each batch; and"/>
          <formula id="id21" value="$C_n^k$"/>
          <text value="is the Binomial coefficient. The reliability of the computations depends on the number of batches and on the choice of the reliability-parameter (or confidence level)$r$which is the probability of obtaining a majority of wrong results. According to the Chernoff inequality, the required number of batches can be expressed as"/>
          <formula id="id22" value="Token(TokenType.FORMULA&amp;quot;, &amp;quot;\begin{equation}&#10;   n\geq \fr{1}{(p-1/2)^2}\,\ln\left( \fr{1}{\sqrt{1-r}}\right)\,.&#10;   \label{e2-dol}&#10;   \end{equation}&amp;quot;, line=225, col=20)"/>
          <text value="For example, if the function computed is a quadratic polynomial then"/>
          <formula id="id23" value="$p=(1-r)^3$"/>
          <text value="as each batch must include at least three input points (vectors). Equations (1) and (2) show that the use of majority-vote based choice among the results obtained from uniformly chosen batches can ``amplify&amp;apos;&amp;apos; the original reliability of devices if enough batches are used. Nevertheless, the minimum number of batches required for obtaining a correct computation results with a confidence level$r$might be very large, even when the device has a small probability of errors. For example, more than 10,000 batches are required in the case of quadratic polynomials for"/>
          <formula id="id24" value="$\varepsilon=0.2$"/>
          <text value="and"/>
          <formula id="id25" value="$r=0.05$"/>
          <text value=", where"/>
          <formula id="id26" value="$\varepsilon$"/>
          <text value="is the small fraction the inputs and$r$is the reliability parameter. On the other hand, according to Eq. (1), the probability of correct computation with a reasonable number of batches is less than the original"/>
          <formula id="id27" value="$\varepsilon =0.2$"/>
          <text value=". Hence, there is no amplification of the computation reliability, that is, using the Chernoff majority rule (1) will not lead to an increase in correct computations. Consequently, in this example, given$r$, it is impossible to provide correct computations on the basis of the majority vote rule, if the number of inputs is less than 10,000 batches, as the computations are erroneous on a fraction of inputs that is greater than"/>
          <formula id="id28" value="$\varepsilon$"/>
          <text value=". A function over a group$G$is"/>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="linear"/>
          </command>
          <text value="if it maps the group$G$to a group$H$so that"/>
          <formula id="id29" value="$(x_1\oplus &#10;x_2)=f(x_1)\otimes f(x_2)$"/>
          <text value="where"/>
          <formula id="id30" value="$\oplus$"/>
          <text value="and"/>
          <formula id="id31" value="$\otimes$"/>
          <text value="are the group operations. Integer multiplication and modular multiplication are some examples for such functions. From the point of view of the computation overhead, one benefit of the linearity is that given the values"/>
          <formula id="id32" value="$f(x_1)$"/>
          <text value="and"/>
          <formula id="id33" value="$f(x_2)$"/>
          <text value="and given that"/>
          <formula id="id34" value="$x=x_1\oplus x_2$"/>
          <text value=", the function"/>
          <formula id="id35" value="$f(x)$"/>
          <text value="can be computed as"/>
          <formula id="id36" value="$f(x_1)\otimes f(x_2)$"/>
          <text value="which might be an easier computation task. An important aspect of the self-correction methods proposed in this paper is that the linearity properties of functions defined over finite fields can be utilized to increase the probability of success of a batch and, therefore, reduce the required number of batches. Error correcting codes can be used to obtain a better success rate for a batch result"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="6-dol"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=". This approach, referred to as"/>
            </braces>
          </command>
          <command value="\textit">
            <braces>
              <text value="\textit{}"/>
            </braces>
            <text value="batch self-corrector"/>
          </command>
          <text value=", has been applied to the function"/>
          <formula id="id37" value="$f(x)=x\,\mathrm{mod}\, R$"/>
          <text value="over the positive integers domain"/>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="6-dol"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=". In addition, it has been used for self-testing, which is a part of the self-correction techniques. For example, Spielman suggested using the result of encoding functions defined over a finite field in order to increase the probability of correct computations of batches"/>
            </braces>
          </command>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="7-dol"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=". Assume that one is able to digitize (discretize) the input domain$X$for a set of integer or rational values"/>
            </braces>
          </command>
          <command value="\cite">
            <braces>
              <braces>
                <text value="{}"/>
                <text value="8-dol"/>
              </braces>
            </braces>
            <braces/>
            <braces>
              <text value=", thereby transforming the given function to the domain/range of finite fields. Then, if the function is a polynomial, it becomes an integer function. Furthermore, if one is able to use the linearity properties to reduce the number of batches, then only the ``improved&amp;apos;&amp;apos; integer function has to be applied to the final real computation. This results in the following stages for computing"/>
            </braces>
          </command>
          <formula id="id38" value="$f(x)$"/>
          <text value=":"/>
          <enumerate/>
          <figure id="id39" value="Token(TokenType.COMMAND&amp;quot;, &amp;quot;\begin{figure*}&#10;   \vspace*{1pt}&#10; \begin{center}&#10; \mbox{%&#10; \epsfxsize=150.174mm&#10; \epsfbox{dol-2.eps}&#10; }&#10; \end}&#10; \vspace*{-6pt}&#10;\Caption{Correctness probability vs.\ correction rate~(\textit{a})&#10;and vs.\ the logarithm of the number of batches~(\textit{b}) for different ALU error rates: &#10;\textit{1}~--- 0.2; \textit{2}~--- 0.3; and &#10;\textit{3}~--- 0.4}&#10;\end{figure*}&amp;quot;, line=282, col=16)"/>
        </subsection>
      </section>
      <section id="id40">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Amplification by Polynomial Interpolation with Error Correction"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="Error correcting codes can be used to exploit linearity"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="8-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". For example, the Reed--Solomon (RS) code of a polynomial over a finite field has linear properties"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="7-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Let"/>
          </braces>
        </command>
        <formula id="id41" value="$(E,D)$"/>
        <text value="be an encoding-decoding pair for an error- correcting code of a code-word of length$n$with rate$T$(that is, a code that can correct$T$bits or symbols) for a polynomial function. For example, consider the Berlekamp--Welch algorithm, of RS codes polynomials computation in the presence of errors of interpolation over a finite field"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="9-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". The polynomial$P$is unknown; and the only information about$P$is that it is of degree of$l$(say,$l=2$). The polynomial$E$is unknown as well. Using the relationship defined above, one can produce a linear system whose solutions are the coefficients of$P$and$E$. This is shown in the following equations. Let"/>
          </braces>
        </command>
        <formula id="id42" value="$Q(X)=aX^3+bX^2+cX+d=P(X) E(X)$"/>
        <text value="where$a$,$b$,$c$, and$d$are unknown coefficients. Substituting"/>
        <formula id="id43" value="$P(X)$"/>
        <text value="by"/>
        <formula id="id44" value="$R(X)=P(X)/Q(X)$"/>
        <text value=", one obtains:"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="$$aX^3+bX^2+cX+d=R(X) E(X)=R(X) (X-e)$$which can be rewritten as:$$aX^3+bX^2+cX+d+R(X) e =R(X) X"/>
        <text value=".$$Now, one can substitute$X$by"/>
        <formula id="id45" value="$\{0,1,2,3,4\}$"/>
        <text value="to obtain five linear equations in five unknowns. Solving this linear system for$a$,$b$,$c$,$d$, and$e$provides the polynomials"/>
        <formula id="id46" value="$Q(X)$"/>
        <text value="and"/>
        <formula id="id47" value="$E(X)$"/>
        <text value="which enable finding"/>
        <formula id="id48" value="$P(X)$"/>
        <text value="by computing the quotient"/>
        <formula id="id49" value="$Q(X)/E(X)$"/>
        <text value=", and from$P$it is possible to recover the original (uncorrupted) values. In this case, the computation correctness probability can be defined as the probability that the number of incorrect symbols (from the specific finite field) is at most$T$. This probability is given by:"/>
        <formula id="id50" value="Token(TokenType.FORMULA&amp;quot;, &amp;quot;\begin{equation}&#10;   P_{\mathrm{corr}}=\sum\limits_{i=0}^T C_N^i \varepsilon^i (1-\varepsilon)^{N-i}&#10;   \label{e3-dol}&#10;   \end{equation}&amp;quot;, line=326, col=20)"/>
        <text value="where$N$is the degree of the polynomials, which is the number of points used for interpolation, referred to as the block size ($N=2$in the case of a quadratic interpolating polynomials), and"/>
        <formula id="id51" value="$\varepsilon$"/>
        <text value="corresponds to the probability of a symbol error. Obviously, the code distance is"/>
        <formula id="id52" value="$T=(n-&#10;k)/2$"/>
        <text value=", where$k$is the number of data symbols that has to be maintained. That is, for$T=1$, a (5,3) code is obtained,$T=2$results in a (7,3) code, and$T=3$provides a (9,3) code, where the left value in a pair of numbers that describe a code is the code-word length, and the right value is the number of data symbols. Figure 2"/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="a"/>
        </command>
        <text value="shows the batches correctness probability ("/>
        <formula id="id53" value="$P_{\mathrm{corr}}$"/>
        <text value=") computed using Eq. (2) vs."/>
        <text value="the correction rate$T$(the$x$axis) for different device errors. As seen in the figure, the probability of a correct result can be increased using the data correction encoding (e."/>
        <text value="g., the RS codes). Correspondingly, in some cases, due to this encoding, one can afford to work with greater fraction of erroneously computed inputs. This means that amplification of the original probability (by using 3-symbols error correction) is possible even when the error probability of the device is approximately 0.3; moreover, such a correction is essential in the case that the error probability is around 0.4. Thus, if one deals with a discrete function (whose domain is a finite field) where RS-encoding can be used, it is possible to improve the probability of correct computation by repeating the computation using uniform random inputs (from this finite field), interpolating them, and choosing the result according to a majority vote rule. Figure 2"/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="b"/>
        </command>
        <text value="presents an example of the computation of correctness probability vs."/>
        <text value="the logarithm (log base 10 is denoted as ``lg&amp;apos;&amp;apos;) of the number of batches for different ALU error rates with RS (7,3). This corresponds to RS encoding that corrects two symbols ($T=2$), when the probability of a symbol error, which is equal in this instance to the erroneous fraction of inputs"/>
        <formula id="id54" value="$\varepsilon$"/>
        <text value=", is"/>
        <formula id="id55" value="$P_s=0.3$"/>
        <text value="; and"/>
        <formula id="id56" value="$P_{\mathrm{corr}}=0.647$"/>
        <text value=". In this case, the amplification of the correct probability starts when 21 batches are used, a considerably lower number of batches than for the case of noncoded batches. In comparison, in the case of"/>
        <formula id="id57" value="$\varepsilon=0.3$"/>
        <text value=", error correction is impossible for noncoded batches as"/>
        <formula id="id58" value="$(1-r)^3&amp;lt;1/2$"/>
        <text value="and is irrelevant for the majority-vote-based choice algorithm. One should take into account, however, the need for 4 extra points for each batch (7 instead of 3) to achieve this improvement."/>
        <braces>
          <text value="{}"/>
        </braces>
        <text value="Nevertheless, adding points to a batch can significantly reduce the required number of batches even when$p$is only slightly larger than$1/2$."/>
      </section>
      <section id="id59">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Real Function Reconstruction"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="The feasibility of implementation of the self-correcting algorithm proposed in this paper for an error correction in analog hardware depends on existence of appropriate transformation of real signals input (numbers) to finite fields. As shown below, the state-of-the-art of analog-digital design allows finding proper solutions of this problem. Note that the explicit reconstructing polynomials and rational functions over finite fields are presented by Sigal"/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="et al"/>
        </command>
        <text value="."/>
        <text value="in"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="3-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Sigal"/>
          </braces>
        </command>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="et al"/>
        </command>
        <text value="."/>
        <text value="use the fact that multiplication of any fixed element of finite fields by a random uniformly distributed element of the field gives a result that is uniformly distributed over the field. Therefore, in order to use the random self-reducibility-based approach to self-correction of real functions, one should consider discrete transformation of these functions to finite fields and commence with reconstruction of the functions. In general, the reconstruction of real continuous function from digital data is governed by the"/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="Nyquist sampling theorem"/>
        </command>
        <text value=""/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="6-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", which requires that a band-limited continuous function is sampled with a frequency equal to, or greater than, twice the maximum frequency of the signal. This digitization-reconstruction model, however, is not suitable in the context of self-correction, since the function is interpolated by algebraic polynomials. Moreover, the batches include randomly generated points. Hence, nonuniform discretization is required. This raises additional difficulties in the reconstruction"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="8-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". In addition, the"/>
          </braces>
        </command>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="quantization"/>
        </command>
        <text value="of function values implies representation by a finite number of bits (say,$n$bits). Due to the finite precision representation of real numbers in computational devices; roundoff errors might occur during the calculations. The problem is finding the minimum accuracy necessary to ensure that the inverse quantization transformation that is a part of the digital-to-analog transformation can perform rounding and roundoff. This would make the function result equivalent to the rounding of the exact result (which could be obtained by the device) for all possible inputs. Since real-valued polynomial interpolations, say, Tailor polynomials, are defined over input variables given as real numbers, they cannot be used to express the finite bit-width limitations. Thus, one should coordinate the number of Tailor series terms and the number of bits in the aforementioned finite numbers representation. In order to resolve this problem, it is possible to use the technique presented in"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="12-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=", where the coefficients of the series are expressed in terms of a finite number of bits referred to as fractional bits (FB). Several techniques for finding the necessary numbers of the Tailor series coefficients given a specific number of FBs are suggested in"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="12-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Another mean for increasing the accuracy is segmentation, which refers to dividing the input into subintervals, slices, or segments"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="10-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Generally, a set of coefficients of a low-degree polynomial can be used to evaluate each segment, and the error probability is computed independently for each segment"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="10-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Note that the degree is an important parameter since a small degree enables correcting more errors using the Berlekamp--Welch algorithm. An evaluation of the obtained accuracy can be controlled by varying the number of segments and/or the polynomial degree. Using online segmentation requires predicting the interpolation error for each segment. For several differential functions, this error depends on the first$d+1$derivatives"/>
          </braces>
        </command>
        <formula id="id60" value="$f^{(d+1)}(x)$"/>
        <text value=", where$d$is the degree of the interpolation polynomial, can be calculated during a preprocessing stage"/>
        <text value="13"/>
        <text value="."/>
      </section>
      <section id="id61">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Synopsys"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="The computation of the value of"/>
        <formula id="id62" value="$f(x)$"/>
        <text value="at a given point by evaluation at several random points can be implemented via interpolation of"/>
        <formula id="id63" value="$f(x)$"/>
        <text value="using samples of$x$. For example, the input data of an ALU, which can be faulty with some known probability, can be considered as a set or series of batches, each of which is a series of$k$randomly generated arguments"/>
        <formula id="id64" value="$r_{i,j}$"/>
        <text value="where"/>
        <formula id="id65" value="$i=1,\ldots ,m$"/>
        <text value="is the number of the ALU random inputs needed for interpolation; for example,$m=2$for the linear interpolation and"/>
        <formula id="id66" value="$k=l+1$"/>
        <text value="in the case of the interpolating polynomial of degree$l$. The variable"/>
        <formula id="id67" value="$j=1,\ldots ,n$"/>
        <text value="is the number of interpolations (number of batches of computations). The series quantity must provide a reliable choice of result of interpolation by majority in the sequence of results of interpolation obtained from the batches. The model suggested in"/>
        <text value="3, 4"/>
        <text value="which uses uniform batches of random inputs is practical only in the case of relatively small error probability"/>
        <formula id="id68" value="$\varepsilon$"/>
        <text value=". Nevertheless, even in the relatively simple case of the quadratic polynomial, the batch correctness probability defined by the Chernoff-bound success probability of 0.512 for"/>
        <formula id="id69" value="$\varepsilon=0.2$"/>
        <text value="might imply a much smaller success probability for all polynomials of degrees$d&amp;gt;2$. Computation in a finite field is one possible way to increase the batches&amp;apos; correctness probability. This means operating with encoded data using coding methods such as RS codes and the Berlekamp--Welch algorithm"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="7-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". This coding is an interpolation as it provides computation of polynomials in all the required points, using several points where the polynomial is known. In fact, the building of polynomials in the Berlekamp-Welch decoding algorithm is similar to Lagrange interpolation. Note that, in effect, different types of errors of computation (referred to as ``ALU"/>
          </braces>
        </command>
        <command value="\_errors">
          <braces>
            <text value="&amp;apos;&amp;apos;) are considered in the compared approaches. While the symbol (bit) error relates to a specific error rate$T$(say,$T=3$), the error considered in self-correcting program theory (e."/>
          </braces>
        </command>
        <text value="g., in"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="3-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=") is only a small fraction"/>
          </braces>
        </command>
        <formula id="id70" value="$\varepsilon$"/>
        <text value="of erroneous computed inputs. This means that for the"/>
        <formula id="id71" value="$(1-\varepsilon)$"/>
        <text value="fraction of inputs"/>
        <formula id="id72" value="$\mu(f(x),f_C(x))\leq \sigma$"/>
        <text value="where"/>
        <formula id="id73" value="$f_C(x)$"/>
        <text value="is the function"/>
        <formula id="id74" value="$f(x)$"/>
        <text value="computed by the ALU;"/>
        <formula id="id75" value="$\mu (f(x), f_C(x))$"/>
        <text value="is the measure of distance between the exact value"/>
        <formula id="id76" value="$f(x)$"/>
        <text value="and the computed function"/>
        <formula id="id77" value="$f_C(x)$"/>
        <text value="; and"/>
        <formula id="id78" value="$\sigma$"/>
        <text value="is the threshold error value. In general,"/>
        <formula id="id79" value="$\sigma$"/>
        <text value="corresponds to other erroneous quantities of bits. As for DSP-based classification tasks, mentioned above as a prospective field of the self-correcting approach application, many current approaches use various polynomials to compute the classification characteristics, e."/>
        <text value="g., spline approximation in image processing. Therefore, in the event that the DSP computes the characteristics correctly on all but a small fraction"/>
        <formula id="id80" value="$\varepsilon$"/>
        <text value="of inputs, the algorithms mentioned above are suitable, and implementation of the computation schema, presented in sections 2--4, can essentially improve the classification reliability in comparison with the DSP characteristic"/>
        <formula id="id81" value="$\varepsilon$"/>
        <text value=". Since the error correction can be interpreted as a ``decoding of code-words,&amp;apos;&amp;apos; one can borrow several ideas from Locally Decodable Codes (LDC)"/>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="13-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". Locally decodable codes are the correcting codes where in order to retrieve the correct value of just one position of the input with high probability, it is sufficient to read a small number of positions of the corresponding possibly corrupted code-word. The locally decodable code can recover from a much higher error-rate"/>
          </braces>
        </command>
        <command value="\cite">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="4-dol"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <text value=". One of the reasons for using LDC is that the previously used RS code consists of complete evaluations of polynomials of total degree up to$d$. In particular, there are LDCs which provide reduction of the error rate of the code with the number of queries which can be essentially higher than the polynomial degree$d$. Hence, the polynomial degree is not a limiting factor for the fraction of erroneous results reduction. In this context, the term"/>
          </braces>
        </command>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="query"/>
        </command>
        <text value="is a measure of complexity computed by the number of bits that need to be read from a corrupted code-word in order to recover a single bit of the encoded word"/>
        <text value="14"/>
        <text value=". It should be noted that LDCs are based on the classical Reed--Muller (RM) codes, which have rather simple and fast hardware implementation"/>
        <text value="15"/>
        <text value="."/>
      </section>
      <section id="id82">
        <braces>
          <text value="\section{}"/>
        </braces>
        <text value="Concluding Remarks and Proposals for Future Research"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="In this paper, recent results in self-correcting computations have been presented. As the results show, in spite of essential reduction in the number of batches needed for suitable computation accuracy, this number might be rather significant. The complexity of the proposed approach depends on the number of"/>
        <text value="batches as well as on the complexity of decoding the codes used for increasing correct computation probability for each batch. Feasible ways for improving the amplification have been proposed and it has been demonstrated that these methods can minimize the number of batches of the computation function used to correct the computed value and provide a significant decrease in the error probability with the number of the batches used. Furthermore, a hardware implementation of this approach to self-correction can be derived from hardware implementation of the coding methods such as RS and RM"/>
        <text value="15, 16"/>
        <text value=". In the future, both the theory of random self-reducibility and new results in LDC will be explored for the problem of reconstruction of real numerical functions for correcting faults remaining in hardware after manufacturing testing. In addition, the authors plan to explore nonuniform sampling methods such as compressive sensing. Furthermore, a study of technical details of hardware implementation as well as DSP-based solutions will be performed."/>
        <braces>
          <text value="{}"/>
          <command value="\small"/>
          <command value="\frenchspacing">
            <braces>
              <braces>
                <text value="{}"/>
              </braces>
            </braces>
          </command>
        </braces>
        <command value="\begin">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="99"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <item id="id83" value="\bibitem">
          <braces>
            <text value="\bibitem{1-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Bil"/>
        <formula id="id84" value="$\acute{\mbox{e}}$"/>
        <text value="n, S., and A. Price"/>
        <text value=". 2007. Modulation classification for radio interoperability via SDR."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="SDR 07 Technical Conference and Product Exposition Proceedings"/>
        </command>
        <text value="."/>
        <braces>
          <text value="{}"/>
          <command value="\sf">
            <braces>
              <text value="http://www.slideshare.net/kirill443/12-4-5647963"/>
            </braces>
            <braces/>
            <braces>
              <text value="(accessed November 7, 2013)."/>
            </braces>
          </command>
        </braces>
        <item id="id85" value="\bibitem">
          <braces>
            <text value="\bibitem{2-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Lala, P."/>
        <text value="2000."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="Self-checking and fault-tolerant digital design"/>
        </command>
        <text value=". Morgan Kaufmann Publs. 400 p."/>
        <item id="id86" value="\bibitem">
          <braces>
            <text value="\bibitem{3-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Sigal, A., R. Lipton, R. Rubinfeld, and M. Sudan"/>
        <text value=". 1990. Reconstructing algebraic functions from mixed data."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="33rd Annual Symposium on Foundations of Computer Science."/>
        </command>
        <text value="503--512."/>
        <item id="id87" value="\bibitem">
          <braces>
            <text value="\bibitem{4-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Gemmell, P., R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson"/>
        <text value=". 1991. Self-testing/correcting for polynomials and for approximate functions."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="23rd Annual ACM Symposium on Theory of Computing Proceedings"/>
        </command>
        <text value=". 32--34."/>
        <item id="id88" value="\bibitem">
          <braces>
            <text value="\bibitem{12-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Lee, D."/>
        <text value="U., R. Cheung, W. Luk, and J. Villasenor"/>
        <text value=". 2008. Hardware implementation trade-offs of polynomial approximations and interpolations."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="IEEE Trans. Comput."/>
        </command>
        <text value="57(5):686--701."/>
        <item id="id89" value="\bibitem">
          <braces>
            <text value="\bibitem{14-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Dolev, Sh., and S. Frenkel"/>
        <text value=". 2009. Extending the scope of self-correcting."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="13th Conference (International) on Applied Stochastic Models and Data Analysis (ASMDA2009) Proceedings"/>
        </command>
        <text value=". 458--462."/>
        <item id="id90" value="\bibitem">
          <braces>
            <text value="\bibitem{5-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Nicely, T."/>
        <text value="R."/>
        <braces>
          <text value="{}"/>
          <text value="Some results of computational research in prime numbers (Computational number theory)"/>
        </braces>
        <text value="."/>
        <braces>
          <text value="{}"/>
          <command value="\sf">
            <braces>
              <text value="http://www.trnicely.net/pentbug/pentbug.html"/>
            </braces>
            <braces/>
            <braces>
              <text value="(accessed December 2010)."/>
            </braces>
          </command>
        </braces>
        <item id="id91" value="\bibitem">
          <braces>
            <text value="\bibitem{6-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Rubinfeld, R."/>
        <text value="1992. Batch checking with applications to linear functions."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="Inform. Process. Lett."/>
        </command>
        <text value="42:77--80."/>
        <item id="id92" value="\bibitem">
          <braces>
            <text value="\bibitem{7-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Spielman, D."/>
        <text value="1996. Highly fault-tolerant parallel computation."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="37th IEEE Annual Symposium on Foundations of Computer Science Proceeding"/>
        </command>
        <text value=". 154--163."/>
        <item id="id93" value="\bibitem">
          <braces>
            <text value="\bibitem{8-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Oppenheim, A."/>
        <text value="V., R."/>
        <text value="W. Schafer, and J."/>
        <text value="R. Buck"/>
        <text value=". 1999."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="Discrete-time signal processing"/>
        </command>
        <text value=". Upper Saddle River, NJ: Prentice-Hall. 871 p."/>
        <item id="id94" value="\bibitem">
          <braces>
            <text value="\bibitem{9-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Berlekamp, E., and L. Welch"/>
        <text value=". 1986. Error correction of algebraic block codes. U.S. Patent No."/>
        <text value="4,633,470."/>
        <item id="id95" value="\bibitem">
          <braces>
            <text value="\bibitem{10-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Tertinek, S., and C. Vogel"/>
        <text value=". 2008. Reconstruction of nonuniformly sampled bandlimited signals using a differentiator-multiplier cascade."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="IEEE Trans. Circuits Syst."/>
        </command>
        <text value="55(8):2273---2286."/>
        <item id="id96" value="\bibitem">
          <braces>
            <text value="\bibitem{11-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Pang, Y., and K. Radecka"/>
        <text value=". 2008. Optimizing imprecise fixed-point arithmetic circuits specified by Taylor series through arithmetic transform."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="Design Automation Conference DAC&amp;apos;08 Proceedings"/>
        </command>
        <text value=". 397--402."/>
        <item id="id97" value="\bibitem">
          <braces>
            <text value="\bibitem{13-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Yekhanin, S."/>
        <text value="2011. Locally decodable codes."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="Foundations Trends Theoretical Computer Sci."/>
        </command>
        <text value="7(1):1--117."/>
        <item id="id98" value="\bibitem">
          <braces>
            <text value="\bibitem{14-1-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Rahardja, S., and B."/>
        <text value="J. Falkowski"/>
        <text value=". 2001. Efficient algorithm to calculate Reed--Muller expansions over GF(4)."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
        </command>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="Circuits, Devices and Systems"/>
        <text value=". 148(6):289, 297."/>
        <item id="id99" value="\bibitem">
          <braces>
            <text value="\bibitem{14-2-dol}"/>
          </braces>
        </item>
        <author value="\Aue{}"/>
        <text value="Leroux, C., G. Le Mestre, C. Jego, P. Adde, and M. Jezequel."/>
        <text value="2008. A 5-Gbps FPGA prototype of a (31,29)$^2$Reed--Solomon turbo decoder."/>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="5th Symposium (International) on Turbo Codes and Related Topics Proceedings"/>
        </command>
        <text value=". 67--72."/>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="thebibliography"/>
            </braces>
          </braces>
          <braces/>
          <braces/>
          <braces/>
        </command>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="multicols"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-6pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\hfill">
          <braces>
            <braces>
              <text value="{}"/>
              <command value="\small"/>
            </braces>
          </braces>
        </command>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="Received October 23, 2013"/>
        </command>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="-12pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\Contr"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Dolev Shlomi"/>
        </command>
        <text value="(b."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="professor, Doctor of Science in computer science, Dean of the Faculty of Natural Sciences, Ben-Gurion University of the Negev, Beer-Sheva 84105, Israel; dolev@cs.bgu.ac.il"/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="3pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Frenkel Sergey L."/>
        </command>
        <text value="(b."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="Candidate of Science (PhD) in technology, senior scientist, Institute of Informatics Problems, Russian Academy of Sciences, Moscow 119333, Russian Federation; associate professor, Moscow Institute of Radio, Electronics, and Automation (MIREA), Moscow 119454, Russian Federation; fsergei@mail.ru"/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="3pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
          <text value="Tamir Dan E."/>
        </command>
        <text value="(b."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="PhD-CS, associate professor in the Department of Computer Science, Texas State University, San Marcos, TX 78666, USA; dt19@txstate.edu"/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="12pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\hrule"/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="2pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\hrule"/>
        <text value="ВЕРОЯТНОСТНЫЙ ПОДХОД К САМОКОРРЕКТИРУЮЩИМСЯ ВЫЧИСЛЕНИЯМ В ПРОЕКТИРОВАНИИ АППАРАТУРЫ"/>
        <text value="Ш. Долев$^1$, С. Френкель$^2$, Д."/>
        <text value="Е. Тамир$^3$"/>
        <text value="Вероятностный подход к самокорректирующимся вычислениям в проектировании аппаратуры"/>
        <text value="Ш. Долев, С. Френкель, Д."/>
        <text value="Е. Тамир"/>
        <command value="\titel">
          <braces>
            <braces>
              <text value="{}"/>
              <command value="\tit">
                <braces/>
                <braces>
                  <braces>
                    <text value="{}"/>
                    <command value="\aut">
                      <braces/>
                      <braces>
                        <braces>
                          <text value="{}"/>
                          <command value="\autkol">
                            <braces/>
                            <braces>
                              <braces>
                                <text value="{}"/>
                                <command value="\titkol">
                                  <braces/>
                                </command>
                                <command value="\vspace*">
                                  <braces>
                                    <braces>
                                      <text value="{}"/>
                                      <text value="-12pt"/>
                                    </braces>
                                  </braces>
                                  <braces/>
                                </command>
                              </braces>
                            </braces>
                          </command>
                        </braces>
                      </braces>
                    </command>
                  </braces>
                </braces>
              </command>
            </braces>
          </braces>
        </command>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="$^1$Университет им."/>
        <text value="Бен-Гуриона в Негаве, Беэр-Шева, Израиль, dolev@cs.bgu.ac.il"/>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="$^2$Институт проблем информатики Российской академии наук; Московский государственный технический"/>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <formula id="id100" value="$\hphantom{^1}$"/>
        <text value="университет радиотехники, электроники и автоматики (МГТУ МИРЭА), Москва, Россия,"/>
        <command value="\linebreak">
          <braces>
            <text value="\linebreak"/>
          </braces>
        </command>
        <formula id="id101" value="$\hphantom{^1}$"/>
        <affiliation>
          <braces>
            <text value="fsergei@mail.ru"/>
          </braces>
        </affiliation>
        <command value="\noindent">
          <braces>
            <text value="\noindent"/>
          </braces>
        </command>
        <text value="$^3$Университет Техаса, г."/>
        <text value="Сан-Маркос, США, dt19@txstate.edu"/>
        <command value="\vspace*">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="6pt"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\small">
          <braces>
            <braces>
              <text value="{}"/>
            </braces>
          </braces>
        </command>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
        </command>
        <command value="\thepage">
          <braces/>
        </command>
        <command value="\hfill">
          <braces>
            <text value="ИНФОРМАТИКА И ЕЁ ПРИМЕНЕНИЯ"/>
          </braces>
        </command>
        <text value="том"/>
        <text value="7"/>
        <text value="выпуск"/>
        <text value="4"/>
        <text value="2013"/>
        <command value="\small">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="ИНФОРМАТИКА И ЕЁ ПРИМЕНЕНИЯ"/>
            </braces>
          </braces>
        </command>
        <text value="том"/>
        <text value="7"/>
        <text value="выпуск"/>
        <text value="4"/>
        <text value="2013"/>
        <command value="\hfill"/>
        <command value="\textbf">
          <braces>
            <text value="\textbf{}"/>
          </braces>
        </command>
        <command value="\thepage">
          <braces/>
          <braces/>
          <braces/>
        </command>
        <annotation value="\Abst{Описаны некоторые подходы к распространению метода самокоррекции программ, основанного на свойстве &amp;lt;&amp;lt;случайной самосокращаемости&amp;gt;&amp;gt; (random self-reducibility), на задачи проектирования аппаратной части вычислительных систем. Данная концепция может быть использована для проектирования как цифровой, так и аналоговой аппаратуры. Расширение метода основано на использовании случайных выборок, полиномиальной интерполяции и теории самокорректирующихся кодов. В частности, предлагается использовать известные методы реконструкции числовых функций для коррекции ошибок, вызываемых неисправностями, остающимися в аппаратуре после производственного контроля. Предлагаемый подход может дополнять известные методы тестирования цифровых и аналоговых приборов посредством использования равновероятной выборки операций и верификации результатов их выполнения, обеспечивая приемлемый уровень (небольшую долю) неправильных результатов.}"/>
        <keywords>
          <braces>
            <text value="\KW{самокоррекция; вычисление действительных функций; анализ данных; интерполяция}"/>
          </braces>
        </keywords>
        <text value="Расширенные тезисы данной статьи были представлены на 13-й Международной конференции по прикладным стохастическим моделям и анализу данных (ASMDA-2009). Работа выполнена при частичной поддержке Российского фонда фундаментальных исследований (грант №"/>
        <text value="12-07-00109), Фонда главы отделения информатики Риты Алтура, Центра вычислительной техники им."/>
        <text value="Линне и Уильяма Франкелей, Израильского научного фонда (грант №"/>
        <text value="428/11), Кабарнит кибербезопасности консорциума &amp;lt;&amp;lt;Магнит&amp;gt;&amp;gt;, гранта Института перспективных оборонных технологий им."/>
        <text value="Медведи (Технион) и Израильской Интернет ассоциации."/>
        <command value="\begin">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="2"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\renewcommand">
          <braces>
            <braces>
              <text value="{}"/>
              <command value="\bibname">
                <braces/>
                <braces>
                  <braces>
                    <text value="{}"/>
                    <command value="\protect"/>
                    <command value="\rmfamily">
                      <braces>
                        <text value="Литература"/>
                      </braces>
                      <braces/>
                    </command>
                  </braces>
                </braces>
              </command>
            </braces>
          </braces>
        </command>
        <braces>
          <text value="{}"/>
          <command value="\small"/>
          <command value="\frenchspacing">
            <braces>
              <braces>
                <text value="{}"/>
              </braces>
            </braces>
          </command>
        </braces>
        <command value="\addcontentsline">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="toc"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="section"/>
            </braces>
          </braces>
          <braces/>
          <braces>
            <braces>
              <text value="{}"/>
              <text value="References"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\begin">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="99"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <item id="id102" value="\bibitem">
          <braces>
            <text value="\bibitem{1-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Bil"/>
        <formula id="id103" value="$\acute{\mbox{e}}$"/>
        <text value="n S., Price A."/>
        <text value="Modulation classification for radio interoperability via SDR //"/>
        <braces>
          <text value="{}"/>
          <text value="SDR 07 Technical Conference and Product Exposition Proceedings"/>
        </braces>
        <text value=", 2007."/>
        <braces>
          <text value="{}"/>
          <command value="\sf">
            <braces>
              <text value="http://www.slideshare.net/kirill443/12-4-5647963"/>
            </braces>
            <braces/>
            <braces>
              <text value="(accessed November 7, 2013)."/>
            </braces>
          </command>
        </braces>
        <item id="id104" value="\bibitem">
          <braces>
            <text value="\bibitem{2-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Lala P."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="Morgan Kaufmann Publs., 2000. 400 с."/>
        <item id="id105" value="\bibitem">
          <braces>
            <text value="\bibitem{3-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Sigal A., Lipton R., Rubinfeld R., Sudan M"/>
        <text value=". Reconstructing algebraic functions from mixed data //"/>
        <braces>
          <text value="{}"/>
          <text value="33rd Annual Symposium on Foundations of Computer Science"/>
        </braces>
        <text value=", 1990. P. 503--512."/>
        <item id="id106" value="\bibitem">
          <braces>
            <text value="\bibitem{4-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Gemmell P., Lipton R., Rubinfeld R., Sudan M., Wigderson A"/>
        <text value=". Self-testing/correcting for polynomials and for approximate functions //"/>
        <braces>
          <text value="{}"/>
          <text value="23rd Annual ACM Symposium on Theory of Computing Proceedings"/>
        </braces>
        <text value=", 1991. P. 32--34."/>
        <item id="id107" value="\bibitem">
          <braces>
            <text value="\bibitem{12-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Lee D."/>
        <text value="U., Cheung R., Luk W., Villasenor J."/>
        <text value="Hardware implementation trade-offs of polynomial approximations and interpolations //"/>
        <braces>
          <text value="{}"/>
          <text value="IEEE Trans. Comput."/>
        </braces>
        <text value=", 2008. Vol. 57. No."/>
        <text value="5. P. 686--701."/>
        <item id="id108" value="\bibitem">
          <braces>
            <text value="\bibitem{14-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Dolev Sh., Frenkel S"/>
        <text value=". Extending the scope of self-correcting //"/>
        <braces>
          <text value="{}"/>
          <text value="13th Conference (International) on Applied Stochastic Models and Data Analysis (ASMDA2009) Proceedings"/>
        </braces>
        <text value=", 2009. С. 458--462."/>
        <item id="id109" value="\bibitem">
          <braces>
            <text value="\bibitem{5-dol-}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Nicely T."/>
        <text value="R."/>
        <braces>
          <text value="{}"/>
          <text value="Some results of computational research in prime numbers (Computational number theory)"/>
        </braces>
        <text value="."/>
        <braces>
          <text value="{}"/>
          <command value="\sf">
            <braces>
              <text value="http://www.trnicely.net/pentbug/pentbug.html"/>
            </braces>
            <braces/>
            <braces>
              <text value="(last retrieved December 2010)."/>
            </braces>
          </command>
        </braces>
        <item id="id110" value="\bibitem">
          <braces>
            <text value="\bibitem{6-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Rubinfeld R."/>
        <text value="Batch checking with applications to linear functions //"/>
        <braces>
          <text value="{}"/>
          <text value="Inform. Process. Lett."/>
        </braces>
        <text value=", 1992. Vol. 42. P. 77--80."/>
        <item id="id111" value="\bibitem">
          <braces>
            <text value="\bibitem{7-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Spielman D."/>
        <text value="Highly fault-tolerant parallel computation //"/>
        <braces>
          <text value="{}"/>
          <text value="37th IEEE Annual Symposium on Foundations of Computer Science Proceeding"/>
        </braces>
        <command value="\specialsymbol">
          <braces>
            <text value="~"/>
          </braces>
        </command>
        <text value="154--163."/>
        <item id="id112" value="\bibitem">
          <braces>
            <text value="\bibitem{8-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Oppenheim A."/>
        <text value="V., Schafer R."/>
        <text value="W., Buck J."/>
        <text value="R."/>
        <braces>
          <text value="{}"/>
          <text value="Discrete-time signal processing"/>
        </braces>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="Upper Saddle River, NJ: Prentice- Hall, 1999. 871 p."/>
        <item id="id113" value="\bibitem">
          <braces>
            <text value="\bibitem{9-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Berlekamp E., Welch L."/>
        <text value="Error correction of algebraic block codes. U.S. Patent No."/>
        <text value="4,633,470, 1986."/>
        <item id="id114" value="\bibitem">
          <braces>
            <text value="\bibitem{10-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Tertinek S., Vogel C"/>
        <text value=". Reconstruction of nonuniformly sampled bandlimited signals using a differentiator-multiplier cascade //"/>
        <braces>
          <text value="{}"/>
          <text value="IEEE Trans. Circuits Syst."/>
        </braces>
        <text value=", 2008. Vol. 55. No."/>
        <text value="8. P. 2273--2286."/>
        <item id="id115" value="\bibitem">
          <braces>
            <text value="\bibitem{11-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Pang Y., Radecka K"/>
        <text value=". Optimizing imprecise fixed-point arithmetic circuits specified by Taylor series through arithmetic transform //"/>
        <braces>
          <text value="{}"/>
          <text value="Design Automation Conference DAC&amp;apos;08 Proceedings"/>
        </braces>
        <text value=", 2008. P. 397--402."/>
        <item id="id116" value="\bibitem">
          <braces>
            <text value="\bibitem{13-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Yekhanin S."/>
        <text value="Locally decodable codes //"/>
        <braces>
          <text value="{}"/>
          <text value="Foundations Trends Theoretical Computer Sci."/>
        </braces>
        <text value=", 2011. Vol. 7. Iss. 1. P. 1--117."/>
        <item id="id117" value="\bibitem">
          <braces>
            <text value="\bibitem{14-1-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Rahardja S., Falkowski B."/>
        <text value="J."/>
        <command value="\specialsymbol">
          <braces>
            <text value="~---"/>
          </braces>
        </command>
        <text value="Circuits, Devices and Systems, 2001. Vol. 148. No."/>
        <text value="6. P. 289, 297."/>
        <item id="id118" value="\bibitem">
          <braces>
            <text value="\bibitem{14-2-dol-1}"/>
          </braces>
        </item>
        <author value="\Au{}"/>
        <text value="Leroux C., Le Mestre G., Jego C., Adde P., Jezequel M."/>
        <text value="A 5-Gbps FPGA prototype of a (31,29)$^2$Reed--Solomon turbo decoder // 5th Symposium (International) on Turbo Codes and Related Topics Proceedings, 2008. P. 67--72."/>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="thebibliography"/>
            </braces>
          </braces>
          <braces/>
          <braces/>
          <braces/>
        </command>
        <command value="\end">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="multicols"/>
            </braces>
          </braces>
          <braces/>
        </command>
        <command value="\label">
          <braces>
            <braces>
              <text value="{}"/>
              <text value="end"/>
              <command value="\stat">
                <braces/>
              </command>
              <command value="\hfill">
                <braces>
                  <braces>
                    <text value="{}"/>
                    <command value="\small"/>
                  </braces>
                </braces>
              </command>
            </braces>
          </braces>
        </command>
        <command value="\textit">
          <braces>
            <text value="\textit{}"/>
          </braces>
          <text value="Поступила в редакцию 23.10.13"/>
        </command>
        <command value="\renewcommand">
          <braces>
            <braces>
              <text value="{}"/>
              <command value="\figurename">
                <braces/>
                <braces>
                  <braces>
                    <text value="{}"/>
                    <command value="\protect"/>
                    <command value="\bf">
                      <braces>
                        <text value="Рис."/>
                      </braces>
                      <braces/>
                    </command>
                  </braces>
                </braces>
              </command>
            </braces>
          </braces>
        </command>
      </section>
    </fulltext>
  </paper>
</papers>